<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="xml-quotations.css"?>

<!DOCTYPE quotations SYSTEM "quotations.dtd" [
  <!ENTITY ccedil "&#231;">
]>

<quotations>

<quotation>
We will perhaps eventually be writing only small modules which are
identified by name as they are used to build larger ones, so that
devices like indentation, rather than delimiters, might become
feasible for expressing local structure in the source language.

<source>Donald E. Knuth, "Structured Programming with goto
Statements", Computing Surveys, Vol 6 No 4, Dec. 1974</source>
</quotation>

<quotation>
Some rejected alternate names for "Monty Python's Flying Circus":
<br/>
1 2 3 /				It's Them!	
/
Arthur Megapode's Flying Circus	/	The Horrible Earnest Megapode
/
The Panic Show			/	The Plastic Mac Show
/
Ow!  It's Colin Plint!		/	Vaseline Review
/
Vaseline Parade			/	The Keen Show
/
Brian's Flying Circus		/	The Year of the Stoat
/
Cynthia Fellatio's Flying Circus /	Owl Stretching Time
/
The Whizzo Easishow!  (Guaranteed to last 1/2 hour!  Money back if not!)
<source>From Kim "Howard" Johnson's _Life Before and After Monty Python_.
   [It's interesting to contemplate what Python would have been called
     if one of these names had been chosen.]
</source>
</quotation>

<quotation>
Anybody else on the list got an opinion?  Should I change the language
or not?
<source>Guido van Rossum, 28 Dec 91
</source>
</quotation>

<quotation>
in-any-case-the-best-christmas-present-i-got-today!-ly y'rs - tim
<source>Tim Peters, 29 Dec 91
  [First occurrence of Tim Peters's long-phrase-ly idiom.]
</source>
</quotation>

<quotation>
Ha -- you have done me the favor of underestimating my ignorance &lt;smile&gt;.
<source>Tim Peters, 30 Dec 91</source>
</quotation>

<quotation>
I prefer (all things being equal) regularity/orthogonality and logical
syntax/semantics in a language because there is less to have to remember.
(Of course I <em>know</em> all things are NEVER really equal!)
<source>Guido van Rossum, 6 Dec 91
</source>
</quotation>

<quotation>
The details of that silly code are irrelevant.
<source>Tim Peters, 4 Mar 92
</source>
</quotation>

<quotation>
Frankly, I'd rather not try to compete with Perl in the
areas where Perl is best -- it's a battle that's impossible to win,
and I don't think it is a good idea to strive for the number of
obscure options and shortcuts that Perl has acquired through the years.
<source>Guido van Rossum, 7 Jul 1992</source>
</quotation>

<quotation>
Python is a truly wonderful language. When somebody comes up with a
good idea it takes about 1 minute and five lines to program something
that almost does what you want. Then it takes only an hour to extend
the script to 300 lines, after which it still does almost what you
want.
<source>Jack Jansen, 8 Jul 1992
</source>
</quotation>

<quotation>
If you have a browser from CERN's WWW project (World-Wide Web, a
distributed hypertext system) you can browse a WWW hypertext version
of the manual...
<source>Guido van Rossum, 19 Nov 1992
   [First mention of the Web on python-list.]
</source>
</quotation>

<quotation>
Just a success note for Guido and the list:
Python 0.9.9, stdwin, readline, gmp, and md5 all go up on
linux 0.99 pl11 without much problems.
<source>Allan Bailey, 2 Aug 93
   [First mention of Linux on python-list.]
</source>
</quotation>

<quotation>
Rule: "You shouldn't have to open up a black box and take it apart to
find out you've been pushing the wrong buttons!"

Corollary: "Every black box should have at least TWO blinking lights:
"Paper Jam" and "Service Required" (or equivalent)."
<source>Steven D. Majewski, 9 Sep 1993
</source>
</quotation>

<quotation>
We've been through a couple of syntax changes, but I have sort of
assumed that by the time we get to version 1.0 release, the language,
(if not the implementation) will essentially be stable.
<source>Steven D. Majewski, 14 Sep 1993
</source>
</quotation>

<quotation>
"Python tricks" is a tough one, cuz the language is so clean.  E.g., C
makes an art of confusing pointers with arrays and strings, which leads
to lotsa neat pointer tricks; APL mistakes everything for an array,
leading to neat one-liners; and Perl confuses everything period, making
each line a joyous adventure &lt;wink&gt;.
<source>Tim Peters, 16 Sep 93
</source>
</quotation>

<quotation>
I've seen Python criticized as "ugly" precisely because it <em>doesn't</em> have
a trick-based view of the world.  In many ways, it's a dull language,
borrowing solid old concepts from many other languages &amp; styles:  boring
syntax, unsurprising semantics, few automatic coercions, etc etc.  But
that's one of the things I like about it.
<source>Tim Peters, 16 Sep 93
</source>
</quotation>

<quotation>
One of the things that makes it interesting, is exactly how much Guido
has managed to exploit that <em>one</em> implementation trick of
'namespaces'.
<source>Steven D. Majewski, 17 Sep 1993
</source>
</quotation>

<quotation>
Anyone familiar with Modula-3 shold appreciate the difference between
a layered approach, with generic Rd/Wr types, and the Python 'C with
foam padding' approach.  
<source>John Redford, 24 Nov 93
</source>
</quotation>

<quotation>
People simply will not agree on what should and shouldn't be "an
error", and once exception-handling mechanisms are introduced to give
people a choice, they will far less agree on what to do with them.
<source>Tim Peters, 17 Dec 93
</source>
</quotation>

<quotation>
Note that because of its semantics, 'del' <em>can't</em> be a function: "del
a" deletes 'a' from the current namespace. A function can't delete
something from the calling namespace (except when written by Steve
Majewski :-).
<source>Guido van Rossum, 1 Aug 1994 
</source>
</quotation>

<quotation>
I don't know a lot about this artificial life stuff
-- but I'm suspicious of anything Newsweek gets goofy about
-- and I suspect its primary use is as another money extraction tool
to be applied by ai labs to the department of defense
(and more power to 'em).
<br/>
Nevertheless in wondering why free software is so good these days
it occurred to me that the propagation of free software is one gigantic
artificial life evolution experiment, but the metaphor isn't perfect.
<br/>
Programs are thrown out into the harsh environment, and the bad ones
die. The good ones adapt rapidly and become very robust in short
order.
<br/>
The only problem with the metaphor is that the process isn't random
at all. Python <em>chooses</em> to include Tk's genes; Linux decides
to make itself more suitable for symbiosis with X, etcetera. 
<br/>
Free software is artificial life, but better.
<source>Aaron Watters, 29 Sep 1994</source>
</quotation>

<quotation>
I claim complete innocence and ignorance! It must have been Tim.
I wouldn't know a Trondheim Hammer if it fell on my foot!
<source>Steve Majewski, 10 Jan 1995
</source>
</quotation>

<quotation>
(Aieee!  Yet another thing on my TODO pile!)
<source>A.M. Kuchling, 10 Jan 1995
</source>
</quotation>

<quotation>
[After someone wrote "...assignment capability, a la djikstra"]

Ehh, the poor old man's name is Dijkstra.  I should know, "ij" is a
well known digraph in the Dutch language.  And before someone asks the
obvious: his famous "P and V" names for semaphores are derived for the
Dutch words "Passeer" and "Verlaat", or "Pass" and "Leave".  And no, I
haven't met him (although he did work at CWI back in the fifties when
it was called, as it should still be today, Mathematical Centre).  he
currently lives in Austin, Texas I believe.  (While we're at
it... does anybody remember the Dijkstra font for Macintoshes?  It was
a scanned version of his handwriting.  I believe Luca Cardelli scanned
it -- the author of Obliq, a somewhat Python-like distributed language
built on Modula-3.  I could go on forever... :-) 
<source>Guido van Rossum, 19 Jan 1995
</source>
</quotation>

<quotation>
As always, I'll leave it to a volunteer to experiment with this.
<source>Guido van Rossum, 20 Jan 1995
</source>
</quotation>

<quotation>
Non-masochists, please delete this article NOW.
<source>Aaron Watters, 20 Jan 1995
</source>
</quotation>

<quotation>
If Perl weren't
around, I'd probably be using Python right now.  
<source>Tom Christiansen in comp.lang.perl, 2 Jun 95</source>
</quotation>

<quotation>
GUI stuff is <em>supposed</em> to be hard.  It builds character.
<source>Jim Ahlstrom, at one of the early Python workshops</source>
</quotation>

<quotation>
&gt;VERY cool mod, Peter.  I'll be curious to see GvR's reaction to your syntax.
<br/>
Hm.
<source>Nick Seidenman and Guido van Rossum, 1 Aug 1996</source>
</quotation>

<quotation>
Python is an experiment in how much freedom programmers need.  Too
much freedom and nobody can read another's code; too little and
expressiveness is endangered.  
<source>Guido van Rossum, 13 Aug 1996</source>
</quotation>

<quotation>
[On regression testing] Another approach is to renounce all worldly
goods and retreat to a primitive cabin in Montana, where you can live
a life of purity, unpolluted by technological change.  But now and
then you can send out little packages....
<source>Aaron Watters
</source>
</quotation>

<quotation>
Ah, you're a recent victim of forceful evangelization.  Write your own
assert module, use it, and come back in a few months to tell me
whether it really caught 90% of your bugs.
<source>Guido van Rossum, 7 Feb 1997
</source>
</quotation>

<quotation>
The larger scientific computing centers generally have a "theory"
division and a "actually uses the computer" &lt;wink&gt; division.  The
theory division generally boasts some excellent theoreticians and
designers, while the other division generally boasts some excellent
physical scientists who simply want to get their work done.  In most
labs I've seen, the two divisions hate each others' guts (or, rarely,
blissfully ignore each other), &amp; the politics is so thick you float on
it even after they embed your feet in cement blocks (hence even the
simple relief of death is denied you &lt;wink&gt;).
<source>Tim Peters, 25 Mar 1997
</source>
</quotation>

<quotation>
In one particular way the conflict is fundamental &amp; eternal: the
"working scientists" generally understand the hardware du jour
perfectly, and passionately resent any attempt to prevent them from
fiddling with it directly -- while the theory folks are forever
inventing new ways to hide the hardware du jour.  That two groups can
both be so right and so wrong at the same time is my seventh proof for
the existence of God ...
<source>Tim Peters, 25 Mar 1997</source>
</quotation>

<quotation>
You're going to be in a minority - you're coming to Python programming
from a language which offers you a lot more in the way of comfortable
operations than Python, instead of coming from medieval torture
chambers like C or Fortran, which offer so much less.
<source>Andrew Mullhaupt, 26 Jun 1997
</source>
</quotation>

<quotation>
...although Python uses an obsolete approach to memory management, it
is a _good_ implementation of that approach, as opposed to S, which
uses a combination of bad implementation and demented design decisions
to arrive at what may very well be the worst memory behavior of any
actually useful program.
<source>Andrew Mullhaupt, 26 Jun 1997
</source>
</quotation>

<quotation>
I suggested holding a "Python Object Oriented Programming Seminar", but
the acronym was unpopular.
<source>Joseph Strout, 28 Feb 1997
</source>
</quotation>

<quotation>
Strangely enough I saw just such a beast at the grocery store last
night. Starbucks sells Javachip. (It's ice cream, but that shouldn't
be an obstacle for the Java marketing people.)
<source>Jeremy Hylton, 29 Apr 1997
</source>
</quotation>

<quotation>
A little girl goes into a pet show and asks for a wabbit. The shop
keeper looks down at her, smiles and says:
<br/>
"Would you like a lovely fluffy little white rabbit, or a cutesy
wootesly little brown rabbit?"
<br/>
"Actually", says the little girl, "I don't think my python would notice."
<source>Told by Nick Leaton, 4 Dec 1996
</source>
</quotation>

<quotation>
When I originally designed Perl 5's OO, I thought about a lot of this
stuff, and chose the explicit object model of Python as being the
least confusing.  So far I haven't seen a good reason to change my
mind on that.
<source>Larry Wall, 27 Feb 1997 on perl5-porters
</source>
</quotation>

<quotation>
<pre>
PSA 1996 Budget
---------------
Income:
$1,093,276.54  'Guido for President' 
                 Campaign Contributions(1)
$        3.12  Milk Money Extortion Program
$    2,934.07  PSA Memberships
-------------
$1,096,213.73  Total Income

Expenses:
$  652,362.55  Monty Python Licencing Fees (2)
$   10,876.45  Pre-Release 2 Week Vacations (3)
$  369,841.59  Post-Release 2 Week Vacations (3)
$       15.01  Alien Abduction Insurance
$   62,541.72  Python Web Site Maintenance
$      554.65  Great Comfort Cream
-------------
$1,096,191.97  Total Expenses
$      (21.76) Total Profit (Loss)
</pre>

Notes:
<br/>
     (1) Many of you many not be aware of the fabulously successful
'Guido for President' Campaign. While Guido has no interest in being the
president, the PSA thought it would be a cool way to collect money. The
centerpiece of the campaign featured an attractive offer to spend the
night in Guido's spare bedroom in exchange for a $50,000.00
contribution. (Mark Lutz stayed TWICE!)
<br/>
     (2) Since the proliferation of Monty Python related names (Python,
Monty, Grail, Eric-the-Half-a-Compiler, et al.) has increased over the
past year, the PSA felt it would be wise to licencing the Python name to
forestall any lawsuits. An added benefit is that John Cleese is teaching
Guido how to walk funny.
<br/>
     (3) Pre-Release vacations are spent in the Catskills. Post-Release
vacations are spent in the Bahamas. Guido is currently working on a
system which will allow him to make more releases of Python; thus
octupling the number of vacations he takes in a year.
<source>Matthew Lewis Carroll Smith, 4 Apr 1997
</source>
</quotation>

<quotation>
I mean, just take a look at Joe Strout's brilliant little "python for
beginners" page.  Replace all print-statements with 
<code>sys.stdout.write( string.join(map(str, args)) + "\n")</code>
and you'll surely won't get any new beginners.  And That Would Be A
Very Bad Thing.
<source>Fredrik Lundh, 27 Aug 1996
</source>
</quotation>

<quotation>
Ya, ya, ya, except ... if I were built out of KSR chips, I'd be
running at 25 or 50 MHz, and would be wrong about ALMOST EVERYTHING
almost ALL THE TIME just due to being a computer! Think about it --
when's the last time you spent 20 hours straight debugging your
son/wife/friend/neighbor/dog/ferret/snake?  And they <em>still</em> fell over
anyway?  Except in a direction you've never seen before each time you
try it?  The easiest way to tell you're dealing with a computer is
when the other side keeps making the same moronic misteakes over and
misteakes over and misteakes over and misteakes over and misteakes
over and misteakes CTRL-C again.  
<source>Tim Peters, 30 Apr 97
</source>
</quotation>

<quotation>
BTW, a member of the ANSI C committee once told me that the only
thing rand is used for in C code is to decide whether to pick up the
axe or throw the dwarf, and if that's true I guess "the typical libc
rand" is adequate for all but the most fanatic of gamers &lt;wink&gt;.  
<source>Tim Peters, 21 June 1997.
</source>
</quotation>

<quotation>
Things in Python are very clear, but are harder to find than the
secrets of wizards. Things in Perl are easy to find, but look like
arcane spells to invoke magic. 
<source>Mike Meyer, 6 Nov 1997</source>
</quotation>

<quotation>
Indeed, as Palin has come to understand, being part of Python means
never really knowing what may lurk around the corner.
<br/>
"We've never really followed any rules at all with Python," he said.
"We're a spontaneous lot. It's more fun that way."
<source>Michael Palin, quoted from a Reuters/Variety news item titled 
   "Rare Python Reunion", Jan 15 1998.</source>
</quotation>

<quotation>
Python is an excellent language for learning object orientation. (It also 
happens to be my favorite OO scripting language.) 
<author>Sriram Srinivasan</author>
<source><cite>Advanced Perl Programming</cite></source>
</quotation>

<quotation>
The point is that newbies almost always read more into the semantics
of release than are specified, so it's worthwile to be explicit about
how little is being said &lt;wink&gt;.
<source>Tim Peters, 12 Feb 1998</source>
</quotation>

<quotation>
Ah!  "Never mind" to a bunch of what I said before (this editor can't
move backwards &lt;wink&gt;).
<source>Tim Peters, 12 Feb 1998</source>
</quotation>

<quotation>
After 1.5 years of Python, I'm still discovering richness (and still 
unable to understand what the hell Jim Fulton is talking about).
<source>Gordon McMillan, 13 Mar 1998</source>
</quotation>

<quotation>
Tabs are good, spaces are bad and mixing the two just means that your 
motives are confused and that you don't use enough functions.
<source>John J. Lehmann, 19 Mar 1998</source>
</quotation>

<quotation>
... but whenever optimization comes
up, people get sucked into debates about exciting but elaborate schemes
not a one of which ever gets implemented; better to get an easy 2% today
than dream about 100% forever.
<source>Tim Peters, 22 Mar 1998</source>
</quotation>

<quotation>
I've been playing spoilsport in an attempt to
get tabnanny.py working, but now that there's absolutely no reason to
continue with this, the amount of my life I'm willing to devote to it is
unbounded &lt;0.9 wink&gt;.
<source>Tim Peters, 30 Mar 1998</source>
</quotation>

<quotation>
Python is a little weak in forcing encapsulation. It isn't made for
bondage and domination environments.
<source>Paul Prescod, 30 Mar 1998</source>
</quotation>

<quotation>
One of my
first big programming assignments as a student of computer science was
a source formatter for Pascal.  The assignment was designed to show us
the real-life difficulties of group programming projects.  It
succeeded perhaps too well.  For a long time, I was convinced that
source code formatters were a total waste of time, and decided to
write beautiful code that no automatic formatter could improve upon.
In fact, I would intentionally write code that formatters could only
make worse.
<source>Guido van Rossum, 31 Mar 1998</source>
</quotation>

<quotation>
   You need to build a system that is futureproof; it's no good just
   making a modular system. You need to realize that your
   system is just going to be a module in some bigger system to come, and
   so you have to be part of something else, and it's a bit of a way of
   life.
<source>Tim Berners-Lee, at the WWW7 conference</source>
</quotation>

<quotation>
From gotos to the evolution of life in 10 posts; that's
comp.lang.python for you!
<source>A.M. Kuchling, 4 Apr 1998</source>
</quotation>

<quotation>
This is <em>Python</em>!  If we didn't care what code looked like, most
of us would probably be hacking in some version of Lisp -- which already
covered most of Python's abstract <em>semantics</em> way back when Guido was just a
wee snakelet frolicking in the lush Amsterdam jungle. 
<source>Tim Peters, 24 Apr 1998</source>
</quotation>

<quotation>
The infinities aren't contagious except in that they often appear that way
due to their large size.
<source>Tim Peters on the IEEE 754 floating point standard, 27 Apr 1998</source>
</quotation>

<quotation>
The "of course, while <em>I</em> have no problem with
this at all, it's surely too much for a lesser being" flavor of argument
always rings hollow to me.  Are you personally confused by the meanings for
"+" that exist today?  <em>Objecting</em> to the variations is a different story;
I'm wondering whether you personally stumble over them in practice.  I
don't; Steven doesn't; I doubt that you do either.  I'm betting that almost
<em>nobody</em> ever does, in which case those "less nimble colleagues and
students" must be supernaturally feeble to merit such concern.
<source>Tim Peters, 29 Apr 1998</source>
</quotation>

<quotation>
"Ideally, IMO, two messages with the same name should have
 the same meaning but possibly different implementations.
 Of course, "meaning" is somewhat relative, but the notion
 that two messages with the same name should have the same
 'meaning' is very useful."
<br/>
"Like clothes.launder() vs money.launder(), or shape.draw() vs blood.draw(),
or matrix.norm() vs hi.norm() &lt;wink&gt;?
I'm afraid English thrives on puns,
and the same word routinely means radically different things across
application areas.  Therefore, to insist that a word have "one true meaning"
in a programming language is insisting that the language cater to one true
application domain."
<source>Jim Fulton and Tim Peters, in a discussion of rich comparisons, 29 Apr 1998</source>
</quotation>

<quotation>
Indeed, when I design <em>my</em> killer language, the identifiers "foo" and "bar"
will be reserved words, never used, and not even mentioned in the reference
manual.  Any program using one will simply dump core without comment.
Multitudes will rejoice.
<source>Tim Peters, 29 Apr 1998</source>
</quotation>

<quotation>
Too little freedom makes life
confusingly clumsy; too much, clumsily confusing.  Luckily, the tension
between freedom and restraint eventually gets severed by Guido's Razor.
<source>Tim Peters, 29 Apr 1998</source>
</quotation>

<quotation>
In other words, I'm willing to see dark
corners added to the language, as long as I don't have to go into them
myself.
<source>A.M. Kuchling, 29 Apr 1998</source>
</quotation>

<quotation>
This argument is specious.  What on earth would it mean to compare an
object you created with another object from someone else's code unless
you knew exactly what each object's semantics were?  Do you really
want to ask if my abstract syntax tree is less then your HTTP
connection object?
<source>Jeremy Hylton, in a discussion of rich comparisons, 29 Apr 1998</source>
</quotation>

<quotation>
Two things I learned for sure during a particularly intense acid trip in my
own lost youth: (1) everything is a trivial special case of something else;
and, (2) death is a bunch of blue spheres.
<source>Tim Peters, 1 May 1998</source>
</quotation>

<quotation>
Well, they will be:  "&lt;" will mean what everyone thinks it means when
applied to builtin types, and will mean whatever __lt__ makes it mean
otherwise, except when __lt__ isn't defined but __cmp__ is in which case it
will mean whatever __cmp__ makes it mean, except when neither __lt__ or
__cmp__ are defined in which case it's still unsettled.  I think.  Or isn't
that what you meant by "clearly defined"?
<source>Tim Peters, 6 May 1998</source>
</quotation>

<quotation>
You write a great program, regardless of
language, by redoing it over &amp; over &amp; over &amp; over, until your fingers bleed
and your soul is drained.  But if you tell newbies <em>that</em>, they might decide
to go off and do something sensible, like bomb defusing&lt;wink&gt;.
<source>Tim Peters, 5 Jun 1998</source>
</quotation>

<quotation>
OO styles help in part because they make it easier to redo large parts over,
or, when the moon is shining just right, to steal large parts from someone
else.  Python helps in many additional ways regardless of style, not least
of which in that it hurts less to throw away 50 lines of code than 5,000
&lt;0.5 wink&gt;.  The pains, and joys, of programming are <em>qualitatively</em> the
same under Python.  There's less pain less often, and joy comes quicker.
And that's worth a whole lot.
<source>Tim Peters, 5 Jun 1998</source>
</quotation>


<quotation>
I've had a DBA tell me that what I wanted to do 
"could not" be done because his silly $5000 tool couldn't model it. 
Proving him wrong simply increased his conviction that what I was 
doing was immoral and perverse.
Which, come to think of it, it probably was. Hee hee.
<source>Gordon McMillan, 8 Jun 1998</source>
</quotation>

<quotation>
The majority of programmers aren't really looking for flexibility.  Most
languages that enjoy huge success seem to do so not because they're
flexible, but because they do one particular thing <em>extremely</em> well.  Like
Fortran for fast number-crunching in its day, or Perl for regexps, or C++
for compatibility with C, or C for ... well, C's the exception that proves
the rule. 
<source>Tim Peters, 11 Jun 1998</source>
</quotation>

<quotation>
It has also been referred to as the "Don Beaudry <em>hack</em>," but
that's a misnomer.  There's nothing hackish about it -- in fact,
it is rather elegant and deep, even though there's something dark
to it.
<source>Guido van Rossum, <cite>Metaclass Programming in Python 1.5</cite></source>
</quotation>

<quotation> 
Just point your web browser at
http://www.python.org/search/ and look for "program", "doesn't",
"work", or "my".  Whenever you find someone else whose program didn't
work, don't do what they did.  Repeat as needed.  
<source>Tim Peters, on python-help, 16 Jun 1998</source> </quotation>

<quotation>
Now some people see unchecked raw power and flee from perceived danger,
while others rush toward perceived opportunity.  That's up to them.  But I
think it's enormously <em>clarifying</em> in either case to see just 
<em>how</em> raw this
particular gimmick can get.
<source>Tim Peters, 16 Jun 1998</source>
</quotation>

<quotation>
Every language has its partisans, usually among folks deeply immersed in
their particular theology, triumphant in having divined the inner meaning of
some esoteric operations, like a medieval Jesuit hot on the trail of the
final ontological proof,  whose conciseness in solving a single problem
makes them almost swoon with ecstacy at the expected savings of many
keystrokes, as if those very keystrokes represented a lot of heavy lifting
and hauling on their part.
<source>John Holmgren, 18 Jun 1998</source>
<!-- Jesuits weren't medieval, but it's still a good quote. -->
</quotation>

<quotation>
> In general, the situation sucks.
<br/>
mind-if-i-use-that-as-my-epitaph&lt;wink&gt;?-ly y'rs  - tim
<source>Timothy J. Grant and Tim Peters, 22 Jun 1998</source>
</quotation>

<quotation>
&gt; Just for the record, on AIX, the following C program:
<br/>
Oh no you don't!  I followed AIX threads for the first year it came out, but
eventually decided there was no future in investing time in baffling
discussions that usually ended with "oh, never mind -- turns out it's a bug"
&lt;0.9 wink&gt;.
<source>Vladimir Marangozov and Tim Peters, 23 Jun 1998</source>
</quotation>

<quotation>
Python - why settle for snake oil when you can have the <em>whole</em> snake?
<source>Mark Jackson, 26 Jun 1998</source>
</quotation>

<quotation>
The problem I have with "SETL sets" in Python is the same I have with every
other language's "killer core" in Python:  SETL is much more than just "a
set type", Eiffel is much more than just fancy pre- and post-conditions,
Perl's approach to regexps is much more than just its isolated regexp
syntax, Scheme is much more than just first-class functions &amp; lexical
closures, and so on.  Good languages aren't random collections of
interchangeable features:  they have a philosophy and internal coherence
that's never profitably confused with their surface features.
<source>Tim Peters, 10 Jul 1998</source>
</quotation>

<quotation>
"Since I'm so close to the pickle module, I just look at the
pickles directly, as I'm pretty good at reading pickles."
<br/>
"As you all can imagine, this trick goes over really well at parties."
<source>Jim Fulton and Paul Everitt on the Bobo list, 17 Jul 1998</source>
</quotation>

<quotation>
My theory is that the churning of old threads and reminiscences 
(Continuations, Icon influences, old-T-shirts, the pre news-group
mailing list archive, whitespace, closures, .... ) has brought 
some old messages to the surface, via some mechanism similar to
the way plankton and other nutrients are cycled in the ocean. 
<source>Steven D. Majewski, 23 Jul 1998</source>
</quotation>

<quotation>
In general, Our Guido flees from schemes that merely change <em>which</em> foot
gets blown off &lt;0.45 caliber wink&gt;.  Schemes that remove the firing pin
entirely have a much better, um, shot &lt;wink&gt;.
<source>Tim Peters, 25 Jul 1998</source>
</quotation>

<quotation>
 I don't know what "invert the control structure" means -- but if it's
 anything like turning a hamster inside-out, I would <em>expect</em>
it to be messy &lt;wink&gt;.
<source>Tim Peters, 25 Jul 1998</source>
</quotation>

<quotation>
This makes it possible to pass complex object hierarchies to a C
coder who thinks computer science has made no worthwhile advancements
since the invention of the pointer.
<source>Gordon McMillan, 30 Jul 1998</source>
</quotation>

<quotation> 
The nice thing about list comprehensions is that their
most useful forms could be implemented directly as light sugar for
ordinary Python loops, leaving lambdas out of it entirely.  You end up
with a subtly different beast, but so far it appears to be a beast
that's compatible with cuddly pythons.  
<source>Tim Peters, 6 Aug 1998</source> 
</quotation>

<quotation> 
I wonder what Guido thinks he might do in Python2 (assuming, of course, that
he doesn't hire a bus to run over him before then &lt;wink&gt;).
<source>Tim Peters, 26 Aug 1998</source> 
</quotation>

<quotation> After writing CGI scripts the traditional way for a few
years, it is taking awhile to reshape my thinking. No sledgehammer to
the head yet, but lots of small sculpting hammers...  
<source>John Eikenberry on the Bobo list, 27 Aug 1998</source> 
</quotation>

<quotation>
I believe sometimes numbers
creep into my programs as strings, so '4'/2 needs to also be 2.
Other languages do this.  Since this is due in part to user input,
I guess 'four'/2, 'quattro/2', 'iv/2' etc. need to be 2 as well;
don't know any other language that does so, but Python could take the
lead here in software reliability.  Any white space should be ignored,
including between my ears.  I don't have time to write any useful
software, so I've decided to devote myself to proposing various
changes to the Python interpreter.
<source>Donn Cave uses sarcasm with devastating effect, 28 Aug 1998</source> 
</quotation>

<quotation>
then-again-if-history-were-important-god-wouldn't-have-hid-
it-in-the-past-ly y'rs
<source>Tim Peters, 28 Aug 1998</source> 
</quotation>

<quotation>
<pre>
&gt; &gt;( float ( / 1 3 ))
&gt; 0.33333333333333331
</pre>
Now <em>that</em> one is impressive:  it's the best possible 17-digit decimal
representation of the best possible 53-bit fp binary representation of 1/3,
and 17 is the minimum number of decimal digits you need in general so that a
53-bit binary fp value can be exactly reconstructed by a best-possible atof.
<source>Tim Peters, 2 Sep 1998</source> 
</quotation>

<quotation>
This is not a technical issue so much as a human issue; we 
are limited and so is our time.  (Is this a bug or a feature of time?
Careful; trick question!)
<source>Fred Drake on the Documentation SIG, 9 Sep 1998</source> 
</quotation>

<quotation>
There are also some surprises [in the late Miocene Australia]
some small mammals totally unknown and not obviously related
to any known marsupial (appropriately awarded names such as
<foreign>Thingodonta</foreign> and <foreign>Weirdodonta</foreign>) and a giant
python immortalized as <foreign>Montypythonoides</foreign>.
<source><cite>The Book of Life</cite>, found by Aaron Watters
</source> 
</quotation>

<quotation>
Can the denizens of this group enlighten me about what the
advantages of Python are, versus Perl ?
<br/>
"python" is more likely to pass unharmed through
your spelling checker than "perl".

<source>An unknown poster and Fredrik Lundh, 11 Sep 1998
</source> 
</quotation>

<quotation>
I have to say that the Dragon book is good when you consider
the alternatives, but compared with the Platonic ideal it leaves
much to be desired.  In particular the algorithm descriptions
are described at such a low level  it's difficult to understand
how they work -- and at a higher conceptual level
involving graph theoretical transforms of automata (which I got
thanks to Jean Gallier by word of mouth and effort of chalk)
is nearly invisible for the trees. 
<source>Aaron Watters, 17 Sep 1998</source> 
</quotation>

<quotation>
... and at a higher conceptual level involving graph theoretical
transforms of automata (which I got thanks to Jean Gallier by word of
mouth and effort of chalk) ...
<source>Aaron Watters, 17 Sep 1998</source> 
</quotation>

<quotation>
Every clarity vanished? :-)
<source>Christian Tismer after answering a poster's question, 17 Sep 1998</source> 
</quotation>

<quotation>
Take the "public" modifier off
   Joseph's interface, or leave it there but nest the interface inside
   class closure, or even move the interface to its own printer.java
   file, and it compiles and runs without incident. Most of the big boys
   I hang with aren't paralyzed by self-explanatory compiler msgs &lt;wink&gt;.
<br/>
   not-to-mention-the-girls-ly y'rs 
<source>Tim Peters, 24 Sep 1998</source> 
</quotation>

<quotation>
   &lt;shakes head ruefully&gt; You kids today, with your piercings and your
   big pants and your purple-and-green hair and your X-Files and your
   Paula Cole and your espresso coffee and your Seattle grunge rock and
   your virtual machines and your acid-washed jeans and your Ernest
   Hemingway and your object-oriented languages and your fax machines and
   your hula hoops and your zoot suits and your strange slang phrases
   like "That's so bogus" or "What a shocking bad hat" and those atonal
   composers like Arnold Schoenberg and Milton Babbit that you kids seem
   to like these days and your cubist painters and your Ally McBeal and
   that guy in Titanic and your TCP/IP protocol and your heads filled
   with all that Cartesian dualism these days and ... well, I just don't
   get you kids. &lt;shakes head ruefully again&gt;
<source>A.M. Kuchling, 1 Oct 1998</source> 
</quotation>

<quotation>
E.g., at the REBOL prompt I typed
<pre>
     send tim@email.msn.com "Did this work?"
</pre>
   and in response it dialed my modem, connected to my ISP, and then
   REBOL crashed after provoking an invalid page fault in kernel32.dll.
   Then my connection broke, and the modem dialed and connected again.
   Then it just sat there until it timed out.
<br/>
   now-<em>that's</em>-user-friendly&lt;wink&gt;-ly y'rs
<source>Tim Peters, 24 Sep 1998</source> 
</quotation>

<quotation>
I've reinvented the idea of variables and types as in a programming
language, something I do on every project. 
<source>Greg Ward, September 1998</source> 
</quotation>

<quotation>
"The event/tree dualism reminds me why I always wanted to be able to do pattern matching on trees."
<br/>
"'Honey, what is this guy doing up there?'
'Oh, I suppose it's Christian, trying to match some patterns.' "
<source>Christian Tismer and Dirk Heise, 12 Oct 1998</source> 
</quotation>

<quotation>
Perl is worse than Python because people wanted it worse.
<source>Larry Wall, 14 Oct 1998</source> 
</quotation>

<quotation>
"What's the opinion of the (wink) Python luminaries?"
<br/>
"The last time I saw a position paper from them, they came out strongly
against the suggestion that old people be put on ice floes and left to drift
out to sea to die.
<br/>
they-never-like-<em>any</em>-of-my-ideas-ly y'rs"
<source>Stuart Hungerford and Tim Peters, 14 Oct 1998</source> 
</quotation>

<quotation>
Rather than borrowing from our beauty-impaired ugly sibling, why not look
at Java, the beautiful, conceited sister? We could have something more
like JavaDoc.
<source>Paul Prescod, 18 Oct 1998</source> 
</quotation>

<quotation>
It won't work. This is far too concrete a problem to interest Tim. I 
see 3 possible approaches:
<br/>
1) Claim that Python can't do a &lt;some random combination of 'L', 'R', 
'A'&gt; grammar. This will yield an irate response from Aaron which will 
draw Tim into it and you'll get a solution in 3 months after lots of 
entertaining posts.
<br/>
2) Turn it into an optimization problem and get a solution from 
Marc-Andre using mxTextTools next week.
<br/>
3) Turn it into an obfuscation problem and get competing solutions 
from Greg Stein and Fredrik tomorrow morning.
<br/>
if-anybody's-found-don-beaudry's-sucker-button-let-me-know ly 'yrs
<source>Gordon McMillan, 16 Oct 1998</source>
</quotation>

<quotation>
To my battle-scarred mind,
documentation is never more than a hint. Read it once with disbelief
suspended, and then again with full throttle skepticism.
<source>Gordon McMillan, 19 Oct 1998</source> 
</quotation>

<quotation>
Then let the record show that I hereby formally lobby for such an
optimization!  I'd lay out some arguments, except that it's already
implemented &lt;wink&gt;.
<br/>
well-<em>that</em>-one-went-easy-ly y'rs  - tim
<source>Tim Peters, 20 Oct 1998</source>
</quotation>

<quotation>
We did requirements and task analysis, iterative design,
    and user testing. You'd almost think programming languages
    were an interface between people and computers.
<source>Steven Pemberton, one of the designers of Python's direct ancestor ABC
</source> 
</quotation>

<quotation>
 Not at all, although I agree here too &lt;wink&gt;.  It's like saying a fork is
 broken just because it's not that handy for jacking up a car.  That is,
 Guido implemented the syntax to support default arguments, and it works
 great for that purpose!  Using it to fake closures is a hack, and the "hey,
 this is cool!" / "hey, this really sucks!" mixed reaction thus follows, much
 as pain follows a car falling on your skull.  Stick to stabbing peas, or
 even teensy pea-sized closures, and a fork serves very well.
<source>Tim Peters, 31 Oct 1998</source>
</quotation>

<quotation>
My customers consider it a marketable skill that I
 a) think for myself
 b) share my thoughts with them.
<source>Paul Prescod, 2 Nov 1998</source> 
</quotation>

<quotation>
Anyone else know what a Stanley #45 plane is? ... it's not
what you use if you aren't looking to produce intricate moldings.  If
you want to make a tabletop flat, and bring out the natural beauty of
the wood, you use a big, long and flat bench plane.  The beauty is in
the wood, not the tool, the tool is just the right one to let you see
that and to let others see it too.

<br/>

And that's a very impressive kind of beauty in itself, isn't it?  The
kind of beauty some say is homely--an uninteresting face, boring angles,
few if any parts, no curly flowers.  It's just a tool, and not beautiful
at all.  But look, that tool makes beauty.  It makes it *easy* to make
beautiful things, to see deep into the the grain of whatever material
you're working.

<br/>

Maybe it gets us a little closer to art.
<source>Ivan Van Laningham, 3 Nov 1998</source> 
</quotation>

<quotation>
You might think "That's illegal."  That's not illegal; that's <em>cool</em>.
<source>Paul Dubois at IPC7, on recursive template definitions in C++</source> 
</quotation>

<quotation>
This supports reflection, which is the 90s way of writing self-modifying code.
<source>John Aycock at IPC7, during his parsing talk</source> 
</quotation>

<quotation>
It turns out that docstrings are the only way to associate information with functions, which is what led you to abuse them in such a fascinating and stomach-churning way.
<source>Jim Hugunin at IPC7, on embedding BNF parsing rules in docstrings</source> 
</quotation>

<quotation>
"The Mayans looked on the integers as gods."
<br/>
"What did the Mayans think of integer division?"
<source>Ivan Van Laningham and an unknown audience member at IPC7</source> 
</quotation>

<quotation>
Y2K problem?  The Mayans didn't have a <em>millennium</em>-2K problem!
<source>Eric S. Raymond at IPC7, on learning that the Mayan calendar takes 28 octillion years to wrap around</source> 
</quotation>

<quotation>
"Generic identifier" -- think about it too much and your head explodes.  
<source>Sean McGrath at IPC7, discussing SGML terminology</source> 
</quotation>

<quotation>
Nothing I've ever written has reached 1.0.
<source>Greg Ward at IPC7, on using small version numbers</source> 
</quotation>

<quotation>
Well, that's a little thing -- the specification.
<source>Guido van Rossum at IPC7</source> 
</quotation>

<quotation>
"We've got a name (Module Distribution Utilities) that gives us a good 3-letter acronym to group things under: MDU."
<br/>
"&lt;thpftbt&gt;"
<source>Greg Ward and Jeremy Hylton at IPC7</source> 
</quotation>

<quotation>
Mailman is designed to be extensible <em>and</em> comprehensible.  Without
 comprehensibility, enhancement is self-limiting -- functionality may be
 improved, but further enhancement gets increasingly difficult.
<source>Ken Manheimer at IPC7</source> 
</quotation>

<quotation>
"Generating Usable Installations" -- OK, you've got the GUI SIG.
<source>Barry Warsaw at IPC7, on the choice of name for a SIG to discuss extension building</source>
</quotation>

<quotation>
Performance is a lot like drugs -- it doesn't do much for you, but it occupies a lot of your time.
<source>Jeremy Hylton at IPC7, on the need for a Performance SIG</source>
</quotation>

<quotation>
I made some slides, but they suck, so I won't bother with them.
<source>Andrew Kuchling at IPC7</source>
</quotation>

<quotation>
"What's Python?"
<br/>
"It's a computer programming language."
<br/>
"You mean, like DOS?"
<source>Some guy in a bar and Eric S. Raymond (who was wearing
a conference T-shirt) at IPC7</source>
</quotation>

<quotation>
Excellent plan!  Devious minds are attracted to Python, like mimes to
unappreciative crowds.
<source>Tim Peters, 13 Nov 1998</source>
</quotation>

<quotation>
Ha!  If we had only started numbering dimensions with one, we'd already be
living in a 4-D world, and Mental Organons would be *all over the place*!
<source>Tim Peters, 13 Nov 1998</source>
</quotation>

<quotation>
Well, during those periods when I was me, there was most assuredly 
only one of me. But during some of the more intense discussions, I 
was not me, and while all the rest of the attendees were also not me, 
it is difficult to say whether they were the same not me that I was 
or wasn't at the time.
<source>Gordon McMillan, 18 Nov 1998</source>
</quotation>

<quotation>
If Python strays into trying to be something completely new it will fail,
like Scheme, K and Smalltalk. There are both technical and sociological
reasons for this. If you stray too far technically, you make mistakes:
either you make modelling mistakes because you don't have an underlying
logical model (i.e. C++ inheritance) or you make interface mistakes
because you don't understand how your new paradigm will be used by real
programmers.
<br/>
Let research languages innovate. Python integrates.
<source>Paul Prescod, 21 Nov 1998</source>
</quotation>

<quotation>
"I got a little mad at the way python polynomials were written --
the code looked like its author knew neither polynomials nor
Python."
<br/>
"That would be me :-)."
<source>Moshe Zadka and Guido van Rossum, 22 Nov 1998</source>
</quotation>

<quotation>
I would
recommend not wasting any more time on the naming issue.  (This is a
recurring theme in my posts -- remember, I spent about 0.3
microseconds thinking about whether "Python" would be a good name for
a programming language, and I've never regretted it.)
<source>Guido van Rossum, 25 Nov 1998</source>
</quotation>

<quotation>
"My course members are almost all coming from Math,
and the first question was 'why isn't it complete?'
Just a matter of elegance."
<br/>
"Oh, don't worry.  My background is math.  This is actually
good for them -- like discovering that Santa Claus doesn't
really exist."
<source>Christian Tismer and Guido van Rossum, 2 Dec 1998</source>
</quotation>

<quotation>
One of my cheap entertainments is axiomatizing characterizations
of [Tim Peters].  I think I've come up with a minimal one:  the only
c.l.p poster more concerned with working non-legal code than
non-working legal code. 
<source>Cameron Laird, 2 Dec 1998</source>
</quotation>

<quotation>
PYTHON = (P)rogrammers (Y)earning (T)o (H)omestead (O)ur (N)oosphere.
<source>Seen in Sean McGrath's .sig, 3 Dec 1998</source>
</quotation>

<quotation>
I never realized it before, but having looked that over
I'm certain I'd rather have my eyes burned out by zombies with flaming dung
sticks than work on a conscientious Unicode regex engine.
<source>Tim Peters, 3 Dec 1998</source>
</quotation>

<quotation>
"Python? Oh, I've heard of that.
I have a friend at the NSA who uses it."
<source>Overhead at a meeting, quoted in c.l.p on 3 Dec 1998</source>
</quotation>

<quotation>
I think Gordon has priority on this one, since it's clearly a consequence of
his observation that tim_one despises and deplores anything useful.  Which
has greater explanatory power, since I've often noted that tim_one complains
about legal working code too!  Anything that works may be useful, right?
Brrrrr.  Must destroy.
<source>Tim Peters in the third person, 3 Dec 1998</source>
</quotation>

<quotation>
"Eric has a way of explaining what we're doing and why we're doing
it," says Guido van Rossum, the inventor of a programming language
called Python and a prominent figure among open-source proponents. Van
Rossum, a gawky Dutchman who now lives in Reston, invited Raymond to
address a group of Python software developers in Houston...
<source>From the <cite>Washington Post</cite>, 3 Dec 1998</source>
</quotation>

<quotation>
Subclassing with a mixin doesn't let you, for example, interfere with
how an existing attribute is accessed. The general idea here is to
kidnap the object, skin it, then waltz around in public impersonating
it. All without letting the programmer / user know he's been
bamboozled.
<source>Gordon McMillan, 3 Dec 1998</source>
</quotation>

<quotation>
Hey, while they're all eating dinner, let's sneak in a keyword!
<br/>
emancipate variable: declare absolute freedom for one variable.  It can be whatever it
wants whenever it wants in whatever form it wants in whatever language it
wants on whatever computer it wants.  In the ensuing chaos it will get
nothing done, but it will give programmers stories to tell for years to
come...
<source>Mike Fletcher, 25 Dec 1998</source>
</quotation>

<quotation>
"Can we kill this thread?  The only thing it does as far as I'm
concerned is increase the posting statistics. :-)"
<br/>
"don't-open-cans-of-worms-unless-you're-looking-for-a-new-diet-ly y'rs"
<source>Guido van Rossum and Tim Peters, 6 Jan 1999</source>
</quotation>

<quotation>
Hey, that was the first truly portable laptop!  Of course I'm nostalgic.
Came with a mighty 24Kb RAM standard, &amp; I popped the extra $80 to max it out
at 32Kb.  Much of Cray's register assigner was developed on that beast:
unlike the prototype Crays of the time, the M100 was always available and
never crashed.  Even better, I could interrupt it any time, poke around, and
resume right where it left off &lt;wink&gt;.
<br/>
m100-basic-reminded-me-a-lot-of-python-except-that-it-sucked-ly y'rs 
<source>Tim Peters remembering the Model 100, 10 Jan 1999</source>
</quotation>

<quotation>
"Heh -- all it really broke so far was my resistance to installing Tk.  I
suppose wizardry is inevitable after one installs something, though &lt;wink&gt;."
<br/>
"Spoken like a truly obsessive-compulsive wizard!
It-takes-one-to-know-one..."
<source>Tim Peters and Guido van Rossum, 6 Jan 1999</source>
</quotation>

<quotation>
Note, however, that architectural forms are completely declarative and
can  be implemented in a highly optimized fashion. The sorts of
extensions that  Microsoft has proposed for XSL (&lt;xsl:eval&gt;...&lt;/&gt;)
would completely destroy  those features. Architectural mapping would,
in general, be as reliable  and high performance as ordinary software
-- (not at all).
<source>Paul Prescod, 6 Jan 1999</source>
</quotation>

<quotation>
Darned confusing, unless you have that magic ingredient <em>coffee</em>, of which
I can pay you Tuesday for a couple pounds of extra-special grind today.
<source>John Mitchell, 11 Jan 1999</source>
</quotation>

<quotation>
That's so obvious that someone has already got a patent on it.
<source>Guido van Rossum, 12 Jan 1999</source>
</quotation>

<quotation>
I have to stop now. I've already told you more than I know.
<source>Wolf Logan, 14 Jan 1999</source>
</quotation>

<quotation>
I really don't have any incisive insights about the economic
mechanisms or viability of free software and open source, but I do
have a strong, clear sense that such things make it possible for me to
do my job, as a programmer and a facilitator of/participant in online
communities, better and more easily than I otherwise could do.
<source>Ken Manheimer, 24 Jan 1999</source>
</quotation>

<quotation>
Every standard applies to a certain problem domain and a certain level. A
standard can work perfectly and save the world economy billions of dollars
and there will still be software and hardware compatibility problems.
In fact, solving one level of compatibility just gives rise to the next
level of incompatibility. For example, connecting computers together through
standard protocols gives rise to the problem of byte endianness issues.
Solving byte endianness gives rise to the problem of character sets.
Solving character sets gives rise to the problem of end-of-line and
end-of-file conventions. Solving that gets us to the problem of
interpreting the low-level syntax (thus XML). Then we need to interpet
that syntax in terms of objects and properties (thus RDF, WDDX, etc.). And
so forth.
<br/>
We could judge a standard's success by its ability to reveal another level
of standardization that is necessary.
<source>Paul Prescod, 24 Jan 1999</source>
</quotation>

<quotation>
I just want to go on the record as being completely opposed to
computer languages. Let them have their own language and soon
they'll be off in the corner plotting with each other!
<source>Steven D. Majewski, 25 Jan 1999</source>
</quotation>

<quotation>
Constraints often boost creativity.
<source>Jim Hugunin, 11 Feb 1999</source>
</quotation>

<quotation>
Programming is no different - it's only by going outside what you know, and
looking from another direction (working, if you like, your brain, so that
it can be more powerful :-) that you can improve further.
<source>Andrew Cooke, 12 Feb 1999</source>
</quotation>

<quotation>
any-technology-indistinguishable-from-magic-is-too-mysterious-
    to-trust-ly y'rs
<source>Tim Peters, 16 Feb 1999</source>
</quotation>

<quotation>
"I don't think we've thought of this, and it's actually a good idea."
<br/>
"I'd better go patent it!"
<source>Uche Ogbuji and Paul Prescod, 16 Feb 1999</source>
</quotation>

<quotation>
Contrary to advertising, no parsing system is "easy to learn", in or out of
the Python world -- parsing is a hard problem.  Most are easy enough to use
after practice, though.  Ironically, the trickiest system of all to master
(regexps) is also the feeblest and the most widely used.
<source>Tim Peters, 17 Feb 1999</source>
</quotation>

<quotation>
So Python's only cross-platform choices were to
mimic the C/POSIX API or invent its own new x-platform API; only one of
those is realistic (as Java proves every day &lt;wink&gt;).
<source>Tim Peters, 21 Feb 99</source>
</quotation>

<quotation>
Yes:  the code in ntpath.split is too clever to have any hope of working
correctly &lt;wink&gt;.
<source>Tim Peters, 19 Mar 99</source>
</quotation>

<quotation>
Thanks.  The sooner I get discouraged and quit, the more time
I'll save overall.
<source>Frank Sergeant, 28 Mar 1999</source>
</quotation>

<quotation>
I would actively encourage my competition to use Perl.
<source>Sean True, 30 Mar 1999</source>
</quotation>

<quotation>
But it's a general way to debug: tell someone what right things
your program is doing. Chances are that you will see the wrong
thing(s) before the other person has said anything...
I just stick a picture of a face on my monitor and talk to
it to find bugs.
<source>Richard van de Stadt, 9 Apr 1999</source>
</quotation>

<quotation>
Might just be nostalgia, but I think I would give an arm
or two to get that (not necessarily my own, though).
<source>Fredrik Lundh, 13 May 1999</source>
</quotation>

<quotation>
1.    Beautiful is better than ugly.
<br />
2.    Explicit is better than implicit.
<br />
3.    Simple is better than complex.
<br />
4.    Complex is better than complicated.
<br />
5.    Flat is better than nested.
<br />
6.    Sparse is better than dense.
<br />
7.    Readability counts.
<br />
8.    Special cases aren't special enough to break the rules.
<br />
9.    Although practicality beats purity.
<br />
10.    Errors should never pass silently.
<br />
11.    Unless explicitly silenced.
<br />
12.    In the face of ambiguity, refuse the temptation to guess.
<br />
13.    There should be one -- and preferably only one -- obvious way to do it.
<br />
14.    Although that way may not be obvious at first unless you're Dutch.
<br />
15.    Now is better than never.
<br />
16.    Although never is often better than <em>right</em> now.
<br />
17.    If the implementation is hard to explain, it's a bad idea.
<br />
18.    If the implementation is easy to explain, it may be a good idea.
<br />
19.    Namespaces are one honking great idea -- let's do more of those!
<br />
<source>Tim Peters' 19 Pythonic Theses, 4 Jun 1999</source>
</quotation>

<quotation>
"However, I've heard that after about
10K items in a dict, it starts having problems."
<br/>
"11,523 to be exact.  After that, dicts drink to excess and show up for work
late the morning after.  We don't like to talk about it, though."
<source>Aahz Maruch and Tim Peters, 8 Jun 1999</source>
</quotation>

<quotation>
Stackless Python 0.2, a plug-in replacement for the Python core that does
not use the C stack, has been announced by Christian Tismer as the best
 way
to prove that it was possible without a major rewrite to the core. Neel
Krishnaswami commented to Christian, "This is very neat, and you are
completely deranged".
<source>From Linux Weekly News, 17 Jul 1999</source>
</quotation>

<quotation>
... we need more
people like him, who are willing to explore without being driven to argue
with people about it.
<source>William Tanksley on Chuck Moore, inventor of Forth, 2 Jul 1999</source>
</quotation>

<quotation>
Sorry for the term, I picked it up from Jim Fulton back when it was
an about-to-be-added feature for Principia/Aqueduct.  As with so many
Fultonisms, it's vivid and tends to stick in one's (non-pluggable) brain.
<source>Paul Everitt on the term "pluggable brains", 5 Jul 1999</source>
</quotation>

<quotation>
I picture a lump of inanimate flesh (a result from a
relational database query) being infused with the spark of life (object
behavior, aka class).
<source>Jim Fulton on the term "pluggable brains", 5 Jul 1999</source>
</quotation>

<quotation>
This is good. It means that while Ionesco is dead, his spirit
lives on.
<source>Gordon McMillan on how Windows attaches meaning to 3-character
file extensions, 30 Jul 1999</source> 
</quotation>

<quotation>
(On the statement <code>print "42 monkeys"+"1 snake"</code>)
BTW, both perl and Python get this wrong.  Perl gives 43 and Python
gives "42 monkeys1 snake", when the answer is clearly "41 monkeys and
1 fat snake". 
<source>Jim Fulton, 10 Aug 1999
</source>
</quotation>

<quotation>
I expect that what you really object to is the absence
of control structures other than goto, and the LT/GE/etc spelling of
comparison operators.  That was common enough in its day, and even by the
time Pascal came around the keypunch I used still didn't have a semicolon
key.  It looks ugly in retrospect only because it is &lt;wink&gt;.
<source>Tim Peters on SNOBOL4, 17 Aug 1999</source> 
</quotation>

<quotation>
Theory and reality rarely are kissing cousins.
<source>Christopher Petrilli, 1 Sep 1999</source> 
</quotation>

<quotation>
Features generally don't exist in isolation, and you have to look at all the
consequences, not just the one that attracts you at first sight.
<source>Tim Peters, 3 Sep 1999</source> 
</quotation>

<quotation>
The danger in this line of thinking is not realizing that the
computational effort involved in big NP complete problems
is *so* huge that even in optimized micro-code, the
algorithm might take a million years to run.
Tweezers or shovel -- it makes little difference when you
are trying to move a universe...
<source>Sean McGrath, 4 Sep 1999</source> 
</quotation>

<quotation>
On a scale of one to ten I'd give it a tim.
<source>William Tanksley, 13 Sep 1999</source> 
</quotation>

<quotation>
Statistical analysis shows that the junk
    looks like human text, which clearly shows
    that it is actually used in some yet unknown
    way.
    (docstrings?)
<source>Fredrik Lundh, writing about junk DNA, 05 Oct 1999</source> 
</quotation>

<quotation>
If I engineer code that I expect to be in use for N
years, I make damn sure that every internal limit is at least 10x larger
than the largest I can conceive of a user making reasonable use of at the
end of those N years.  The invariable result is that the N years pass, and
fewer than half of the users have bumped into the limit &lt;0.5 wink&gt;.
<source>Tim Peters, 11 Nov 1999</source> 
</quotation>

<quotation>
I don't think the bytecodehacks, while sufficiently dark and useless
to be a tim-ism, qualify me in any way for a Pythonic Wizard Hat...
<source>Michael Hudson, 16 Nov 1999</source> 
</quotation>

<quotation>
The bottom tier is what
a certain class of wanker would call "business objects" ...
<source>Greg Ward, 9 Dec 1999</source> 
</quotation>

<quotation>
Since I've done fewer than my normal quota of futile things this
week, I thought I'd post to remind people that ...
<source>Phil Austin, 9 Dec 1999</source> 
</quotation>

<quotation>
There are useful diagrams in UML, (eg, the state and
transition diagrams). Unfortunately, the one most tools use to
generate code (and draw from reverse engineering) has
everything to do with language structure, and nothing to do
with what actually happens at runtime. To put it bluntly:
people spend most of their time designing the wrong thing.
Worse, they get it wrong, but it's carved in stone now; so the
final system is either needlessly complex and marginally
functional, or bears no resemblance to the "design".
<source>Gordon McMillan, 15 Dec 1999</source> 
</quotation>

<quotation>
The secret to good performance is to prototype and prototype,
then code the bottlenecks in a faster language. The secret to
large systems is to prototype and prototype, until you've got
clean separation of the system into managable pieces, then
code in whatever language most suits the need of each piece.
<source>Gordon McMillan, 15 Dec 1999</source> 
</quotation>

<quotation>
When Jim [Fulton] says "tricky" it means your brain could explode.
<source>Michel Pelletier, 15 Dec 1999</source> 
</quotation>

<quotation>
You have start-tags,
attributes, end-tags and character data. We have all
seen "XML applications" and "XML parsers" which handle
this gang-of-four concepts.  ... 
Now we can peer over the parapet and shout
"your parser smells of elderberries" or
"I wave my mixed content at your ankles",
as long as we like but the simple
gang-of-four base apps will not go away.
<source>Sean McGrath, 19 Dec 1999</source> 
</quotation>

<quotation>
Abstraction is one of those notions that Python tosses out the
window, yet expresses very well.
<source>Gordon McMillan, 6 Jan 2000</source> 
</quotation>

<quotation>
The set of naming conventions has a cardinality equal to the
number of Python users.
<source>Gordon McMillan, 6 Jan 2000</source> 
</quotation>

<quotation>
It's not the mail volume that bothers me -- I can ignore 100s of
messages a day very quickly.  It's the time it takes to respond to all
of them.
<source>Guido van Rossum, 20 Jan 2000</source> 
</quotation>

<quotation>
   This is the way of Haskell or
Design by Contract of Eiffel. This one is like wearing a XV century
armor, you walk very safely but in a very tiring way. 
<source>Manuel Gutierrez Algaba, 26 Jan 2000</source>
</quotation>

<quotation>
Life's better without braces.
<source>Unofficial motto of IPC8, coined by Bruce Eckel</source>
</quotation>

<quotation>
"Aggressive" means "sometimes wrong".
<source>John Aycock at IPC8, during his "Agressive Type Inferencing" talk</source>
</quotation>

<quotation>
Do I do everything in C++ and teach a course in advanced swearing?
<source>David Beazley at IPC8, on choosing a language for teaching</source>
</quotation>

<quotation>
Alice is 3D Logo on steroids.
<source>Randy Pausch at IPC8</source>
</quotation>

<quotation>
I was willing to grant this one at once, but, now that I look back at it
all -- the loyalty oaths, the relentless self-criticism sessions, the
midnight visits from the Ministry of Love -- I'm afraid what we really have
here is unspeakably more sinister.  
<source>Tim Peters after a reference to "Python's cult-like
following", 2 Feb 2000</source>
</quotation>

<quotation>
Guido (like us!) is a bit schizophrenic here:  he wants to be a benevolent
dictator, but also wants to treat people like grownups.  This probably
worked better before Python got a large American audience &lt;0.9 wink&gt;. 
<source>Tim Peters, 10 Feb 2000</source>
</quotation>

<quotation>
I have formal proofs that any change of the indentation rules results
in 35% increase of the page faults for only 63.7% of the cache misses.
The net effect is an overall slowdown of 10%.
<source>Vladimir Marangozov after Yet Another indentation flamewar, 16 Feb 2000</source>
</quotation>

<quotation>
... let me just say that my least-favourite Python
error message is "SyntaxError: invalid syntax", which somehow manages to
be both overly terse and redundant at the same time.
<source>Greg Ward, 15 Feb 2000</source>
</quotation>

<quotation>
See, functional programmers are an insular lot. You rarely see
them in public, except at parades when they all have antler-
hats and silly shoes on. So they completely missed the
infamous "goto considered harmful" thread and didn't even
realize they were doing anything wrong.

<br/>

Now, let's pretend you're writing a 'bot that can pass as a
functional programmer. There's a complex protocol here.
When two functional programmers see each other on the
street, they recognize each other by the antler hats. But in
certain parts of the Midwest, regular people wear antler hats,
too. So there's a protocol. First a &lt;wink wink&gt;. Then the
secret handshake. Then you sniff each other's armpits and
stamp your foot 3 times.

<br/>

OK, so you've written a bot, and it works fine on the street.
Now you send it to a cocktail party. It sees a potential
functional programmer and gives the &lt;wink wink&gt;. Now it tries
to move into position to do the secret handshake, but
discovers that it's antler-hat is entangled with someone else's.
Oops. &lt;wink wink&gt; at the new guy. Handshake. But before it
can sniff, the first one has moved up for his handshake. Ay yi
yi. Your bot crashes and is exposed.

<br/>

So now you rewrite your bot to use a finite state machine so it
can handle multiple sessions. That means throwing out all the
code that worked on the street. But if you'd used
continuations, it would be a relatively minor adjustment of that
code. 'Course you wouldn't have had to write the bot to begin
with.

<source>Gordon McMillan,  18 Feb 2000  </source>
</quotation>

<quotation>
IIRC, Guido went to CNRI to work on bots and agents or something
similar. Could the timbot and the effbot be an offshoot of that?
Next, he's going to start a company with timbot and effbot as the main
products. Van Rossum's Universal Robots?
<source>Bernhard Herzog,  21 Feb 2000 </source>
</quotation>

<quotation>
So those are the extremes:  Boehm-Demers-Weiser avoids blame by refusing to do anything.
Java avoids blame by exposing an impossibly baroque implementation-driven
finalization model.  Scheme avoids blame by refusing to do anything "by
magic", but helps you to shoot yourself with the weapon of your choice.
The bad news is that I don't know of a scheme <em>not</em> at an extreme!
<source>Tim Peters on the knotty problem of finalizers and cycles, 3 Mar 2000 </source>
</quotation>

<quotation>
It's extremely un-Pythonic to let things leak (despite that it has let
things leak for a decade &lt;wink&gt;), but also extremely un-Pythonic to make
some wild-ass guess.
<source>Tim Peters on garbage collection, 3 Mar 2000 </source>
</quotation>

<quotation>
IOW, the only people who lose under this scheme are the
ones begging to lose, and their "loss" consists of taking responsibility.
<source>Tim Peters, 3 Mar 2000 </source>
</quotation>

<quotation>
An axiom is accepted without proof:  we have plenty of proof that there's no
thoroughly good answer (i.e., every language that has ever addressed this
issue -- along with every language that ever will &lt;wink&gt;).
<source>Tim Peters on garbage collection, 3 Mar 2000 </source>
</quotation>

<quotation>
I can see the FAQ now...
<br/>
   Q1.1.2.3: Why can't I divide integers?
<br/>   
   A: You drooling moron!  You need a 10-page owners manual and
   instructional video to handle the notational complexity of
   Tic-Tacs, don't you?  As every schoolboy knows, the integers are a
   <em>ring</em>, not a field, you simpering simpleton.  Oh wait!  Let me
   guess!  I have to spell it out for you, you festering wombat boil.
   You can't divide integers by integers and get integers.  Understand
   now?  Now go out there and don't do it.  And read Herstein, while
   you're at it.
<source>Johann Hibschman, 4 Mar 2000 </source>
</quotation>

<quotation>
Actually, I believe you understand me fine,
you'd just rather not believe it:  floating point sucks, rationals suck,
refusing to allow int division sucks, the constructive reals suck, symbolic
manipulation sucks, ..., but all in different ways for different reasons.
Every one bristles with its own brands of both shallow and deep "surprises".
So it goes -- seeking to represent the infinite by the finite is an
inherently unreachable goal.  This is also why people die &lt;wink&gt;.
<source>Tim Peters, 4 Mar 2000 </source>
</quotation>

<quotation>
The reason I'm right is that I said there won't be any <em>single</em>
"survivor" of the evolutionary struggle,  and that the efforts to crown
one's favorite as such are just so much noise.  The software ecosystem
of the foreseeable future will always have its own form of "diversity": 
there will be lions <em>and</em> elephants <em>and</em> fish <em>and</em> seals <em>and</em> birds, 
because there will be many diverse "habitats" where the particular
adaptations of each will be needed/advantageous.
<br/>
The reasoned debates (as opposed to religious wars) may lead to lions
with opposable thumbs,  or elephants that can see in the infrared,  but
there will never be a 2000-pound fish with a mane and wings.  Well,  not
outside the lab,  anyway.
<source>Ran, 5 Mar 2000 </source>
</quotation>

<quotation>
"Complexity" seems to be a lot like "energy":  you can <em>transfer</em> it
from the end user to one/some of the other players,  but the total
amount seems to remain pretty much constant for a given task.
<source>Ran, 5 Mar 2000 </source>
</quotation>

<quotation>
LaTeX2HTML is pain.
<source>Fred Drake in a documentation checkin message, 14 Mar 2000 </source>
</quotation>

<quotation>
Here, have some cycles of reversed kielbasa.  And ten (10 (0xa (101010b)))
Usenet Points, redeemable in comp.lang.python for increased local
prestige.  Some prestige may depend upon your own actions.  Local Prestige
may or may not have any effect on your actual life (or lack thereof).
<source>William Tanksley, 21 Mar 2000 </source>
</quotation>

<quotation>
Mucking with
builtins is fun the way huffing dry erase markers is fun.  Things are
very pretty at first, but eventually the brain cell lossage will more
than outweigh that cheap thrill.
<source>Barry Warsaw, 23 Mar 2000 </source>
</quotation>

<quotation>
&gt;Have you ever looked at the output of a <code>bib | tbl | eqn</code> pipeline?
<br/>
Are you kids still using that as a pick-up line?
<source>Roy Smith and Cameron Laird, 4 Apr 2000</source>
</quotation>

<quotation>
This
is like getting lost in a dictionary.  What does quincuncial mean anyhow?
<source>Dennis Hamilton, 4 Apr 2000</source>
</quotation>

<quotation>
UTF-8 has a certain purity in that it equally annoys every nation, and is
nobody's default encoding. 
<source>Andy Robinson, 10 Apr 2000</source>
</quotation>

<quotation>
"Now if we could
figure
out where python programmers are from, someone could write a book and get
rich."
<br/>
"Yorkshire."
<source>Quinn Dunkan and Warren Postma, 11 Apr 2000</source>
</quotation>

<quotation>
   If I didn't have my part-time performance art
   income to help pay the bills, I could never
   afford to support my programming lifestyle.
<source>Jeff Bauer, 21 Apr 2000</source>
</quotation>

<quotation>
  Of course, this brought me face to face once again with Python's
  <foreign>pons asinorum</foreign>, the significance of whitespace.
<source>Eric S. Raymond, in the <cite>Linux Journal</cite>'s Python supplement</source>
</quotation>

<quotation>
Surprisingly enough, Python has taught me more about Lisp than Lisp
ever did ;-).
   <source>Glyph Lefkowitz, 03 May 2000</source>
</quotation>

<quotation>
 How about we notate the hungarian notation with the type of hungarian
   notation, you know, hungarian meta notation: HWND
   aWin32ApiHandleDefinedInWindowsDotH_hwndWindowHandle;
   <source>Warren Postma, 4 May 2000</source>
</quotation>

<quotation>
Note that Python's licence is in fact the MIT X11 licence, with MIT
filed off and CNRI written in its place in crayon.
   <source>A.M. Kuchling, 5 May 2000</source>
</quotation>

<quotation>
Once you've read and
understood _The Art of the Metaobject Protocol_ you are one quarter of
the way to provisional wizard status. (The other three-fourths are b)
understanding Haskell's monads, c) grokking Prolog, and d) becoming
handy with a combinator-based language by implementing a Forth.)
   <source>Neel Krishnaswami, 9 May 2000</source>
</quotation>

<quotation>
"The future" has
arrived but they forgot to update the docs.
<source>R. David Murray, 9 May 2000</source>
</quotation>

<quotation>
/* This algorithm is from a book written before the invention of
     structured programming... */
   <source>Comment in parser/pgen.c, noted by Michael Hudson</source>
</quotation>

<quotation>
For more information please see my unpublished manuscript
on steam driven turing machines. [2000pp in crayon donated to
the harvard library -- they never told me whether they filed it
under mathematics, philosophy, logic, mechanical engineering,
or computational science]
   <source>Aaron Watters, 12 May 2000</source>
</quotation>

<quotation>
Me?  I hate the whole lambda calculus, not because of what it is, but
because of what many people think it is.  They think that it's the whole
of computer science, the ultimate way to express and reason about
programs, when in reality it's merely a shabby and incomplete model of how
Fortran fails to work.  The first thing SICP has to do is teach everyone
how bad the lambda calculus model is -- as part of teaching them about a
language allegedly based on lambda calculus.
<br/>
I'm sorry, was my bias showing again?  :-)
<source>William Tanksley, 13 May 2000</source>
</quotation>

<quotation>
 I never got beyond starting the data-structures in C++, I never got
beyond seeing how it would work in Scheme. I finished it in one
Python-filled afternoon, and discovered the idea sucked big time.  I
was glad I did it in Python, because it only cost me one afternoon to
discover the idea sucks.  
<source>Moshe Zadka, 13 May 2000</source>
</quotation>

<quotation>
In truth, we use 'j' to represent sqrt(-1) for exactly the same reason
we use a convention for the direction of current which is exactly the
opposite of the direction the electrons actually travel: because it
drives physicists crazy.  (And if we pick up a few mathematicians or
whatever along the way, well, that's just gravy. ;-)
<source>Grant R. Griffin, 14 May 2000</source>
</quotation>

<quotation>
Unicode: everyone wants it, until they get it.
<source>Barry Warsaw, 16 May 2000</source>
</quotation>

<quotation>
I saw a hack you sent me a few months ago and approved of its
intent and was saddened by its necessity.
<source>Jim Fulton, 16 May 2000</source>
</quotation>

<quotation>
Suspicions are most easily dispelled/confirmed via evidence, and
taking the trouble to do this has the pleasant side-effect that you
can either cease expending effort worrying, or move directly to taking
positive action to correct the problem.
<source>Neel Krishnaswami, 21 May 2000</source>
</quotation>

<quotation>
Thanks to the
overnight turnaround and the early interpreter's habit of
returning nothing at all useful if faced with a shortage of )s,
one could easily detect the LISP users:  they tended to walk
around with cards full of )))))))... in their shirt pockets, to be
slapped onto the end of submitted card decks:  one at least
got something back if there were too many )s.
<source>John W. Baxter, 21 May 2000</source>
</quotation>

<quotation>
Python: embodies a harmony of chocolate kisses with hints of jasmine
and rose. Trussardi's wild new fragrance.
<source>From <cite>Marie Claire</cite>, Australian edition, May 2000;
noted by Fiona Czuczman</source>
</quotation>

<quotation>
In arts, compromises yield mediocre results.  The personality and vision
of the artist has to go through.  I like to see Python as a piece of art.
I just hope the artist will not get too tainted by usability studies.
<source>Fran&ccedil;ois Pinard, 22 May 2000</source>
</quotation>

<quotation>
 In fact, I've never seen an argument about which I
cared less.  I'm completely case insensitivity insensitive.
<source>William Tanksley, 23 May 2000</source>
</quotation>

<quotation>
They boo-ed when Dylan went electric.
But for me its about the instincts of a designer, and the faith of a fan.
Not science.
So much the better.
<source>Arthur Siegel, 23 May 2000</source>
</quotation>

<quotation>
Burroughs did something very odd with COBOL at one point (and no, it
wasn't The Naked Lunch).
<source>Will Rose, 27 May 2000</source>
</quotation>

<quotation>
Code generators are hacks. Sometimes necessary hacks, but hacks
nevertheless.
<source>Paul Prescod, 7 Jun 2000</source>
</quotation>

</quotations>

