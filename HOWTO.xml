<?xml version='1.0' encoding='iso-8859-1'?>
<par>&xist; is an &xml; based extensible &html; generator written in Python.
It was developed as a replacement for an &html; preprocessor named
<app moreinfo="http://www.linguistik.uni-erlangen.de/~msbethke/hsc/">HSC</app>
and borrows some features and ideas from it. It also borrows the basic ideas
(&xml;/&html; elements as Python objects) from
<app moreinfo="http://starship.python.net/crew/friedrich/HTMLgen/html/main.html">HTMLgen</app>
or <app moreinfo="http://dustman.net/andy/python/HyperText/">HyperText</app>.</par>


<section><title>Overview</title>
<par>&xist; can be used as a compiler that reads an input &xml; file
and generates a transformed output file, or it could be used for generating
&xml; dynamically inside a web server (but note that handling object trees
<em>is</em> slower than simply sending constant output strings).
In either case generating the final &html; or &xml; output requires
the following three steps:</par>
<ulist>
<item>Generating a source &xml; tree: This can be done either by
parsing an &xml; file, or by directly constructing the
tree &mdash; as <app>HTMLgen</app> and <app>HyperText</app>
do &mdash; as a tree of Python objects. &xist; provides a very natural
and pythonic &api; for that.</item>
<item>Converting the source tree into a target tree: This target
tree can be a &html; tree or a &svg; tree or XSL-Fo tree or any other
&xml; tree you like. Every node class provides a
<method>convert</method> method for performing the conversion. For
your own &xml; element types you have to define your
own element classes and implement an appropriate
<method>convert</method> method. This is possible for
processing instructions and entity references too.</item>
<item>Publishing the target tree: For generating the final
output a <class>Publisher</class> object is used that writes
the final &xml; to an output stream.</item>
</ulist>
</section>


<section><title>Constructing &xml; trees</title>
<par>Like any other &dom; &api;, &xist; provides the usual classes:</par>
<ulist>
<item><pyref module="ll.xist.xsc" class="Text"><class>Text</class></pyref> for text data</item>
<item><pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref> for document fragments,
a <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref> object is simply a list
of nodes,</item>
<item><pyref module="ll.xist.xsc" class="Comment"><class>Comment</class></pyref> for &xml; comments
(e.g. <markup>&lt;!-- the comment --&gt;</markup>)</item>
<item><pyref module="ll.xist.xsc" class="DocType"><class>DocType</class></pyref> for document type
declarations (e.g. <markup>&lt;!DOCTYPE html PUBLIC <rep>...</rep>&gt;</markup>),</item>
<item><pyref module="ll.xist.xsc" class="ProcInst"><class>ProcInst</class></pyref> for processing instructions
(e.g. <markup>&lt;?php echo $spam;?&gt;</markup>),</item>
<item><pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref> for &xml; elements,</item>
<item><pyref module="ll.xist.xsc" class="Entity"><class>Entity</class></pyref> for entities
(e.g. <markup>&amp;parrot;</markup>),</item>
<item><pyref module="ll.xist.xsc" class="Attr"><class>Attr</class></pyref> for attributes and</item>
<item><pyref module="ll.xist.xsc" class="Attrs"><class>Attrs</class></pyref> for attribute mappings.</item>
</ulist>

<section><title>&xml; trees as Python objects</title>
<par>&xist; works somewhat different from a normal &dom; &api;.
Instead of only one element class, &xist; has one class for every element
type. All the standard elements known to &xist; are defined in modules in
the <pyref module="ll.xist.ns"><module>ll.xist.ns</module></pyref> subpackage.
The definition of &html; can be found in
<pyref module="ll.xist.ns.html"><module>ll.xist.ns.html</module></pyref>
for example.</par>

<par>Every element class has a constructor of the form:</par>
<prog>
__init__(self, *content, **attrs)
</prog>
<par>Positional arguments (i.e. items in <arg>content</arg>)
will be the child nodes of the element node. Keyword arguments
will be attributes. You can pass most builtin types to such a constructor.
Strings and integers will be automatically converted to
<pyref module="ll.xist.xsc" class="Text"><class>Text</class></pyref> objects.
Constructing an &html; element works like this:</par>
<example><title>The first example</title>
<prog>
from ll.xist.ns import html

node = html.div(
	"Hello ",
	html.a("Python", href="http://www.python.org/"),
	" world!"
)
</prog>
</example>

<par>For attribute names that collide with Python keywords
or are not legal identifiers (most notably <lit>class</lit>), the attribute name
must be slightly modified, so that it's a legal Python identifier
(for <lit>class</lit> an underscore is appended):</par>
<example><title>Colliding attribute names</title>
<prog>
node = html.div(
	"Hello world!",
	class_="greeting"
)
</prog>
</example>
<par>(Don't worry: This modified attribute name will be mapped to the real official attribute
name once the output file is written.) You can pass attributes as a dictionary too:</par>
<example><title>Passing attributes as dictionaries</title>
<prog>
node = html.div(
	"Hello world!",
	{
		"class_": "greeting",
		"id": 42,
		"title": "Greet the world"
	}
)
</prog>
</example>
</section>

<section><title>Generating &xml; trees from &xml; files</title>
<par>Of course &xml; trees can also be generated by parsing
&xml; files. For this the module <pyref module="ll.xist.parsers"><module>ll.xist.parsers</module></pyref>
provides several functions:</par>
<prog>
def parseString(text, base=None, sysid=None, **parserargs)
def parseURL(id, base=None, sysid=None, **parserargs)
def parseFile(filename, base=None, sysid=None, **parserargs)
</prog>
<par><pyref module="ll.xist.parsers" function="parseString"><function>parseString</function></pyref>
is for parsing strings (8bit and Unicode) and
<pyref module="ll.xist.parsers" function="parseURL"><function>parseURL</function></pyref> is for
parsing resources from &url;s. With
<pyref module="ll.xist.parsers" function="parseFile"><function>parseFile</function></pyref> you can parse
local files.</par>
<par>All three functions call create a parser internally, parse the supplied source document and will
return the resulting object tree.</par>
<par>For further info about the rest of the arguments, see the documentation
for <pyref module="ll.xist.parsers" class="Parser"><class>ll.xist.parsers.Parser</class></pyref>.</par>
</section>
</section>


<section><title>Defining new elements and converting &xml; trees</title>

<par>To be able to parse an &xml; file, you have to provide an element class
for every element type that appears in the file. Defining an element class
for an element named <lit>cool</lit> works like this:</par>

<example><title>Defining a new element</title>
<prog>
class cool(xsc.Element):
	empty = False

	def convert(self, converter):
		node = html.b(self.content, " is cool!")
		return node.convert(converter)
</prog>
</example>

<par>You have to derive your new class from
<pyref module="ll.xist.xsc" class="Element"><class>xsc.Element</class></pyref>.
The name of the class will be the element name. For element type names that
are invalid Python identifiers, you can use the class attribute <lit>xmlname</lit>
in the element class to overwrite the element name.</par>
<par>To be able to convert an element of this type to a new &xml; tree
(&html; in most cases), you have to implement the
<pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
method. In this method you can build a new &xml; tree from the content and attributes
of the object.</par>

<par>Using this new element is simple</par>

<example><title>Using the new element</title>
<prog>
&gt;&gt;&gt; node = cool("Python")
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;Python is cool!&lt;/b&gt;
</prog>
</example>

<par><pyref module="ll.xist.xsc" class="Node" method="conv"><method>conv</method></pyref> simply
calls
<pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
with a default <pyref module="ll.xist.converters" class="Converter"><arg>converter</arg></pyref>
argument. We'll come to converters in a minute.
<pyref module="ll.xist.xsc" class="Node" method="asBytes"><method>asBytes</method></pyref>
is a method that converts the node to a byte string. This method will be explained
when we discuss the publishing interface.</par>

<par>Note that it is vital for your own <method>convert</method>
methods that you recursively call <method>convert</method>
on your own content, because otherwise some unconverted nodes
might remain in the tree. Lets define a new element:</par>
<prog>
class python(xsc.Element):
	empty = True

	def convert(self, converter):
		return html.a(
			"Python",
			href="http://www.python.org/"
		)
</prog>
<par>Now we can do the following:</par>
<prog>
&gt;&gt;&gt; node = cool(python())
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is cool!&lt;/b&gt;
</prog>
<par>But if we forget to call
<pyref module="ll.xist.xsc" class="Node" method="convert">convert</pyref>
for our own content, i.e. if the element <pyref class="cool"><class>cool</class></pyref>
was written like this:</par>
<prog>
class cool(xsc.Element):
	empty = False

	def convert(self, converter):
		return html.b(self.content, " is cool!")
</prog>
<par>we would get:</par>
<prog>
&gt;&gt;&gt; node = cool(python())
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;&lt;python /&gt; is cool!&lt;/b&gt;
</prog>

<par>Furthermore <method>convert</method> should never modify <self/>.</par>

<section><title>Converters</title>
<par><pyref module="ll.xist.xsc" class="Node" method="conv"><method>conv</method></pyref>
is a convenience method that creates a default converter for you and calls
<pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>.
You could also call <pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref> yourself,
which would look like this:</par>

<prog>
from ll.xist import converters
from ll.xist.ns import html

node = cool(python())
node = node.convert(
	converters.Converter(
		None, None, "deliver", html, None
	)
)
</prog>

<par>You can pass the following five arguments to the
<pyref module="ll.xist.converters" class="Converter"><class>Converter</class></pyref> constructor:</par>
<dlist>
<term><arg>root</arg></term><item><arg>root</arg> (which defaults to <lit>None</lit>) is the root &url;
for the conversion process. When you want to resolve a link in some of your own <method>convert</method> methods,
the &url; must be interpreted relative to this root &url; (You can use
<pyref module="ll.xist.xsc" class="URLAttr" method="forInput"><method>URLAttr.forInput</method></pyref>
for that).</item>
<term><arg>mode</arg></term><item><arg>mode</arg> (which defaults to <lit>None</lit>) works the same way as modes in &xslt;.
You can use this for implementing different conversion modes.</item>
<term><arg>stage</arg></term><item><arg>stage</arg> (which defaults to <lit>"deliver"</lit>)
allows you to implement multi stage conversion: Suppose that you want to deliver a dynamically constructed web page with &xist;
that contains results from a database query and the current time. The data in the database changes
infrequently, so it doesn't make sense to do the query on every request. The query is done
every few minutes and the resulting &html; tree is stored in the servlet
(using any of the available Python servlet technologies). For this conversion the
<arg>stage</arg> would be <lit>"cache"</lit> and your database &xml; element would do the
query when <lit><arg>stage</arg>=="cache"</lit>. Your time display element would do the conversion
when <lit><arg>stage</arg>=="deliver"</lit> and simply returns itself when
<lit><arg>stage</arg>=="cache"</lit>, so it would still be part of the cached &xml; tree
and would be converted to &html; on every request.</item>
<term><arg>target</arg></term><item><arg>target</arg> (which defaults to
<pyref module="ll.xist.ns.html"><module>ll.xist.ns.html</module></pyref>) specifies what the output should be.
Values must be <pyref module="ll.xist.xsc" class="Namespace">namespace subclasses</pyref>
(see below for an explanation of namespaces).</item>
<term><arg>lang</arg></term><item><par><arg>lang</arg> (which defaults to <lit>None</lit>) is the language
in which the result tree should be. This can be used in the <method>convert</method> method
to implement different conversions for different languages, e.g.:</par>
<prog>
class note(xsc.Element):
	empty = False

	def convert(self, converter):
		if converter.lang=="de":
			title = "Anmerkung"
		elif converter.lang=="en":
			title = "Note"
		else:
			title = "???"
		return xsc.Frag(
			html.h1(title),
			html.div(self.content.convert(converter))
		)
</prog>
<par>and you can test for the language with the element
<pyref module="ll.xist.ns.cond" class="If"><class>ll.xist.ns.cond.If</class></pyref>, e.g.:</par>
<prog>
&lt;if lang="de"&gt;Anmerkung
&lt;elif lang="en"&gt;Note
&lt;else&gt;???
&lt;/if&gt;
</prog>
</item>
</dlist>

<par>Additional arguments are passed when a converter is created in the context of
a <pyref module="ll.make"><module>make</module></pyref> script.</par>

</section>

<section><title>Attributes</title>
<par>Setting and accessing the attributes of an element works via
the dictionary interface:</par>
<example>
<prog>
&gt;&gt;&gt; node = html.a("Python", href="http://www.python.org")
&gt;&gt;&gt; print node["href"].asBytes()
http://www.python.org/
&gt;&gt;&gt; del node["href"]
&gt;&gt;&gt; print node["href"].asBytes()

&gt;&gt;&gt; node["href"] = "http://www.python.org"
&gt;&gt;&gt; print node["href"].asBytes()
http://www.python.org/
</prog>
</example>

<par>All attribute values are instances of subclasses of
the class <pyref module="ll.xist.xsc" class="Attr"><class>Attr</class></pyref>. Available
subclasses are:</par>

<ulist>
<item><pyref module="ll.xist.xsc" class="TextAttr"><class>TextAttr</class></pyref>, for normal text attributes;</item>
<item><pyref module="ll.xist.xsc" class="URLAttr"><class>URLAttr</class></pyref>, for attributes that are &url;s;</item>
<item><pyref module="ll.xist.xsc" class="BoolAttr"><class>BoolAttr</class></pyref>, for boolean attributes (for such an attribute
only its presence is important, it's value will always be the same as the attribute name when publishing);</item>
<item><pyref module="ll.xist.xsc" class="IntAttr"><class>IntAttr</class></pyref>, for integer attributes;</item>
<item><pyref module="ll.xist.xsc" class="ColorAttr"><class>ColorAttr</class></pyref>, for color attributes (e.g. <lit>#ffffff</lit>).</item>
</ulist>

<par><pyref module="ll.xist.xsc" class="Attr"><class>Attr</class></pyref> itself is derived from
<pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref> so it is possible
to use all the sequence methods on an attribute.</par>

<par>Unset attributes will be treated like empty ones so the following is possible:</par>

<example>
<prog>
del node["spam"]
node["spam"].append("ham")
</prog>
</example>

<par>This also means that after</par>

<example>
<prog>
del node["spam"][:]
</prog>
</example>

<par>the attribute will be empty again and will be considered to be unset.
Such attributes will be ignored when publishing.</par>

<section><title>Specifying content model and attribute types</title>
<par>When you define a new element you have to specify two things:</par>

<olist>
<item>If the element has an empty content model (like <markup>&lt;br/&gt;</markup>
or <markup>&lt;img/&gt;</markup> do in &html;) or not.</item>
<item>what attributes the element supports and of which type they are.</item>
</olist>

<par>Specifying the content model is done with the class attribute <lit>empty</lit>.
Set it to <lit>False</lit> when your element may have content and to <lit>True</lit>
if it may not.</par>

<par>To specify the attributes for the element, use the class
attribute <lit>Attrs</lit>, which must be a class derived
from <pyref module="ll.xist.xsc" class="Element.Attrs"><class>xsc.Element.Attrs</class></pyref>
and define the attributes by deriving them from one of the existing attribute classes.
We could extend our example element in the following way:</par>

<example><title>Using attributes</title>
<prog>
class cool(xsc.Element):
	empty = False
	class Attrs(xsc.Element.Attrs):
		class adj(xsc.TextAttr): pass

	def convert(self, converter):
		node = xsc.Frag(self.content, " is")
		if "adj" in self.attrs:
			node.append(" ", html.em(self["adj"]))
		node.append(" cool!")
		return node.convert(converter)
</prog>
</example>

<par>and use it like this:</par>

<prog>
&gt;&gt;&gt; node = cool(python(), adj="totally")
&gt;&gt;&gt; print node.conv().asBytes()
&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is \
&lt;em&gt;totally&lt;/em&gt; cool!
</prog>

<section><title>Default attributes</title>
<par>It is possible to define default values for attributes via
the class attribute <lit>default</lit>:</par>

<example><title>Defining default attributes</title>
<prog>
class cool(xsc.Element):
	empty = False
	class Attrs(xsc.Element.Attrs):
		class adj(xsc.TextAttr):
			default = "absolutely"

	def convert(self, converter):
		node = xsc.Frag(self.content, " is")
		if "adj" in self.attrs:
			node.append(" ", html.em(self["adj"]))
		node.append(" cool!")
		return node.convert(converter)
</prog>
</example>

<par>Now if we instantiate the class without specifying
<lit>adj</lit> we'll get the default:</par>

<example><title>Using default attributes</title>
<prog>
&gt;&gt;&gt; node = cool(python())
&gt;&gt;&gt; print node.conv().asBytes()
&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is \
&lt;em&gt;absolutely&lt;/em&gt; cool!
</prog>
</example>

<par>If we want a <class>cool</class> instance without
an <lit>adj</lit> attribute, we can pass <lit>None</lit>
as the attribute value:</par>

<example><title>Removing default attributes</title>
<prog>
&gt;&gt;&gt; node = cool(python(), adj=None)
&gt;&gt;&gt; print node.conv().asBytes()
&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is cool!
</prog>
</example>

</section>

<section><title>Attribute value sets</title>
<par>It's possible to specify that an attribute has a fixed set of allowed
values. This can be done with the class attribute <lit>values</lit>. We could
extend our example to look like this:</par>

<example><title>Defining attributes value sets</title>
<prog>
class cool(xsc.Element):
	empty = False
	class Attrs(xsc.Element.Attrs):
		class adj(xsc.TextAttr):
			default = "absolutely"
			values = (
				"absolutely",
				"totally",
				"very"
			)

	def convert(self, converter):
		node = xsc.Frag(self.content, " is")
		if "adj" in self.attrs:
			node.append(" ", html.em(self["adj"]))
		node.append(" cool!")
		return node.convert(converter)
</prog>
</example>

<par>These values won't be checked when we create our <class>cool</class>
instance. Only when this node is parsed from a file will the warning
be issued:</par>

<prog>
&gt;&gt;&gt; s = '&lt;cool adj="pretty"&gt;&lt;python/&gt;&lt;/cool&gt;'
&gt;&gt;&gt; node = parsers.parseString(s)
/home/walter/pythonroot/ll/xist/xsc.py:1338: \
    UserWarning: Attribute value 'pretty' \
    not allowed for __main__:cool.Attrs.adj.
  self.checkvalid()
</prog>

<par>The warning will also be issued if we publish such a node,
but note that for warnings Python's warning framework is used,
so the warning will be printed only once (but of course
you can change that with <function>warnings.filterwarnings</function>):</par>

<prog>
&gt;&gt;&gt; node = cool(python(), adj="pretty")
&gt;&gt;&gt; print node.asBytes()
/home/walter/pythonroot/ll/xist/xsc.py:1338: \
    UserWarning: Attribute value 'pretty' \
    not allowed for __main__:cool.Attrs.adj.
  self.checkvalid()
&lt;cool adj="very"&gt;&lt;python /&gt;&lt;/cool&gt;
</prog>

</section>

<section><title>Required attributes</title>
<par>Finally it's possible to specify that an attribute is required.
This again will only be checked when parsing or publishing. To specify that an
attribute is required simply add the class attribute <lit>required</lit>
with the value <lit>True</lit>. The attribute <lit>alt</lit> of the
class <pyref module="ll.xist.ns.html" class="img"><class>ll.xist.ns.html.img</class></pyref>
is such an attribute, so we'll get:</par>

<example><title>Missing required attributes</title>
<prog>
&gt;&gt;&gt; from ll.xist.ns import html
&gt;&gt;&gt; node = html.img(src="eggs.png")
&gt;&gt;&gt; print node.asBytes()
/home/walter/pythonroot/ll/xist/xsc.py:2075: \
    UserWarning: Required attribute 'alt' missing \
    in ll.xist.ns.html:img.Attrs.
  self.attrs.publish(publisher)
&lt;img src="eggs.png" /&gt;
</prog>
</example>

</section>

</section>

<section><title>Namespaces</title>

<par>Now that you've defined your own elements, you have to
tell the parser about them, so they can be instantiated when
a file is parsed. This is done with namespace classes.</par>

<par>Namespace classes can be thought of as object oriented versions of
&xml; namespaces. Two class attributes can be used to configure the namespace:
<lit>xmlname</lit> specifies the default namespace prefix to use for the namespace
and <lit>xmlurl</lit> is the namespace name. All element classes nested inside the
namespace class belong to the namespace.</par>

<par>It's also possible to define your namespace class without any nested element classes.
and later add those classes to the namespace by attribute assignment or with the class method
<pyref module="ll.xist.xsc" class="Namespace" method="update"><method>update</method></pyref>,
which expects a dictionary as an argument. All objects found in the values of the
dictionary will be added to the namespace as attributes. So you can put the namespace class
at the end of your Python module after all the element classes are defined and
add all the objects from the local scope to the namespace. Your complete namespace
might looks like this:</par>
<example><title>Defining and populating a namespace</title>
<prog>
class python(xsc.Element):
	empty = True

	def convert(self, converter):
		return html.a(
			"Python",
			href="http://www.python.org/"
		)

class cool(xsc.Element):
	empty = False

	def convert(self, converter):
		return html.b(self.content, " is cool!")

class xmlns(xsc.Namespace):
	xmlname = "foo"
	xmlurl = "http://www.foo.net/foo"
xmlns.update(vars())
</prog>
</example>

<par>All defined namespace classes will be registered with the parser automatically,
so all elements belonging to the namespace will be used when parsing files.</par>

<section><title>Namespaces as modules</title>

<par>It is convenient to define all classes that belong to one namespace in one
Python module. However this means that the resulting module will only contain
one <z>interresting</z> object: the namespace class. To make using this class
more convenient, it's possible to turn the namespace class into a module by
using the class method <pyref module="ll.xist.xsc" class="Namespace" method="makemod"><method>makemod</method></pyref>
instead of <method>update</method>:</par>

<example><title>Turning a namespace into a module</title>
<prog>
class python(xsc.Element):
	empty = True

	def convert(self, converter):
		return html.a(
			"Python",
			href="http://www.python.org/"
		)

class cool(xsc.Element):
	empty = False

	def convert(self, converter):
		return html.b(self.content, " is cool!")

class xmlns(xsc.Namespace):
	xmlname = "foo"
	xmlurl = "http://www.foo.net/foo"
xmlns.<em>makemod</em>(vars())
</prog>
</example>

<par>Suppose that the above code is in the file <filename>foo.py</filename>.
Doing an <lit>import foo</lit> will then give you the namespace class instead
of the module:</par>
<prog>
&gt;&gt;&gt; import foo
&gt;&gt;&gt; foo
&lt;foo:xmlns namespace name=u"foo" url=u"http://www.foo.net/foo" \
   with 2 elements from "foo.py" at 0x87654321&gt;
&gt;&gt;&gt; foo.python
&lt;foo:python element at 0x87654321&gt;
</prog>
</section>

<section><title>Subclassing namespaces</title>
<par>Each element class that belongs to a namespace can access its
namespace via the class attribute <lit>xmlns</lit>. When you're subclassing
namespace classes, the elements in the base namespace will be automatically
subclassed too. Of course you can explicitly subclass an element class too.
The following example should show the usefulness of this feature. Define
your base namespace like this and put it into <filename>navns.py</filename>:</par>

<prog>
from ll.xist import xsc
from ll.xist.ns import html

links = [
	("Python", "http://www.python.org/"),
	("Perl", "http://www.perl.org/"),
	("PHP", "http://www.php.net/"),
	("Java", "http://java.sun.com/")
]

class navigation(xsc.Element):
	empty = True

	def convert(self.converter):
		node = self.xmlns.links()
		for (name, url) in links:
			node.append(
				self.xmlns.link(
					name,
					href=url
				)
			)
		return node.convert(converter)

class links(xsc.Element):
	empty = False

	def convert(self, converter):
		node = self.content
		return node.convert(converter)

class link(xsc.Element):
	empty = False
	class Attrs(xsc.Element.Attrs):
		class href(xsc.URLAttr): pass

	def convert(self, converter):
		node = html.div(
			self.content,
			href=self["href"]
		)
		return node.convert(converter)

class xmlns(xsc.Namespace):
	xmlname = "nav"
	xmlurl = "http://www.example.com/nav"
xmlns.makemod(vars())
</prog>

<par>This namespace defines a navigation element that generates <lit>div</lit>s
with links to various homepages for programming languages. We can use it like this:</par>
<prog>
&gt;&gt;&gt; import navns
&gt;&gt;&gt; print navns.nav().conv().asBytes()
&lt;div&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href="http://www.perl.org/"&gt;Perl&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href="http://www.php.net/"&gt;PHP&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href="http://java.sun.com/"&gt;Java&lt;/a&gt;&lt;/div&gt;
</prog>
<par>(Of course the output will all be on one line.)</par>

<par>Now we can define a derived namespace (in the file <filename>nav2ns.py</filename>)
that overwrites the element classes <class>links</class> and <class>link</class>
to change how the navigation looks:</par>

<prog>
import navns

class xmlns(navns):
	class links(nav.links):
		def convert(self, converter):
			node = html.table(
				self.content,
				border=0,
				cellpadding=0,
				cellspacing=0,
				class_="navigation"
			)
			return node.convert(converter)

	class link(nav.link):
		def convert(self, converter):
			node = html.tr(
				html.td(
					html.a(
						self.content,
						href=self["href"]
					)
				)
			)
			return node.convert(converter)
</prog>

<par>When we use the navigation element from the derived namespace we'll get
the following output:</par>

<prog>
&gt;&gt;&gt; import foo
&gt;&gt;&gt; print foo.nav().conv().asBytes()
&lt;table border="0" cellpadding="0" cellspacing="0" class="navigation"&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.perl.org/"&gt;Perl&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.php.net/"&gt;PHP&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://java.sun.com/"&gt;Java&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</prog>
<par>(again all on one line.)</par>

</section>

<section><title>Namespaces as conversion targets</title>

<par>The <arg>converter</arg> argument passed to the <method>convert</method> method
has an attribute <lit>target</lit> which is a namespace class and specifies the target
namespace to which <self/> should be converted.</par>

<par>You can check which conversion is wanted with <function>issubclass</function>.
Once this is determined you can use element classes from the target to create the
required &xml; object tree. This makes it possible to customize the conversion by
passing a derived namespace to the <method>convert</method> method. We have to change
or example namespace from above like this</par>

<prog>
import navns

class xmlns(navns):
	class links(nav.links):
		def convert(self, converter):
			node = converter.target.table(
				self.content,
				border=0,
				cellpadding=0,
				cellspacing=0,
				class_="navigation"
			)
			return node.convert(converter)

	class link(nav.link):
		def convert(self, converter):
			target = converter.target
			node = target.tr(
				target.td(
					target.a(
						self.content,
						href=self["href"]
					)
				)
			)
			return node.convert(converter)
</prog>

<par>What we might want to do is have all links (i.e. all <class>ll.xist.ns.html.a</class>
elements) generated with an attribute <lit>target="_top"</lit>. For this we derive
a new namespace from <class>ll.xist.ns.html</class> and overwrite the <class>a</class>
element:</par>

<prog>
from ll.xist.ns import html

class xmlns(html):
	class a(html.a):
		def convert(self, converter):
			node = html.a(
				self.content,
				self.attr,
				target="_top"
			)
			return node.convert(converter)
</prog>

<par>Now we can pass this namespace as the conversion target and all links
will have a <lit>target="top"</lit>.</par>
</section>

</section>

<section><title>Entities</title>

<par>In the same way as defining new element types, you can define new
entities. But to be able to use the new entities in an &xml; file
you have to use a parser that supports reporting undefined
entities to the application via <method>skippedEntity</method>
(<pyref module="ll.xist.parsers" class="SGMLOPParser"><class>SGMLOPParser</class></pyref>
in the module <pyref module="ll.xist.parsers"><module>ll.xist.parsers</module></pyref> does that).</par>

<par>In addition to the <pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
method you may implement the method
<pyref module="ll.xist.xsc" class="Node" method="__unicode__"><method>__unicode__</method></pyref>,
which must return a unicode string value for the entity. The following
example is from the module <pyref module="ll.xist.ns.abbr"><module>ll.xist.ns.abbr</module></pyref>:</par>

<example><title>Defining new entities</title>
<prog>
from ll.xist import xsc
from ll.xist.ns import html

class xml(xsc.Entity):
	def convert(self, converter):
		return html.abbr(
			"XML",
			title="Extensible Markup Language",
			lang="en"
		)
	def __unicode__(self):
		return u"XML"
</prog>
</example>

<par>Now you can use this new entity in your &xml; files:</par>

<example><title>Using the newly defined entity</title>
<prog>
&lt;cool adj="very"&gt;&amp;xml;&lt;/cool&gt;
</prog>
</example>

</section>

<section><title>Processing instructions</title>
<par>Defining processing instructions works the same way. Derive a
new class from <pyref module="ll.xist.xsc" class="ProcInst"><class>ll.xist.xsc.ProcInst</class></pyref>
and implement <pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>.
The following example implements a processing instruction that returns an uppercase
version of it's content as a text node.</par>

<example><title>Defining new processing instructions</title>
<prog>
class upper(xsc.ProcInst):
	def convert(self, converter):
		return xsc.Text(self.content.upper())
</prog>
</example>

<par>it can be used in an &xml; file as following:</par>

<example><title>Using the newly defined processing instruction</title>
<prog>
&lt;cool&gt;&lt;?upper foo?&gt;&lt;/cool&gt;
</prog>
</example>

</section>

</section>

</section>

<section><title>Publishing &xml; trees</title>

<par>After creating the &xml; tree and converting the tree
into its final output form, you have to write the resulting tree
to a file. This can be done with the publishing &api;. Two methods
that use the publishing &api; are
<pyref module="ll.xist.xsc" class="Node" method="asBytes"><method>asBytes</method></pyref>
and
<pyref module="ll.xist.xsc" class="Node" method="write"><method>write</method></pyref>.
<pyref module="ll.xist.xsc" class="Node" method="asBytes"><method>asBytes</method></pyref>
returns an 8bit &xml; string. You can specify the encoding with the
parameter <arg>encoding</arg> (with <lit>"us-ascii"</lit> being the default).
Unencodable characters will be escaped with character references when possible
(i.e. inside text nodes, for comments or processing instructions you'll get
an exception):</par>

<prog>
&gt;&gt;&gt; from ll.xist import xsc
&gt;&gt;&gt; from ll.xist.ns import html
&gt;&gt;&gt; node = html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ")
&gt;&gt;&gt; print node.asBytes(encoding="ascii")
&lt;div&gt;&amp;#228;&amp;#246;&amp;#252;&lt;br /&gt;&amp;#196;&amp;#214;&amp;#220;&lt;/div&gt;
&gt;&gt;&gt; print node.asBytes(encoding="iso-8859-1")
&lt;div&gt;äöü&lt;br /&gt;ÄÖÜ&lt;/div&gt;
&gt;&gt;&gt; print xsc.Comment(u"äöü").asBytes()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "~/pythonroot/xist/xsc.py", line 828, in asBytes
    return publisher.asBytes()
  File "~/pythonroot/xist/publishers.py", line 162, in asBytes
    return u"".join(self.texts).encode(self.encoding)
UnicodeEncodeError: 'ascii' codec can't encode \
characters in position 0-2: ordinal not in range(128)
</prog>

<par>Another useful parameter is <arg>xhtml</arg>,
it specifies if you want pure &html; or &xhtml; as output:</par>

<dlist>
<term><lit>xhtml==0</lit></term><item>This will give you pure &html;, i.e. no final <lit>/</lit>
for elements with an empty content model, so you'll get e.g. <markup>&lt;br&gt;</markup> in the output.
Elements that don't have an empty content model, but are empty will be published with a start and
end tag (i.e. <markup>&lt;div&gt;&lt;/div&gt;</markup>).</item>
<term><lit>xhtml==1</lit></term><item>This gives &html; compatible &xhtml;. Elements with an empty content
model will be published like this: <markup>&lt;br /&gt;</markup>.</item>
<term><lit>xhtml==2</lit></term><item>This gives full &xml; output. Every empty element will be published with
an empty tag (without an additional space): <markup>&lt;br/&gt;</markup> or <markup>&lt;div/&gt;</markup>.</item>
</dlist>
<par>Writing a node to a file can be done with the method
<pyref module="ll.xist.xsc" class="Node" method="write"><method>write</method></pyref>:</par>
<prog>
&gt;&gt;&gt; from ll.xist.ns import html
&gt;&gt;&gt; node = html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ"
)
&gt;&gt;&gt; node.write(
...    open("foo.html", "wb"),
...    encoding="ascii"
)
</prog>

<par>All these methods use the method
<pyref module="ll.xist.xsc" class="Node" method="publish"><method>publish</method></pyref> internally.
<pyref module="ll.xist.xsc" class="Node" method="publish"><method>publish</method></pyref> gets passed
an instance of <pyref module="ll.xist.publishers" class="Publisher"><class>ll.xist.publisher.Publisher</class></pyref>.</par>
</section>


<section><title>Searching trees</title>

<par>Finding nodes in a tree can be done with the method
<pyref module="ll.xist.xsc" class="Node" method="find"><method>find</method></pyref>.
<pyref module="ll.xist.xsc" class="Node" method="find"><method>find</method></pyref> will return
a <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref> with the nodes it finds.
You pass a callable object to <method>find</method> which is used for determining which part of the
tree should be searched and which nodes should be returned.</par>
<par><module>ll.xist.xsc</module> provided several useful predefined classes for that.
<pyref module="ll.xist.xsc" class="FindType"><class>FindType</class></pyref> will search only
the first level of the tree and will return any node that is an instance of one of the classes
passed to the constructor. So if you have an instance of <class>ll.xist.ns.html.ul</class>
named <lit>node</lit> you could search for all <class>ll.xist.ns.li</class> elements inside
with the following code:</par>

<example><title>Searching for <class>li</class> inside <class>ul</class></title>
<prog>
node.content.find(xsc.FindType(html.li))
</prog>
</example>

<par><pyref module="ll.xist.xsc" class="FindTypeAll"><class>FindTypeAll</class></pyref>
can be used when you want to search the complete tree. The following example extracts
all the links on the <link href="http://www.python.org/">Python home page</link>:</par>

<example><title>Finding all links on the Python home page</title>
<prog>
from ll.xist import xsc, parsers
from ll.xist.ns import html, chars

node = parsers.parseURL(
	"http://www.python.org/",
	encoding="latin1",
	tidy=True)

links = node.find(xsc.FindTypeAll(html.a))

for link in links:
	print link["href"]
</prog>
</example>

<par>This gives the output:</par>

<prog>
http://www.python.org/
http://www.python.org/search/
http://www.python.org/download/
http://www.python.org/doc/
http://www.python.org/Help.html
http://www.python.org/dev/
...
</prog>

<par>The following example will find all external links on the Python home page:</par>

<example><title>Finding external links on the Python home page</title>
<prog>
from ll.xist import xsc, parsers
from ll.xist.ns import html, chars

node = parsers.parseURL(
	"http://www.python.org/",
	encoding="latin1",
	tidy=True)

def isextlink(node):
	if isinstance(node, html.a) \
		and not unicode(node["href"]).startswith("http://www.python.org"):
		return (True, xsc.entercontent)
	return (xsc.entercontent,)

links = node.find(isextlink)

for link in links:
	print link["href"]
</prog>
</example>

<par>This gives the output:</par>

<prog>
http://www.jython.org/
http://sourceforge.net/tracker/?atid=105470&amp;group%5fid=5470
http://sourceforge.net/tracker/?atid=305470&amp;group%5fid=5470
http://sourceforge.net/cvs/?group%5fid=5470
http://www.python-in-business.org/
http://www.europython.org/
mailto:webmaster@python.org
...
</prog>

<par>The callable (<function>isextlink</function> in the example) will be called
for each node and must return a sequence with the following entries:</par>

<dlist>
<term><lit>ll.xist.xsc.entercontent</lit></term><item>enter the content of this element
and continue searching;</item>
<term><lit>ll.xist.xsc.enterattrs</lit></term><item>enter the attributes of this element
and continue searching;</item>
<term>boolean value</term><item>If true, the node will be part of the resulting fragment.</item>
</dlist>

<par>The sequence will be <z>executed</z> in the order you specify. To change
the top down traversal from our example to a bottom up traversal we could change
<function>isextlink</function> to (note the swapped tuple entries):</par>

<example><title>Bottom up link traversal function</title>
<prog>
def isextlink(node):
	if isinstance(node, html.a) \
		and not unicode(node["href"]).startswith("http://www.python.org"):
		return <em>(xsc.entercontent, True)</em>
	return (xsc.entercontent,)
</prog>
</example>

</section>


<section><title>Manipulating trees</title>
<par>&xist; provides many methods for manipulating an
&xml; tree.</par>

<par>The method <pyref module="ll.xist.xsc" class="Node" method="withsep"><method>withsep</method></pyref>
can be used to put a seperator node between the child nodes of an
<pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or a <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</par>

<prog>
&gt;&gt;&gt; from ll.xist import xsc
&gt;&gt;&gt; from ll.xist.ns import html
&gt;&gt;&gt; node = html.div(*xrange(10))
&gt;&gt;&gt; print node. \
...    withsep(", "). \
...    asBytes()
&lt;div&gt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&lt;/div&gt;
</prog>

<par>The method <pyref module="ll.xist.xsc" class="Node" method="shuffled"><method>shuffled</method></pyref>
returns a shuffled version of the <pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</par>

<prog>
&gt;&gt;&gt; from ll.xist import xsc
&gt;&gt;&gt; from ll.xist.ns import html
&gt;&gt;&gt; node = html.div(*xrange(10))
&gt;&gt;&gt; print node. \
...    shuffled(). \
...    withsep(", "). \
...    asBytes()
&lt;div&gt;8, 1, 3, 6, 7, 5, 2, 9, 4, 0&lt;/div&gt;
&gt;&gt;&gt; print node. \
...    withsep(", "). \
...    shuffled(). \
...    asBytes()
&lt;div&gt;31, 8905, 7, , , 4, 6, , , 2&lt;/div&gt;
</prog>

<par>There are methods named <pyref module="ll.xist.xsc" class="Node" method="reversed"><method>reversed</method></pyref>
and <pyref module="ll.xist.xsc" class="Node" method="sorted"><method>sorted</method></pyref>, that
return a reversed or sorted version of an element or fragment:</par>

<prog>
&gt;&gt;&gt; from ll.xist import xsc
&gt;&gt;&gt; from ll.xist.ns import html
&gt;&gt;&gt; def sort(n1, n1):
...    return cmp(unicode(n1), uncode(n2))
&gt;&gt;&gt; node = html.div(8,4,2,1,9,6,3,0,7,5)
&gt;&gt;&gt; print node.sorted(sort). \
...    reversed().withsep(",").asBytes()
&lt;div&gt;9,8,7,6,5,4,3,2,1,0&lt;/div&gt;
</prog>

<par>The method <pyref module="ll.xist.xsc" class="Node" method="mapped"><method>mapped</method></pyref>
recursively walks the tree and generates a new tree, where all the nodes are mapped
through a function. An example: To replace <lit>Python</lit> with <lit>Parrot</lit>
in every text node on the <link href="http://www.python.org/">Python page</link>, do the following:</par>

<prog>
from ll.xist import xsc, parsers, converters
from ll.xist.ns import html

def p2p(node):
	if isinstance(node, xsc.Text):
		node = node.replace("Python", "Parrot")
		node = node.replace("python", "parrot")
	return node

node = parsers.parseURL(
	"http://www.python.org/",
	encoding="iso-8859-1",
	tidy=True)

node.mapped(p2p, converters.Converter()).write(
	open("parrot_index.html", "wb"))
</prog>

<par>The function must either return a new node, in which case this
new node will be used instead of the old one, or return the
old node to tell <pyref module="ll.xist.xsc" class="Node" method="mapped"><method>mapped</method></pyref>
that it should recursively continue with the content of the node.</par>
</section>

<section><title>&url;s</title>

<par>For &url; handling &xist; uses the module
<pyref module="ll.url"><module>ll.url</module></pyref>. Refer to its documentation
for the basic functionality (especially regarding the methods
<pyref module="ll.url" class="URL" method="__div__"><method>__div__</method></pyref>
and <pyref module="ll.url" class="URL" method="relative"><method>relative</method></pyref>).</par>

<par>When &xist; parses an &xml; resource it uses a so called <z>base</z> &url;.
This base &url; can be passed to all parsing functions. If it isn't specified
it defaults to the &url; of the resource being parsed. This base &url; will
be prepended to all &url;s that are read during parsing:</par>
<prog>
&gt;&gt;&gt; from ll.xist import parsers
&gt;&gt;&gt; from ll.xist.ns import html
&gt;&gt;&gt; node = parsers.parseString( \
...   '&lt;img src="eggs.png"/&gt;', \
...   base="root:spam/index.html")
&gt;&gt;&gt; print node.asBytes()
&lt;img src="root:spam/eggs.png" /&gt;
</prog>

<par>For publishing a base &url; can be specified too. &url;s will be published
relative to this base &url; with the exception of relative &url;s in the tree.
This means:</par>
<ulist>
<item>When you have a relative &url; (e.g. <lit>#top</lit>) generated by a <method>convert</method>
call, this &url; will stay the same when publishing.</item>
<item>Base &url;s for parsing should never be relative: Relative base
&url;s will be prepended to all relative &url;s in the file, but this will not be
reverted for publishing. In most cases the base &url; should be a
<lit>root</lit> &url; when you parse local files.</item>
<item>When you parse remote web pages you can either
omit the <arg>base</arg> argument, so it will default to the
&url; being parsing, so that links, images, etc. on the page
will still point back to their original location, or you
might want to use the empty &url; <lit>URL()</lit> as the
base, so you'll get all &url; in the page as they are.</item>
<item><par>When &xist; is used as a compiler for static pages, you're
going to read source &xml; files, do a conversion and write the
result to a new target file. In this case you should probably
use the &url; of the target file for both parsing and
publishing. Let's assume we have an &url; <lit>#top</lit>
in the source file. When we use the <z>real</z> file names
for parsing and publishing like this:</par>
<prog>
node = parsers.parseFile(
	"spam.htmlxsc",
	base="root:spam.htmlxsc"
)
node = node.conv()
node.write(
	open("spam.html", "wb"),
	base="root:spam.html"
)
</prog>
<par>the following will happen: The &url; <lit>#top</lit>
will be parsed as <lit>root:spam.htmlxsc#top</lit>. After
conversion this will be written to <filename>spam.html</filename>
relative to the &url; <lit>root:spam.html</lit>, which results
in <lit>spam.html#top</lit>, which works, but is not what you
want.</par>
<par>When you use <lit>root:spam.html</lit> both for parsing
and publishing, <lit>#top</lit> will be written to the target file
as expected.</par></item>
</ulist>

</section>

<section><title>Automatic generation of image size attributes</title>

<par>The module <pyref module="ll.xist.ns.htmlspecials"><module>ll.xist.ns.htmlspecials</module></pyref>
contains an element <pyref module="ll.xist.ns.htmlspecials" class="autoimg"><class>autoimg</class></pyref>
that extends <pyref module="ll.xist.ns.html" class="img"><class>ll.xist.ns.html.img</class></pyref>.
When converted to &html; via the <pyref module="ll.xist.ns" class="Node" method="convert"><method>convert</method></pyref>
method the size of the image will be determined and the <lit>height</lit>
and <lit>width</lit> attributes will be set accordingly, if those attributes
are not set already.</par>

</section>

<section><title>Embedding Python code</title>
<par>It's possible to embed Python code into &xist; &xml; files. For this
&xist; supports two new processing instructions:
<pyref module="ll.xist.ns.code" class="pyexec"><lit>pyexec</lit></pyref>
and <pyref module="ll.xist.ns.code" class="pyeval"><lit>pyeval</lit></pyref> (in the module
<pyref module="ll.xist.ns.code"><module>ll.xist.ns.code</module></pyref>. The content of
<pyref module="ll.xist.ns.code" class="pyexec"><lit>pyexec</lit></pyref> will be
executed when the processing instruction node is instantiated, i.e. when the
&xml; file is parsed, so anything you do there will be available afterwards.</par>

<par>The result of a call to <pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
for a <pyref module="ll.xist.ns.code" class="pyeval"><lit>pyeval</lit></pyref> processing instruction is whatever the
Python code in the content returns. The processing instruction content is treated as the body
of a function, so you can put multiple return statements there.
The converter is available as the parameter <arg>converter</arg> inside
the processing instruction. For example, consider the following &xml; file:</par>

<prog>
&lt;?pyexec
	# sum
	def gauss(top=100):
		sum = 0
		for i in xrange(top+1):
			sum += i
		return sum
?&gt;
&lt;b&gt;&lt;?pyeval return gauss()?&gt;&lt;/b&gt;
</prog>

<par>Parsing this file and calling
<pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
results in the following:</par>

<prog>
&lt;b&gt;5050&lt;/b&gt;
</prog>

</section>
