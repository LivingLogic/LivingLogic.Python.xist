<?xml version='1.0' encoding='iso-8859-1'?>
<doc:par>&xist; is an &xml;-based extensible &html; generator written in Python.
It was developed as a replacement for an &html; preprocessor named
<a href="http://www.giga.or.at/~agi/hsc/">HSC</a>, and borrows some
features and ideas from it. It also borrows the basic ideas (&xml;/&html;
elements as Python objects) from 
<a href="http://starship.python.net/crew/friedrich/HTMLgen/html/main.html">HTMLgen</a> 
or <a href="http://dustman.net/andy/python/HyperText/">HyperText</a>.</doc:par>

<doc:section><doc:title>Overview</doc:title>
<doc:par>&xist; can be used as a compiler that reads an input file
and generates a transformed output file, or it could be used for generating
&xml; dynamically inside a web server. In either case generating the final
&html; or &xml; output in the form of a file or a response sent from
the web server, requires the following three steps:</doc:par>
<ulist>
<item>Generating a source &xml; tree: This can be done either by
parsing an &xml; file, or by directly constructing the
tree, as <app>HTMLgen</app> and <app>HyperText</app>
do, as a tree of Python objects. &xist; provides a very natural
and pythonic &api; for that.</item>
<item>Converting the source tree into a target tree: This target
tree can be a &html; tree or a &wml; tree or any other
&xml; tree you like. Every node class provides a
<function>convert</function> method for performing the conversion. For
your own &xml; element types you have to define your
own element classes and implement an appropriate
<function>convert</function> method.</item>
<item>Publishing the target tree: For writing the final
output to a file or generating a string that can
be delivered as a response from a web server, all node classes
provide a <function>publish</function> method, that
passes the string fragments to a appropriate publishing handler.</item>
</ulist>
</doc:section>

<doc:section><doc:title>Constructing &xml; trees</doc:title>
<doc:par>Like any other &dom; &api;, &xist; provides the 
usual classes:</doc:par>
<ulist>
<item><doc:pyref module="xist.xsc" class="Text">Text</doc:pyref> for text data</item>
<item><doc:pyref module="xist.xsc" class="Frag">Frag</doc:pyref> for document fragments,
a <doc:pyref module="xist.xsc" class="Frag">Frag</doc:pyref> object is simply a list
of nodes,</item>
<item><doc:pyref module="xist.xsc" class="Comment">Comment</doc:pyref> for &xml; comments
(e.g. <markup>&lt;!-- the comment --&gt;</markup>)</item>
<item><doc:pyref module="xist.xsc" class="DocType">DocType</doc:pyref> for document type
declarations (e.g. <markup>&lt;!DOCTYPE html PUBLIC <replaceable>...</replaceable>&gt;</markup>),</item>
<item><doc:pyref module="xist.xsc" class="ProcInst">ProcInst</doc:pyref> for processing instructions
(e.g. <markup>&lt;?php echo $spam;?&gt;</markup>,</item>
<item><doc:pyref module="xist.xsc" class="Element">Element</doc:pyref> for &xml; elements,</item>
<item><doc:pyref module="xist.xsc" class="Entity">Entity</doc:pyref> for entities (e.g. <markup>&amp;parrot;</markup>) and</item>
<item><doc:pyref module="xist.xsc" class="Attr">Attr</doc:pyref> for attributes.</item>
</ulist>

<doc:section><doc:title>&xml; trees as Python objects</doc:title>
<doc:par>&xist; works somewhat different from a normal &dom; &api;.
Instead of only one element class, &xist; has one class for every element
type. All the elements known to &xist; are defined in modules in
the <doc:pyref module="xist.ns">xist.ns</doc:pyref> subpackage. The definition of &html; can 
be found in <doc:pyref module="xist.ns.html">xist.ns.html</doc:pyref> for example.</doc:par>

<doc:par>Every element class has a constructor of the form
<doc:programlisting>
__init__(self, *content, **attrs)
</doc:programlisting>
Positional arguments (i.e. items in <parameter>content</parameter>)
will be the child nodes of the element node. Keyword arguments
will be attributes. You can pass most builtin types to such a constructor.
Strings and integers will be automatically converted to
<pyref module="xist.xsc" class="Text">Text</pyref> objects.
So constructing an &html; element works like this:
<doc:example title="The first example">
<doc:programlisting>
from xist.ns import html

node = html.div(
	"Hello ",
	html.a("Python", href="http://www.python.org/"),
	" world!"
)
</doc:programlisting>
</doc:example>
</doc:par>

<doc:par>For attribute names that collide with Python keywords
(most notably <markup>class</markup>) you can append an underscore to the
name:
<doc:example title="Colliding attribute names">
<doc:programlisting>
node = html.div(
	"Hello world!",
	class_="greeting"
)
</doc:programlisting>
</doc:example>
One trailing underscore will be stripped off of an attribute name in the
element constructor.
</doc:par>
</doc:section>

<doc:section><doc:title>Generating &xml; trees from &xml; files</doc:title>
<doc:par>Of course &xml; trees can also be generated by parsing
&xml; files. For this the module <doc:pyref module="xist.parsers">xist.parsers</doc:pyref>
provides four functions:
<doc:programlisting>
parseString(text, parser=None,
	namespaces=None, defaultEncoding="utf-8")
parseFile(filename, parser=None,
	namespaces=None, defaultEncoding="utf-8")
parseURL(url, parser=None,
	namespaces=None, defaultEncoding="utf-8")
parseTidyURL(url, parser=None,
	namespaces=None, defaultEncoding="utf-8")
</doc:programlisting>
<doc:pyref module="xist.parsers" function="parseString">parseString</doc:pyref> is for parsing strings 
(8bit and Unicode), <doc:pyref module="xist.parsers" function="parseFile">parseFile</doc:pyref> for 
parsing files. <doc:pyref module="xist.parsers" function="parseURL">parseURL</doc:pyref> allows to 
parse remote files via <pyref module="urllib">urllib</pyref> and 
<doc:pyref module="xist.parsers" function="parseTidyURL">parseTidyURL</doc:pyref> pipes remote files 
through <app>tidy</app> before parsing the result. The argument 
<doc:pyref module="xist.parsers" function="parseString" arg="parser">parser</doc:pyref>
specifies the parser to be used. Any SAX2 parser can be used. &xist; provides a
SAX2 parser for <app>sgmlop</app> named 
<doc:pyref module="xist.parsers" class="SGMLOPParser">SGMLOPParser</doc:pyref> (which
is the default if no argument is given) and an &html; parser named
<doc:pyref module="xist.parsers" class="HTMLParser">HTMLParser</doc:pyref>, that
tries to make sense of &html; sources.</doc:par>

<doc:par>All four functions call
<doc:pyref module="xist.parsers" function="parse">parse(source, parser=None, namespaces=None)</doc:pyref>
internally and pass an appropriate <doc:pyref module="xist.parsers" function="parse" arg="source">source</doc:pyref> argument,
which is a standard &sax; <doc:pyref module="xml.sax.xmlreader" class="InputSource">InputSource</doc:pyref>
object, so it's possible to extend the parsing machinery for different data sources.</doc:par>
</doc:section>
</doc:section>

<doc:section><doc:title>Defining new elements, converting &xml; trees</doc:title>
<doc:par>To be able to parse an &xml; file, you have to provide an element class
for every element type that appears in the file. Defining an element class
for an element named <code>cool</code> works like this:
<doc:example title="Defining a new element">
<doc:programlisting>
class cool(xsc.Element):
	empty = 0

	def convert(self, converter):
		node = html.b(self.content, " is cool!")
		return node.convert(converter)
</doc:programlisting>
</doc:example>
You have to derive your new class from <pyref module="xist.xsc" class="Element">xsc.Element</pyref>.
The name of the class will be the element name. For element type names that are no valid Python
identifiers, you can use the class attribute <code>name</code> in the element class the overwrite
the element name.</doc:par>
<doc:par>To be able to convert an element of this type to a new &xml; tree (&html; in most cases),
you have to implement the <pyref module="xist.xsc" class="Node" method="convert">convert</pyref>
method. In this method you can build a new &xml; tree from the content and attributes
of the object.</doc:par>

<doc:par>Using this new element is simple
<doc:example title="Using the new element">
<doc:programlisting>
&gt;&gt;&gt; node = cool("Python")
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;Python is cool!&lt;/b&gt;
</doc:programlisting>
</doc:example>
(<doc:pyref module="xist.xsc" class="Node" method="conv">conv</doc:pyref> simply
calls
<doc:pyref module="xist.xsc" class="Node" method="convert">convert</doc:pyref>
with a default <doc:pyref module="xist.cnverters" class="Converter">converter</doc:pyref>
argument. We'll come to converters in a minute. 
<doc:pyref module="xist.xsc" class="Node" method="asBytes">asBytes</doc:pyref>
is a method that converts the node to a string. This method will be explained
when we discuss the publishing interface.)
</doc:par>

<doc:par>Note that it is vital for your own <pyref method="convert">convert</pyref>
methods that you recursively call
<pyref module="xist.xsc" class="Node" method="convert">convert</pyref>
on you own content, because otherwise some unconverted nodes
might remain in the tree. Lets define a new element:
<doc:programlisting>
class python(xsc.Element):
	empty = 1

	def convert(self, converter):
		return html.a("Python", href="http://www.python.org/")
</doc:programlisting>
Now we can do the following:
<doc:programlisting>
&gt;&gt;&gt; node = cool(python())
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is cool!&lt;/b&gt;
</doc:programlisting>
But if we forget to call
<pyref module="xist.xsc" class="Node" method="convert">convert</pyref>
for our own content, i.e. if the element <pyref class="cool">cool</pyref> 
was written like this:
<doc:programlisting>
class cool(xsc.Element):
	empty = 0

	def convert(self, converter):
		return html.b(self.content, " is cool!")
</doc:programlisting>
we would get:
<doc:programlisting>
&gt;&gt;&gt; node = cool(python())
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;&lt;python /&gt; is cool!&lt;/b&gt;
</doc:programlisting>
</doc:par>

<doc:section><doc:title>Converters</doc:title>
<doc:par><doc:pyref module="xist.xsc" class="Node" method="conv">conv</doc:pyref> is a convenience
method that creates a default converter for you and calls
<doc:pyref module="xist.xsc" class="Node" method="convert">convert</doc:pyref>.
You could also call <doc:pyref module="xist.xsc" class="Node" method="convert">convert</doc:pyref> yourself,
which would look like this:
<doc:programlisting>
from xist import converters

node = cool(python())
node = node.convert(
	converters.Converter(None, "deliver", "html", None))
</doc:programlisting>
You can pass the following four arguments to the
<doc:pyref module="xist.converters" class="Converter">Converter</doc:pyref> constructor</doc:par>
<ulist>
<item><doc:pyref module="xist.converters" class="Converter" method="__init__" arg="mode">mode</doc:pyref>
(which defaults to <code>None</code>) works the same way as modes in &xslt;. You can use this
for implementing different conversion modes.</item>
<item><doc:pyref module="xist.converters" class="Converter" method="__init__" arg="stage">stage</doc:pyref>
(which defaults to <code>"deliver"</code>) allows you to implement multi stage conversion:
Suppose that you want to deliver a dynamically constructed web page with &xist; that contains
results from a database query and the current time. The data in the database changes
infrequently, so it doesn't make sense to do the query on every request. The query is done
every few minutes and the resulting &html; tree is stored in the servlet
(using any of the available Python servlet technologies). For this conversion the
<doc:pyref module="xist.converters" class="Converter" method="__init__" arg="stage">stage</doc:pyref>
would be <code>"cache"</code> and your database &xml; element would do the
query when <code><doc:pyref module="xist.converters" class="Converter" method="__init__" arg="stage">stage</doc:pyref>=="cache"</code>.
Your time display element would do the conversion when
<code><doc:pyref module="xist.converters" class="Converter" method="__init__" arg="stage">stage</doc:pyref>=="deliver"</code>
and simply returns itself when 
<code><doc:pyref module="xist.converters" class="Converter" method="__init__" arg="stage">stage</doc:pyref>=="cache"</code>,
so it would still be part of the cached &xml; tree and would be converted to &html; on every request.</item>
<item><doc:pyref module="xist.converters" class="Converter" method="__init__" arg="target">target</doc:pyref>
(which defaults to <code>html</code>) specifies what the output should be. Values could
e.g. be <code>"html"</code>, <code>"wml"</code> or <code>"docbook"</code>.</item>
<item><doc:pyref module="xist.converters" class="Converter" method="__init__" arg="lang">lang</doc:pyref>
(which defaults to <code>None</code>) the language in which the result tree should be.
This can be used in the <pyref method="convert">convert</pyref> method
to implement different conversions for different languages, e.g.:
<doc:programlisting>
class note(xsc.Element):
	empty = 0

	def convert(self, converter):
		if converter.lang=="de":
			title = "Anmerkung"
		elif converter.lang=="ja":
			title = u"???"
		elif converter.lang=="fr":
			title = "???"
		else:
			title = "Note"
		return xsc.Frag(
			html.h1(title),
			html.div(self.content.convert(converter)))
</doc:programlisting>
and you can test for the language with the element
<pyref module="xist.ns.cond" class="If">xist.ns.cond.If</pyref>, e.g.:
<doc:programlisting>
&lt;if lang="de"&gt;Anmerkung
&lt;elif lang="ja"&gt;???
&lt;elif lang="fr"&gt;???
&lt;else&gt;Note
&lt;if&gt;
</doc:programlisting>
</item>
</ulist>
</doc:section>

<doc:section><doc:title>Attributes</doc:title>
<doc:par>Setting and accessing the attributes of an element work via
the dictionary interface. So if <code>node</code>
is an <pyref module="xist.xsc" class="Element">Element</pyref> that supports the
attribute <code>spam</code> the following can be
done:
<doc:example title="Working with attributes">
<doc:programlisting>
if node.hasAttr("spam"):
	del node["spam"]
else:
	node["spam"] = "eggs"
node["spam"].append("ham")
</doc:programlisting>
</doc:example>
</doc:par>
<doc:par>All attribute values are instances of subclasses of
the class <pyref module="xist.xsc" class="Attr">Attr</pyref>. Available
subclasses are:</doc:par>
<ulist>
<item><pyref module="xist.xsc" class="TextAttr">TextAttr</pyref>, for normal text attributes;</item>
<item><pyref module="xist.xsc" class="URLAttr">URLAttr</pyref>, for attributes that are URLs;</item>
<item><pyref module="xist.xsc" class="BoolAttr">BoolAttr</pyref>, for boolean attributes (such an attribute
is either present or not, but it's value will be ignored);</item>
<item><pyref module="xist.xsc" class="IntAttr">IntAttr</pyref>, for integer attributes;</item>
<item><pyref module="xist.xsc" class="ColorAttr">ColorAttr</pyref>, for color attributes (e.g. <code>#ffffff</code>)</item>
</ulist>
<doc:par><pyref module="xist.xsc" class="Attr">Attr</pyref> itself is derived from
<pyref module="xist.xsc" class="Frag">Frag</pyref> so it is possible
to use all the sequence methods on an attribute. Unset attributes will be treated
like empty ones so the following is possible:
<doc:example>
<doc:programlisting>
del node["spam"]
node["spam"].append("ham")
</doc:programlisting>
</doc:example>
this also means that after
<doc:example>
<doc:programlisting>
del node["spam"][0]
</doc:programlisting>
</doc:example>
the attribute will be empty again and will be considered to be unset.
Such attributes will be ignored when publishing.
</doc:par>
</doc:section>

<doc:section><doc:title>Specifying content model and attributes</doc:title>
<doc:par>When you define a new element you have to specify two things:</doc:par>

<olist>
<item>If the element has an empty content model (like <markup>&lt;br/&gt;</markup>
or <markup>&lt;img/&gt;</markup> do in &html;) or not.</item>
<item>what attributes the element supports and of which type they are.</item>
</olist>

<doc:par>Specifying the content model is done with the class attribute <code>empty</code>.
Set it to <code>0</code>, when your element may have content and to <code>1</code>
if it may not.</doc:par>

<doc:par>To specify the attributes for the element, use the class
attribute <pyref>attrHandlers</pyref>, which must be a dictionary
mapping attribute names to attribute classes. We could extend our
example element in the following way:
<doc:example title="Using attributes">
<doc:programlisting>
class cool(xsc.Element):
	empty = 0
	attrHandlers = {"adj": xsc.TextAttr}

	def convert(self, converter):
		node = xsc.Frag(self.content, " is")
		if self.hasAttr("adj"):
			node.append(" ", html.em(self["adj"]))
		node.append(" cool!")
		return node.convert(converter)
</doc:programlisting>
</doc:example>
and use it like this
<doc:programlisting>
&gt;&gt;&gt; node = cool(python(), adj="totally")
&gt;&gt;&gt; print node.conv().asBytes()
&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is &lt;em&gt;totally&lt;/em&gt; cool!
</doc:programlisting>
</doc:par>
</doc:section>

<doc:section><doc:title>Namespace objects</doc:title>
<doc:par>Now that you've defined your own elements, you have to
tell the parser about them, so they can be instantiated when
a file is parsed. This is done with namespace objects. At the end
of your Python module after all the classes are defined, create a
namespace object that collects all the class objects from the
local scope:
<doc:example>
<doc:programlisting>
namespace = xsc.Namespace(
	"foo",
	"http://www.foo.net/DTDs/foo.dtd",
	vars()
)
</doc:programlisting>
</doc:example>
Arguments for the <pyref module="xist.xsc" class="Namespace">Namespace</pyref>
constructor are:</doc:par>
<ulist>
<item><pyref module="xist.xsc" class="Namespace" method="__init__" arg="prefix">prefix</pyref> is
the namespace prefix that can be used to disambiguate elements in different namespaces
with the same name.</item>
<item><pyref module="xist.xsc" class="Namespace" method="__init__" arg="uri">uri</pyref> is the
namespace URL for the namespace. This is currently unused. &xist; doesn't have real
namespace support where namespace prefixes can be bound to namespace URLs dynamically,
but uses fixed prefixes.</item>
<item><pyref module="xist.xsc" class="Namespace" method="__init__" arg="thing">thing</pyref> is
the object that should be registered in the namespace. To register all the element
classes (and entities and processing instruction classes) defined in the module, simply
use <code>vars()</code>.</item>
</ulist>

<doc:par>All namespace objects will automatically be registered with the
parser. Now all newly defined elements will be used when parsing
files.</doc:par>
</doc:section>

<doc:section><doc:title>Entities and processing instructions</doc:title>
<doc:par>In the same way as defining new element types, you can define new
entities and processing instructions. But to be able to use the new entities
in an &xml; file you have to use a parser that supports reporting undefined
entities to the application via <pyref method="skippedEntity">skippedEntity</pyref>
(<pyref module="xist.parsers" class="SGMLOPParser">SGMLOPParser</pyref> in the
module <pyref module="xist.parsers">xist.parsers</pyref> does that).</doc:par>
<doc:par>In addition to the <pyref module="xist.xsc" class="Node" method="convert">convert</pyref>
method you have to implement the method
<pyref module="xist.xsc" class="Node" method="asPlainString">asPlainString</pyref>,
which must return a unicode string value for the entity. The following
example is from the module <pyref module="xist.ns.abbr">xist.ns.abbr</pyref>:
<doc:example title="Defining new entities">
<doc:programlisting>
from xist import xsc
from xist.ns import html

class xml(xsc.Entity):
	def convert(self, converter):
		return html.abbr(
			"XML",
			title="Extensible Markup Language",
			lang="en")
	def asPlainString(self):
		return u"XML"
</doc:programlisting>
</doc:example>
Now you can use this new entity in your &xml; files:
<doc:programlisting>
&lt;cool adj="very"&gt;&amp;xml;&lt;/cool&gt;
</doc:programlisting>
</doc:par>
<doc:par>Defining processing instructions works the same way. Derive a
new class from <pyref module="xist.xsc" class="ProcInst">xist.xsc.ProcInst</pyref>
and implement <pyref module="xist.xsc" class="Node" method="convert">convert</pyref>.
The following example implements a processing instruction that returns an uppercase
version of it's content as a text node.
<doc:example title="Defining new processing instructions">
<doc:programlisting>
class upper(xsc.ProcInst):
	def convert(self, converter):
		return xsc.Text(self.content.upper())
</doc:programlisting>
</doc:example>
it can be used in an &xml; file as following:
<doc:programlisting>
&lt;?upper foo?&gt;
</doc:programlisting>
</doc:par>
</doc:section>
</doc:section>

<doc:section><doc:title>Publishing &xml; trees</doc:title>
<doc:par>After creating the &xml; tree and converting the tree
into its final output form, you have to write the resulting tree
into a file. This can be done with the publishing &api;. Two methods
that use the publishing &api; are
<pyref module="xist.xsc" class="Node" method="asBytes">asBytes</pyref>
and
<pyref module="xist.xsc" class="Node" method="write">write</pyref>.
<pyref module="xist.xsc" class="Node" method="asBytes">asBytes</pyref>
returns an 8bit &xml; string. You can specify the encoding with the
parameter <pyref module="xist.xsc" class="Node" method="asBytes" arg="encoding">encoding</pyref>
(with <code>"us-ascii"</code> being the default).
Unencodable characters will be escaped with numeric character references when possible
(i.e. inside text nodes, for comments or processing instructions you'll get
an exception):
<doc:programlisting>
&gt;&gt;&gt; from xist.ns import xsc, html
&gt;&gt;&gt; print html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ").asBytes(encoding="ascii")
&lt;div&gt;&amp;#228;&amp;#246;&amp;#252;&lt;br /&gt;&amp;#196;&amp;#214;&amp;#220;&lt;/div&gt;
&gt;&gt;&gt; print html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ").asBytes(encoding="iso-8859-1")
&lt;div&gt;äöü&lt;br /&gt;ÄÖÜ&lt;/div&gt;
&gt;&gt;&gt; print xsc.Comment(u"äöü").asBytes()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "~/pythonroot/xist/xsc.py", line 828, in asBytes
    return publisher.asBytes()
  File "~/pythonroot/xist/publishers.py", line 162, in asBytes
    return u"".join(self.texts).encode(self.encoding)
UnicodeError: ASCII encoding error: ordinal not in range(128)
</doc:programlisting>
</doc:par>
<doc:par>Another useful parameter is
<pyref module="xist.xsc" class="Node" method="asBytes" arg="XHTML">XHTML</pyref>,
it specifies if you want pure &html; or &xhtml; as output:</doc:par>
<ulist>
<item><code>XHTML==0</code> will give you pure &html;, i.e. no final <markup>/</markup>
for elements with an empty content model, so you'll get e.g. <markup>&lt;br&gt;</markup> in the output.
Elements that have no empty content model, but are empty will be published with a start and
end tag (i.e. <markup>&lt;div&gt;&lt;/div&gt;</markup>).</item>
<item><code>XHTML==1</code> gives &html; compatible &xhtml;. Elements with empty content
model will be published like this: <markup>&lt;br /&gt;</markup>.</item>
<item><code>XHTML==2</code> gives full &xml; output. Every empty element will be published with
an empty tag (without an additional space): <markup>&lt;br/&gt;</markup> or <markup>&lt;div/&gt;</markup>.</item>
</ulist>
<doc:par>Writing a node to a file can be done with the method
<pyref module="xist.xsc" class="Node" method="write">write</pyref>:
<doc:programlisting>
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ").write(open("foo.html", "wb"), encoding="ascii")
</doc:programlisting>
</doc:par>
<doc:par>All these methods use the method 
<pyref module="xist.xsc" class="Node" method="publish">publish</pyref> internally.
<pyref module="xist.xsc" class="Node" method="publish">publish</pyref> gets passed
an instance of <pyref module="xist.publishers" class="Publisher">xist.publisher.Publisher</pyref>
(or one of it's subclasses). All strings generated will be sent to the
<pyref module="xist.publishers" class="Publisher" method="publish">publish</pyref> method
of the publisher. <pyref module="xist.xsc" class="Node" method="write">write</pyref>
uses <pyref module="xist.publishers" class="FilePublisher">FilePublisher</pyref>
and
<pyref module="xist.xsc" class="Node" method="asBytes">asBytes</pyref>
uses <pyref module="xist.publishers" class="BytePublisher">BytePublisher</pyref>.
For example <pyref module="xist.publishers" class="FilePublisher">FilePublisher</pyref>
looks like this:
<doc:programlisting>
class FilePublisher(Publisher):
	def __init__(self, file, base=None, encoding=None, XHTML=None,
			publishPrefix=0):
		Publisher.__init__(self, base=base, encoding=encoding,
			XHTML=XHTML, publishPrefix=publishPrefix)
		(encode, decode, streamReaderClass,
			streamWriterClass) = codecs.lookup(self.encoding)
		self.file = streamWriterClass(file)

	def publish(self, text):
		self.file.write(text)
</doc:programlisting>
</doc:par>
</doc:section>

<doc:section><doc:title>Manipulating trees</doc:title>
<doc:par>&xist; provides many methods for manipulation an
&xml; tree. Finding nodes in a tree can be done with the method
<pyref module="xist.xsc" class="Node" method="find">find</pyref>.
<pyref module="xist.xsc" class="Node" method="find">find</pyref> will return
a <pyref module="xist.xsc" class="Frag">Frag</pyref> with the nodes it finds.
Parameters are (with defaults listed in parenthesis):</doc:par>
<ulist>
<item><code>type</code> (<code>None</code>), which is a class object or a list of class
objects. <pyref module="xist.xsc" class="Node" method="find">find</pyref> will
only find nodes that are instances of these classes (or subclasses)</item>
<item><code>subtype</code> (<code>0</code>), a flag that indicates if instances
of subclasses of those specified in the <code>type</code> parameter should
be returned too.</item>
<item><code>attrs</code> (<code>None</code>) is a dictionary mapping attribute
names to attribute string values (or <code>None</code>). This makes it possible
to search for elements with certain attributes, e.g.
<doc:programlisting>
node.find(type=html.a, attrs={"name": None})
</doc:programlisting>
will find all nodes in <code>node</code> that are <pyref module="xist.ns.html" class="a">a</pyref>
instances and have the attribute <code>name</code> set (i.e. the attribute is not
empty).
<doc:programlisting>
node.find(type=html.a, attrs={"href": None, "rel": "parent"})
</doc:programlisting>
will find all <pyref module="xist.ns.html" class="a">a</pyref>
instances where the <pyref module="xist.xsc" class="Node" method="asPlainString">asPlainString</pyref>
value of the <code>rel</code> attribute is <code>parent</code> and the <code>href</code>
attribute is set.</item>
<item><code>test</code> (<code>None</code>) is callable object that will be called
to test if a node should be returned from
<pyref module="xist.xsc" class="Node" method="find">find</pyref> if it passes all previous
tests:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; nums = ["%d," % i for i in xrange(100)]
&gt;&gt;&gt; print xsc.Frag(*nums). \
...    find(test=lambda n: n.asPlainString()[0]=="4"). \
...    asBytes()
4,40,41,42,43,44,45,46,47,48,49,
</doc:programlisting>
</item>
<item><code>searchchildren</code> (<code>0</code>), specifies if the tree
should be searched recursively (<code>searchchildren==1</code>) or only
the first level (<code>searchchildren==0</code>)</item>
<item><code>searchattrs</code> (<code>0</code>), specifies if attribute
nodes should be searched too.</item>
</ulist>
<doc:par>You could for example extract all the links on Python's
<a href="http://python.sf.net/">SourceForge page</a> with the following:</doc:par>
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc, parsers
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; node = parsers.parseTidyURL("http://python.sf.net/")
&gt;&gt;&gt; links = node.find(type=html.a, \
...    attr={"href": None}, searchchildren=1)
&gt;&gt;&gt; for link in links:
...    print link["href"].asPlainString()
...
http://www.python.org/
http://sourceforge.net/
http://sourceforge.net/projects/python/
peps/
sf-faq.html
maint-docs/
devel-docs/
snapshots/
http://www.python.org/
http://www.amk.ca/python/dev/
</doc:programlisting>
<doc:par>The method <pyref module="xist.xsc" class="Node" method="withSep">withSep</pyref>
can be used to put seperator node between the child nodes of an
<pyref module="xist.xsc" class="Element">Element</pyref>
or a <pyref module="xist.xsc" class="Frag">Frag</pyref>:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; print html.div(*xrange(10)).withSep(", ").asBytes()
&lt;div&gt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&lt;/div&gt;
</doc:programlisting>
</doc:par>
<doc:par>The method <pyref module="xist.xsc" class="Node" method="shuffled">shuffled</pyref>
returns a shuffled version of the <pyref module="xist.xsc" class="Element">Element</pyref>
or <pyref module="xist.xsc" class="Frag">Frag</pyref>:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; print html.div(*xrange(10)).shuffled().withSep(", ").asBytes()
&lt;div&gt;8, 1, 3, 6, 7, 5, 2, 9, 4, 0&lt;/div&gt;
&gt;&gt;&gt; print html.div(*xrange(10)).withSep(", ").shuffled().asBytes()
&lt;div&gt;31, 8905, 7, , , 4, 6, , , 2&lt;/div&gt;
</doc:programlisting>
</doc:par>
<doc:par>There are methods named <pyref module="xist.xsc" class="Node" method="reversed">reversed</pyref>
and <pyref module="xist.xsc" class="Node" method="sorted">sorted</pyref>, that
return a reversed or sorted version of an element for fragment:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; print html.div(8,4,2,1,9,6,3,0,7,5). \
...    sorted(lambda n1, n2: \
...       cmp(n1.asPlainString(), n2.asPlainString())). \
...    reversed().withSep(",").asBytes()
&lt;div&gt;9,8,7,6,5,4,3,2,1,0&lt;/div&gt;
</doc:programlisting>
</doc:par>
<doc:par>The method <pyref module="xist.xsc" class="Node" method="mapped">mapped</pyref>
recursively walks the tree and generates a new tree, where all the nodes are mapped
through a function. For example to replace <code>Python</code> with <code>Parrot</code>
in every text node on the <a href="http://python.sf.net/">SourceForge page</a>, do the following:
<doc:programlisting>
from xist import xsc, parsers
from xist.ns import html

def p2p(node):
	if isinstance(node, xsc.Text):
		node = node.replace("Python", "Parrot")
		node = node.replace("python", "parrot")
	return node

node = parsers.parseTidyURL("http://python.sf.net/")
node.mapped(p2p).write(open("parrot_index.html", "wb"))
</doc:programlisting>
The function must either return a new node, in which case this
new node will be used instead of the old one, or return the
old node to tell <pyref module="xist.xsc" class="Node" method="mapped">mapped</pyref>
that it should recursively continue with the content of the node.
</doc:par>
</doc:section>

<doc:section><doc:title>URLs</doc:title>
<doc:par>&xist; has a class for URLs (<pyref module="xist.url" class="URL">xist.url.URL</pyref>)
which is a thin wrapper around <pyref module="urlparse">urlparse</pyref>'s
features. You can add URLs via <code>/</code>, e.g.
<doc:programlisting>
URL("http://www.foo.org/") / URL("/images/bar.png")
</doc:programlisting>
yields an URL object equivalent to
<doc:programlisting>
URL("http://www.foo.org/images/bar.png").
</doc:programlisting>
</doc:par>
<doc:par>&xist; stores the URL from which an attribute was parsed
in the <pyref>base</pyref> attribute of the <pyref module="xist.ns" class="URLAttr">URLAttr</pyref>
object.</doc:par>
</doc:section>

<doc:section><doc:title>Automatic generation of image size attributes</doc:title>
<doc:par>The module <pyref module="xist.ns.specials">xist.ns.specials</pyref>
contains an element <pyref module="xist.ns.specials" class="autoimg">autoimg</pyref> that extends
<pyref module="xist.ns.html" class="img">xist.ns.html.img</pyref>.
When converted to &html; via the <pyref module="xist.ns" class="Node" method="convert">convert</pyref>
method the size of the image will be determined and the <code>height</code>
and <code>width</code> attributes will be set accordingly.</doc:par>

<doc:par>This is not the whole truth. When the <code>width</code> or <code>height</code>
attribute is already specified, the following happens:
%-formatting is used on the attribute value, the width and
height of the image is passed to the % operator as a dictionary
with the keys <code>"width"</code> and <code>"height"</code>.
The resulting string is <code>eval()</code>uated and its result is used for the attribute.
So to make an image twice as wide and high do the following:
<doc:programlisting>
&lt;autoimg src="foo.png" width="%(width)d*2" height="%(height)d*2"/&gt;
</doc:programlisting></doc:par>
</doc:section>

<doc:section><doc:title>Embedding Python code</doc:title>
<doc:par>It's possible to embed Python code into &xist; &xml; files. For this
&xist; supports two new processing instructions: <pyref module="xist.ns.code" class="Exec">code:exec</pyref> 
and <pyref module="xist.ns.code" class="Eval">code:eval</pyref> (in the module
<pyref module="xist.ns.code">xist.ns.code</pyref>. The content of
<pyref module="xist.ns.code" class="Exec">code:exec</pyref> will be 
executed when the processing instruction node is instantiated, i.e. when the 
&xml; file is parsed, so anything you do there will be available afterwards.</doc:par>

<doc:par>The result of a call to <pyref module="xist.xsc" class="Node" method="convert">convert</pyref> 
for a <pyref module="xist.ns.code" class="Eval">code:eval</pyref> processing instruction is whatever the 
Python code in the content returns. This content is treated as the body
of a function, so you can put multiple return statements there.
The converter is available as the parameter <code>converter</code> inside
the processing instruction. For example, consider the following &xml; file:
<doc:programlisting>
&lt;?code:exec
	# sum
	def gauss(top=100):
		sum = 0
		for i in xrange(top+1):
			sum += i
		return sum
?&gt;
&lt;b&gt;&lt;?code:eval return gauss()?&gt;&lt;/b&gt;
</doc:programlisting>
Parsing this file and calling 
<pyref module="xist.xsc" class="Node" method="convert">convert</pyref> results in the following:
<doc:programlisting>
&lt;b&gt;5050&lt;/b&gt;
</doc:programlisting>
</doc:par>
</doc:section>
