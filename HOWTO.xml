<?xml version='1.0' encoding='iso-8859-1'?>
<doc:par>&xist; is an &xml; based extensible &html; generator written in Python.
It was developed as a replacement for an &html; preprocessor named
<app moreinfo="http://www.giga.or.at/~agi/hsc/">HSC</app>, and borrows some
features and ideas from it. It also borrows the basic ideas (&xml;/&html;
elements as Python objects) from 
<app moreinfo="http://starship.python.net/crew/friedrich/HTMLgen/html/main.html">HTMLgen</app> 
or <app moreinfo="http://dustman.net/andy/python/HyperText/">HyperText</app>.</doc:par>

<doc:section><doc:title>Overview</doc:title>
<doc:par>&xist; can be used as a compiler that reads an input file
and generates a transformed output file, or it could be used for generating
&xml; dynamically inside a web server (but note that handling object trees
<em>is</em> slower than simply printing the output string). 
In either case generating the final &html; or &xml; output requires 
the following three steps:</doc:par>
<ulist>
<item>Generating a source &xml; tree: This can be done either by
parsing an &xml; file, or by directly constructing the
tree, as <app>HTMLgen</app> and <app>HyperText</app>
do, as a tree of Python objects. &xist; provides a very natural
and pythonic &api; for that.</item>
<item>Converting the source tree into a target tree: This target
tree can be a &html; tree or a &wml; tree or any other
&xml; tree you like. Every node class provides a
<method>convert</method> method for performing the conversion. For
your own &xml; element types you have to define your
own element classes and implement an appropriate
<method>convert</method> method.</item>
<item>Publishing the target tree: For generating the final
output, all node classes provide a <method>publish</method> method, that
passes the string fragments to an appropriate publishing handler.</item>
</ulist>
</doc:section>

<doc:section><doc:title>Constructing &xml; trees</doc:title>
<doc:par>Like any other &dom; &api;, &xist; provides the 
usual classes:</doc:par>
<ulist>
<item><doc:pyref module="xist.xsc" class="Text"><class>Text</class></doc:pyref> for text data</item>
<item><doc:pyref module="xist.xsc" class="Frag"><class>Frag</class></doc:pyref> for document fragments,
a <doc:pyref module="xist.xsc" class="Frag"><class>Frag</class></doc:pyref> object is simply a list
of nodes,</item>
<item><doc:pyref module="xist.xsc" class="Comment"><class>Comment</class></doc:pyref> for &xml; comments
(e.g. <markup>&lt;!-- the comment --&gt;</markup>)</item>
<item><doc:pyref module="xist.xsc" class="DocType"><class>DocType</class></doc:pyref> for document type
declarations (e.g. <markup>&lt;!DOCTYPE html PUBLIC <replaceable>...</replaceable>&gt;</markup>),</item>
<item><doc:pyref module="xist.xsc" class="ProcInst"><class>ProcInst</class></doc:pyref> for processing instructions
(e.g. <markup>&lt;?php echo $spam;?&gt;</markup>,</item>
<item><doc:pyref module="xist.xsc" class="Element"><class>Element</class></doc:pyref> for &xml; elements,</item>
<item><doc:pyref module="xist.xsc" class="Entity"><class>Entity</class></doc:pyref> for entities
(e.g. <markup>&amp;parrot;</markup>),</item>
<item><doc:pyref module="xist.xsc" class="Attr"><class>Attr</class></doc:pyref> for attributes and</item>
<item><doc:pyref module="xist.xsc" class="Attrs"><class>Attrs</class></doc:pyref> for attribute mappings.</item>
</ulist>

<doc:section><doc:title>&xml; trees as Python objects</doc:title>
<doc:par>&xist; works somewhat different from a normal &dom; &api;.
Instead of only one element class, &xist; has one class for every element
type. All the elements known to &xist; are defined in modules in
the <doc:pyref module="xist.ns"><module>xist.ns</module></doc:pyref> subpackage. The definition of &html; can
be found in <doc:pyref module="xist.ns.html"><module>xist.ns.html</module></doc:pyref> for example.</doc:par>

<doc:par>Every element class has a constructor of the form
<doc:programlisting>
__init__(self, *content, **attrs)
</doc:programlisting>
Positional arguments (i.e. items in <arg>content</arg>)
will be the child nodes of the element node. Keyword arguments
will be attributes. You can pass most builtin types to such a constructor.
Strings and integers will be automatically converted to
<pyref module="xist.xsc" class="Text"><class>Text</class></pyref> objects.
So constructing an &html; element works like this:
<doc:example title="The first example">
<doc:programlisting>
from xist.ns import html

node = html.div(
	"Hello ",
	html.a("Python", href="http://www.python.org/"),
	" world!"
)
</doc:programlisting>
</doc:example>
</doc:par>

<doc:par>For attribute names that collide with Python keywords
(most notably <lit>class</lit>) you can append an underscore to the
name:
<doc:example title="Colliding attribute names">
<doc:programlisting>
node = html.div(
	"Hello world!",
	class_="greeting"
)
</doc:programlisting>
</doc:example>
One trailing underscore will be stripped off of an attribute name in the
element constructor. You can pass attributes as a <class>dict</class>
instance too:</doc:par>
<doc:programlisting>
node = html.div(
	"Hello world!",
	{
		"class": "greeting",
		"id": 42,
		"name": "greeting42"
	}
)
</doc:programlisting>
</doc:section>

<doc:section><doc:title>Generating &xml; trees from &xml; files</doc:title>
<doc:par>Of course &xml; trees can also be generated by parsing
&xml; files. For this the module <doc:pyref module="xist.parsers"><module>xist.parsers</module></doc:pyref>
provides two functions:
<doc:programlisting>
parseString(text, systemId="STRING", base=None,
	handler=None, parser=None,
	namespaces=None, defaultEncoding="utf-8",
	tidy=0)

parseURL(id, base=None,
	handler=None, parser=None,
	namespaces=None, defaultEncoding="utf-8",
	tidy=0,
	headers=None, data=None):
</doc:programlisting>
<doc:pyref module="xist.parsers" function="parseString"><function>parseString</function></doc:pyref> is for parsing strings
(8bit and Unicode) and <doc:pyref module="xist.parsers" function="parseURL"><function>parseURL</function></doc:pyref> is for
parsing local and remote files. The argument <arg>tidy</arg> allows you the specify, whether
Marc-André Lemburg's <app moreinfo="http://www.lemburg.com/files/python/">mxTidy</app> should
be used for cleaning up broken &html; before parsing the result. The argument <arg>parser</arg>
specifies the parser to be used. Any &sax;2 parser can be used. &xist; provides a
&sax;2 parser for <app>sgmlop</app> named
<doc:pyref module="xist.parsers" class="SGMLOPParser"><class>SGMLOPParser</class></doc:pyref>
(which is the default if no argument is given) and an &html; parser named
<doc:pyref module="xist.parsers" class="HTMLParser"><class>HTMLParser</class></doc:pyref>, that
tries to make sense of &html; sources.</doc:par>

<doc:par>Both functions call
<doc:pyref module="xist.parsers" function="parse"><function>parse</function></doc:pyref>
internally and pass an appropriate <arg>source</arg> argument, which is a standard &sax;
<class>InputSource</class> instance, so it's possible to extend the parsing machinery
for different data sources.</doc:par>
</doc:section>
</doc:section>

<doc:section><doc:title>Defining new elements, converting &xml; trees</doc:title>
<doc:par>To be able to parse an &xml; file, you have to provide an element class
for every element type that appears in the file. Defining an element class
for an element named <lit>cool</lit> works like this:
<doc:example title="Defining a new element">
<doc:programlisting>
class cool(xsc.Element):
	empty = 0

	def convert(self, converter):
		node = html.b(self.content, " is cool!")
		return node.convert(converter)
</doc:programlisting>
</doc:example>
You have to derive your new class from <pyref module="xist.xsc" class="Element"><class>xsc.Element</class></pyref>.
The name of the class will be the element name. For element type names that are no valid Python
identifiers, you can use the class attribute <lit>name</lit> in the element class the overwrite
the element name.</doc:par>
<doc:par>To be able to convert an element of this type to a new &xml; tree (&html; in most cases),
you have to implement the <pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
method. In this method you can build a new &xml; tree from the content and attributes
of the object.</doc:par>

<doc:par>Using this new element is simple
<doc:example title="Using the new element">
<doc:programlisting>
&gt;&gt;&gt; node = cool("Python")
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;Python is cool!&lt;/b&gt;
</doc:programlisting>
</doc:example>
(<doc:pyref module="xist.xsc" class="Node" method="conv"><method>conv</method></doc:pyref> simply
calls
<doc:pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></doc:pyref>
with a default <doc:pyref module="xist.converters" class="Converter"><arg>converter</arg></doc:pyref>
argument. We'll come to converters in a minute.
<doc:pyref module="xist.xsc" class="Node" method="asBytes"><method>asBytes</method></doc:pyref>
is a method that converts the node to a byte string. This method will be explained
when we discuss the publishing interface.)
</doc:par>

<doc:par>Note that it is vital for your own <method>convert</method>
methods that you recursively call <method>convert</method>
on your own content, because otherwise some unconverted nodes
might remain in the tree. Lets define a new element:
<doc:programlisting>
class python(xsc.Element):
	empty = 1

	def convert(self, converter):
		return html.a(
			"Python",
			href="http://www.python.org/"
		)
</doc:programlisting>
Now we can do the following:
<doc:programlisting>
&gt;&gt;&gt; node = cool(python())
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is cool!&lt;/b&gt;
</doc:programlisting>
But if we forget to call
<pyref module="xist.xsc" class="Node" method="convert">convert</pyref>
for our own content, i.e. if the element <pyref class="cool">cool</pyref> 
was written like this:
<doc:programlisting>
class cool(xsc.Element):
	empty = 0

	def convert(self, converter):
		return html.b(self.content, " is cool!")
</doc:programlisting>
we would get:
<doc:programlisting>
&gt;&gt;&gt; node = cool(python())
&gt;&gt;&gt; print node.conv().asBytes()
&lt;b&gt;&lt;python /&gt; is cool!&lt;/b&gt;
</doc:programlisting>
</doc:par>

<doc:section><doc:title>Converters</doc:title>
<doc:par><doc:pyref module="xist.xsc" class="Node" method="conv"><method>conv</method></doc:pyref>
is a convenience method that creates a default converter for you and calls
<doc:pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></doc:pyref>.
You could also call <doc:pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></doc:pyref> yourself,
which would look like this:
<doc:programlisting>
from xist import converters

node = cool(python())
node = node.convert(converters.Converter(None, None,
	"deliver", "html", None))
</doc:programlisting>
You can pass the following five arguments to the
<doc:pyref module="xist.converters" class="Converter"><class>Converter</class></doc:pyref> constructor</doc:par>
<ulist>
<item><arg>root</arg> (which defaults to <lit>None</lit>) is the root &url; for the conversion process. When you want
to resolve a link in some of your own <method>convert</method> methods, the &url; must be interpreted relative
to this root &url;.</item>
<item><arg>mode</arg> (which defaults to <lit>None</lit>) works the same way as modes in &xslt;. You can use this
for implementing different conversion modes.</item>
<item><arg>stage</arg> (which defaults to <lit>"deliver"</lit>) allows you to implement multi stage conversion:
Suppose that you want to deliver a dynamically constructed web page with &xist; that contains
results from a database query and the current time. The data in the database changes
infrequently, so it doesn't make sense to do the query on every request. The query is done
every few minutes and the resulting &html; tree is stored in the servlet
(using any of the available Python servlet technologies). For this conversion the
<arg>stage</arg> would be <lit>"cache"</lit> and your database &xml; element would do the
query when <lit><arg>stage</arg>=="cache"</lit>. Your time display element would do the conversion
when <lit><arg>stage</arg>=="deliver"</lit> and simply returns itself when
<lit><arg>stage</arg>=="cache"</lit>, so it would still be part of the cached &xml; tree
and would be converted to &html; on every request.</item>
<item><arg>target</arg> (which defaults to <lit>"html"</lit>) specifies what the output should be. Values could
e.g. be <lit>"html"</lit>, <lit>"wml"</lit> or <lit>"docbook"</lit>.</item>
<item><arg>lang</arg> (which defaults to <lit>None</lit>) is the language in which the result tree should be.
This can be used in the <method>convert</method> method
to implement different conversions for different languages, e.g.:
<doc:programlisting>
class note(xsc.Element):
	empty = 0

	def convert(self, converter):
		if converter.lang=="de":
			title = "Anmerkung"
		elif converter.lang=="ja":
			title = u"???"
		elif converter.lang=="fr":
			title = "???"
		else:
			title = "Note"
		return xsc.Frag(
			html.h1(title),
			html.div(self.content.convert(converter))
		)
</doc:programlisting>
and you can test for the language with the element
<pyref module="xist.ns.cond" class="If"><class>xist.ns.cond.If</class></pyref>, e.g.:
<doc:programlisting>
&lt;if lang="de"&gt;Anmerkung
&lt;elif lang="ja"&gt;???
&lt;elif lang="fr"&gt;???
&lt;else&gt;Note
&lt;/if&gt;
</doc:programlisting>
</item>
</ulist>
<par>Additional arguments are passed when a converter is created in the context of
a <pyref module="make"><module>make</module></pyref> script.</par>
</doc:section>

<doc:section><doc:title>Attributes</doc:title>
<doc:par>Setting and accessing the attributes of an element work via
the dictionary interface. So if <lit>node</lit>
is an <pyref module="xist.xsc" class="Element"><class>Element</class></pyref> that supports the
attribute <lit>spam</lit> the following can be
done:
<doc:example title="Working with attributes">
<doc:programlisting>
if node.hasAttr("spam"):
	del node["spam"]
else:
	node["spam"] = "eggs"
node["spam"].append("ham")
</doc:programlisting>
</doc:example>
</doc:par>
<doc:par>All attribute values are instances of subclasses of
the class <pyref module="xist.xsc" class="Attr"><class>Attr</class></pyref>. Available
subclasses are:</doc:par>
<ulist>
<item><pyref module="xist.xsc" class="TextAttr"><class>TextAttr</class></pyref>, for normal text attributes;</item>
<item><pyref module="xist.xsc" class="URLAttr"><class>URLAttr</class></pyref>, for attributes that are &url;s;</item>
<item><pyref module="xist.xsc" class="BoolAttr"><class>BoolAttr</class></pyref>, for boolean attributes (such an attribute
is either present or not, but it's value will be ignored);</item>
<item><pyref module="xist.xsc" class="IntAttr"><class>IntAttr</class></pyref>, for integer attributes;</item>
<item><pyref module="xist.xsc" class="ColorAttr"><class>ColorAttr</class></pyref>, for color attributes (e.g. <code>#ffffff</code>)</item>
</ulist>
<doc:par><pyref module="xist.xsc" class="Attr"><class>Attr</class></pyref> itself is derived from
<pyref module="xist.xsc" class="Frag"><class>Frag</class></pyref> so it is possible
to use all the sequence methods on an attribute. Unset attributes will be treated
like empty ones so the following is possible:
<doc:example>
<doc:programlisting>
del node["spam"]
node["spam"].append("ham")
</doc:programlisting>
</doc:example>
This also means that after
<doc:example>
<doc:programlisting>
del node["spam"][0]
</doc:programlisting>
</doc:example>
the attribute will be empty again and will be considered to be unset.
Such attributes will be ignored when publishing.
</doc:par>
</doc:section>

<doc:section><doc:title>Specifying content model and attributes</doc:title>
<doc:par>When you define a new element you have to specify two things:</doc:par>

<olist>
<item>If the element has an empty content model (like <markup>&lt;br/&gt;</markup>
or <markup>&lt;img/&gt;</markup> do in &html;) or not.</item>
<item>what attributes the element supports and of which type they are.</item>
</olist>

<doc:par>Specifying the content model is done with the class attribute <lit>empty</lit>.
Set it to <lit>0</lit> when your element may have content and to <lit>1</lit>
if it may not.</doc:par>

<doc:par>To specify the attributes for the element, use the class
attribute <lit>attrHandlers</lit>, which must be a dictionary
mapping attribute names to attribute classes. We could extend our
example element in the following way:
<doc:example title="Using attributes">
<doc:programlisting>
class cool(xsc.Element):
	empty = 0
	attrHandlers = {"adj": xsc.TextAttr}

	def convert(self, converter):
		node = xsc.Frag(self.content, " is")
		if self.hasAttr("adj"):
			node.append(" ", html.em(self["adj"]))
		node.append(" cool!")
		return node.convert(converter)
</doc:programlisting>
</doc:example>
and use it like this
<doc:programlisting>
&gt;&gt;&gt; node = cool(python(), adj="totally")
&gt;&gt;&gt; print node.conv().asBytes()
&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt; is &lt;em&gt;totally&lt;/em&gt; cool!
</doc:programlisting>
</doc:par>
</doc:section>

<doc:section><doc:title>Namespace objects</doc:title>
<doc:par>Now that you've defined your own elements, you have to
tell the parser about them, so they can be instantiated when
a file is parsed. This is done with namespace objects. At the end
of your Python module after all the classes are defined, create a
namespace object that collects all the class objects from the
local scope:
<doc:example>
<doc:programlisting>
namespace = xsc.Namespace(
	"foo",
	"http://www.foo.net/DTDs/foo.dtd",
	vars()
)
</doc:programlisting>
</doc:example>
Arguments for the <pyref module="xist.xsc" class="Namespace"><class>Namespace</class></pyref>
constructor are:</doc:par>
<ulist>
<item><arg>prefix</arg> is the namespace prefix that can be used to disambiguate elements
in different namespaces with the same name.</item>
<item><arg>uri</arg> is the namespace &url; for the namespace. This is currently unused.
&xist; doesn't have real namespace support where namespace prefixes can be bound to
namespace &url;s dynamically, but uses fixed prefixes.</item>
<item><arg>thing</arg> is the object that should be registered in the namespace.
To register all the element classes (and entity and processing instruction classes)
defined in the module, simply use <lit>vars()</lit>.</item>
</ulist>

<doc:par>All namespace objects will automatically be registered with the
parser. Now all newly defined elements will be used when parsing
files.</doc:par>
</doc:section>

<doc:section><doc:title>Entities and processing instructions</doc:title>
<doc:par>In the same way as defining new element types, you can define new
entities and processing instructions. But to be able to use the new entities
in an &xml; file you have to use a parser that supports reporting undefined
entities to the application via <method>skippedEntity</method>
(<pyref module="xist.parsers" class="SGMLOPParser"><class>SGMLOPParser</class></pyref>
in the module <pyref module="xist.parsers"><module>xist.parsers</module></pyref> does that).</doc:par>
<doc:par>In addition to the <pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
method you may implement the method
<pyref module="xist.xsc" class="Node" method="__unicode__"><method>__unicode__</method></pyref>,
which must return a unicode string value for the entity. The following
example is from the module <pyref module="xist.ns.abbr"><module>xist.ns.abbr</module></pyref>:
<doc:example title="Defining new entities">
<doc:programlisting>
from xist import xsc
from xist.ns import html

class xml(xsc.Entity):
	def convert(self, converter):
		return html.abbr(
			"XML",
			title="Extensible Markup Language",
			lang="en")
	def __unicode__(self):
		return u"XML"
</doc:programlisting>
</doc:example>
Now you can use this new entity in your &xml; files:
<doc:programlisting>
&lt;cool adj="very"&gt;&amp;xml;&lt;/cool&gt;
</doc:programlisting>
</doc:par>
<doc:par>Defining processing instructions works the same way. Derive a
new class from <pyref module="xist.xsc" class="ProcInst"><class>xist.xsc.ProcInst</class></pyref>
and implement <pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></pyref>.
The following example implements a processing instruction that returns an uppercase
version of it's content as a text node.
<doc:example title="Defining new processing instructions">
<doc:programlisting>
class upper(xsc.ProcInst):
	def convert(self, converter):
		return xsc.Text(self.content.upper())
</doc:programlisting>
</doc:example>
it can be used in an &xml; file as following:
<doc:programlisting>
&lt;?upper foo?&gt;
</doc:programlisting>
</doc:par>
</doc:section>
</doc:section>

<doc:section><doc:title>Publishing &xml; trees</doc:title>
<doc:par>After creating the &xml; tree and converting the tree
into its final output form, you have to write the resulting tree
to a file. This can be done with the publishing &api;. Two methods
that use the publishing &api; are
<pyref module="xist.xsc" class="Node" method="asBytes"><method>asBytes</method></pyref>
and
<pyref module="xist.xsc" class="Node" method="write"><method>write</method></pyref>.
<pyref module="xist.xsc" class="Node" method="asBytes"><method>asBytes</method></pyref>
returns an 8bit &xml; string. You can specify the encoding with the
parameter <arg>encoding</arg> (with <lit>"us-ascii"</lit> being the default).
Unencodable characters will be escaped with numeric character references when possible
(i.e. inside text nodes, for comments or processing instructions you'll get
an exception):
<doc:programlisting>
&gt;&gt;&gt; from xist.ns import xsc, html
&gt;&gt;&gt; print html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ").asBytes(encoding="ascii")
&lt;div&gt;&amp;#228;&amp;#246;&amp;#252;&lt;br /&gt;&amp;#196;&amp;#214;&amp;#220;&lt;/div&gt;
&gt;&gt;&gt; print html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ").asBytes(encoding="iso-8859-1")
&lt;div&gt;äöü&lt;br /&gt;ÄÖÜ&lt;/div&gt;
&gt;&gt;&gt; print xsc.Comment(u"äöü").asBytes()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "~/pythonroot/xist/xsc.py", line 828, in asBytes
    return publisher.asBytes()
  File "~/pythonroot/xist/publishers.py", line 162, in asBytes
    return u"".join(self.texts).encode(self.encoding)
UnicodeError: ASCII encoding error: ordinal not in range(128)
</doc:programlisting>
</doc:par>
<doc:par>Another useful parameter is <arg>xhtml</arg>,
it specifies if you want pure &html; or &xhtml; as output:</doc:par>
<ulist>
<item><lit>xhtml==0</lit> will give you pure &html;, i.e. no final <lit>/</lit>
for elements with an empty content model, so you'll get e.g. <markup>&lt;br&gt;</markup> in the output.
Elements that don't have an empty content model, but are empty will be published with a start and
end tag (i.e. <markup>&lt;div&gt;&lt;/div&gt;</markup>).</item>
<item><lit>xhtml==1</lit> gives &html; compatible &xhtml;. Elements with empty content
model will be published like this: <markup>&lt;br /&gt;</markup>.</item>
<item><lit>xhtml==2</lit> gives full &xml; output. Every empty element will be published with
an empty tag (without an additional space): <markup>&lt;br/&gt;</markup> or <markup>&lt;div/&gt;</markup>.</item>
</ulist>
<doc:par>Writing a node to a file can be done with the method
<pyref module="xist.xsc" class="Node" method="write"><method>write</method></pyref>:
<doc:programlisting>
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; html.div(
...    u"äöü",
...    html.br(),
...    u"ÄÖÜ").write(open("foo.html", "wb"), encoding="ascii")
</doc:programlisting>
</doc:par>
<doc:par>All these methods use the method
<pyref module="xist.xsc" class="Node" method="publish"><method>publish</method></pyref> internally.
<pyref module="xist.xsc" class="Node" method="publish"><method>publish</method></pyref> gets passed
an instance of <pyref module="xist.publishers" class="Publisher"><class>xist.publisher.Publisher</class></pyref>
(or one of it's subclasses). All strings generated will be sent to the
<pyref module="xist.publishers" class="Publisher" method="publish"><method>publish</method></pyref> method
of the publisher. <pyref module="xist.xsc" class="Node" method="write"><method>write</method></pyref>
uses <pyref module="xist.publishers" class="FilePublisher"><class>FilePublisher</class></pyref>
and
<pyref module="xist.xsc" class="Node" method="asBytes"><method>asBytes</method></pyref>
uses <pyref module="xist.publishers" class="BytePublisher"><class>BytePublisher</class></pyref>.
For example <pyref module="xist.publishers" class="FilePublisher"><class>FilePublisher</class></pyref>
looks like this:
<doc:programlisting>
class FilePublisher(Publisher):
	def __init__(self, file, base=None, encoding=None, xhtml=None,
			publishPrefix=0):
		Publisher.__init__(self, base=base, encoding=encoding,
			xhtml=xhtml, publishPrefix=publishPrefix)
		(encode, decode, streamReader,
			streamWriter) = codecs.lookup(self.encoding)
		self.file = streamWriter(file)

	def publish(self, text):
		self.file.write(text)
</doc:programlisting>
</doc:par>
</doc:section>

<doc:section><doc:title>Manipulating trees</doc:title>
<doc:par>&xist; provides many methods for manipulating an
&xml; tree. Finding nodes in a tree can be done with the method
<pyref module="xist.xsc" class="Node" method="find"><method>find</method></pyref>.
<pyref module="xist.xsc" class="Node" method="find"><method>find</method></pyref> will return
a <pyref module="xist.xsc" class="Frag"><class>Frag</class></pyref> with the nodes it finds.
Parameters are (with defaults listed in parenthesis):</doc:par>
<ulist>
<item><arg>type</arg> (<lit>None</lit>), which is a class object or a list of class
objects. <pyref module="xist.xsc" class="Node" method="find"><method>find</method></pyref> will
only find nodes that are instances of these classes (or subclasses);</item>
<item><arg>subtype</arg> (<lit>0</lit>), a flag that indicates if instances
of subclasses of those specified in the <arg>type</arg> parameter should
be returned too;</item>
<item><arg>attrs</arg> (<lit>None</lit>) is a dictionary mapping attribute
names to attribute string values (or <lit>None</lit>). This makes it possible
to search for elements with certain attributes, e.g.
<doc:programlisting>
node.find(type=html.a, attrs={"name": None})
</doc:programlisting>
will find all nodes in <lit>node</lit> that are <pyref module="xist.ns.html" class="a"><class>a</class></pyref>
instances and have the attribute <lit>name</lit> set (i.e. the attribute is not
empty).
<doc:programlisting>
node.find(type=html.a, attrs={"href": None, "rel": "parent"})
</doc:programlisting>
will find all <pyref module="xist.ns.html" class="a"><class>a</class></pyref>
instances where the <pyref module="xist.xsc" class="Node" method="__unicode__"><method>__unicode__</method></pyref>
value of the <lit>rel</lit> attribute is <lit>"parent"</lit> and the <lit>href</lit>
attribute is set;</item>
<item><arg>test</arg> (<lit>None</lit>) is a callable object that will be called
to test if a node should be returned from
<pyref module="xist.xsc" class="Node" method="find"><method>find</method></pyref> when it
passes all previous tests:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; nums = ["%d," % i for i in xrange(100)]
&gt;&gt;&gt; node = xsc.Frag(*nums)
&gt;&gt;&gt; print node. \
...    find(test=lambda n: unicode(n)[0]==u"4"). \
...    asBytes()
4,40,41,42,43,44,45,46,47,48,49,
</doc:programlisting>
</item>
<item><arg>searchchildren</arg> (<lit>0</lit>), specifies if the tree
should be searched recursively (<lit><arg>searchchildren</arg>==1</lit>) or only
the first level (<lit><arg>searchchildren</arg>==0</lit>)</item>
<item><arg>searchattrs</arg> (<lit>0</lit>), specifies if attribute
nodes should be searched too.</item>
</ulist>
<doc:par>You could for example extract all the links on Python's
<a href="http://python.sf.net/">SourceForge page</a> with the following:</doc:par>
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc, parsers
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; node = parsers.parseURL("http://python.sf.net/", tidy=1)
&gt;&gt;&gt; links = node.find(type=html.a, \
...    attr={"href": None}, searchchildren=1)
&gt;&gt;&gt; for link in links:
...    print link["href"]
...
http://www.python.org/
http://sourceforge.net/
http://sourceforge.net/projects/python/
peps/
sf-faq.html
maint-docs/
devel-docs/
snapshots/
http://www.python.org/
http://www.amk.ca/python/dev/
</doc:programlisting>
<doc:par>The method <pyref module="xist.xsc" class="Node" method="withSep"><method>withSep</method></pyref>
can be used to put a seperator node between the child nodes of an
<pyref module="xist.xsc" class="Element"><class>Element</class></pyref>
or a <pyref module="xist.xsc" class="Frag"><class>Frag</class></pyref>:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; print html.div(*xrange(10)).withSep(", ").asBytes()
&lt;div&gt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&lt;/div&gt;
</doc:programlisting>
</doc:par>
<doc:par>The method <pyref module="xist.xsc" class="Node" method="shuffled"><method>shuffled</method></pyref>
returns a shuffled version of the <pyref module="xist.xsc" class="Element"><class>Element</class></pyref>
or <pyref module="xist.xsc" class="Frag"><class>Frag</class></pyref>:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; print html.div(*xrange(10)).shuffled().withSep(", ").asBytes()
&lt;div&gt;8, 1, 3, 6, 7, 5, 2, 9, 4, 0&lt;/div&gt;
&gt;&gt;&gt; print html.div(*xrange(10)).withSep(", ").shuffled().asBytes()
&lt;div&gt;31, 8905, 7, , , 4, 6, , , 2&lt;/div&gt;
</doc:programlisting>
</doc:par>
<doc:par>There are methods named <pyref module="xist.xsc" class="Node" method="reversed"><method>reversed</method></pyref>
and <pyref module="xist.xsc" class="Node" method="sorted"><method>sorted</method></pyref>, that
return a reversed or sorted version of an element or fragment:
<doc:programlisting>
&gt;&gt;&gt; from xist import xsc
&gt;&gt;&gt; from xist.ns import html
&gt;&gt;&gt; print html.div(8,4,2,1,9,6,3,0,7,5). \
...    sorted(lambda n1, n2: \
...       cmp(unicode(n1), unicode(n2))). \
...    reversed().withSep(",").asBytes()
&lt;div&gt;9,8,7,6,5,4,3,2,1,0&lt;/div&gt;
</doc:programlisting>
</doc:par>
<doc:par>The method <pyref module="xist.xsc" class="Node" method="mapped"><method>mapped</method></pyref>
recursively walks the tree and generates a new tree, where all the nodes are mapped
through a function. For example to replace <lit>Python</lit> with <lit>Parrot</lit>
in every text node on the <a href="http://python.sf.net/">SourceForge page</a>, do the following:
<doc:programlisting>
from xist import xsc, parsers
from xist.ns import html

def p2p(node):
	if isinstance(node, xsc.Text):
		node = node.replace("Python", "Parrot")
		node = node.replace("python", "parrot")
	return node

node = parsers.parseURL("http://python.sf.net/", tidy=1)
node.mapped(p2p).write(open("parrot_index.html", "wb"))
</doc:programlisting>
The function must either return a new node, in which case this
new node will be used instead of the old one, or return the
old node to tell <pyref module="xist.xsc" class="Node" method="mapped"><method>mapped</method></pyref>
that it should recursively continue with the content of the node.
</doc:par>
</doc:section>

<doc:section><doc:title>&url;s</doc:title>
<doc:par>For &url; handling &xist; uses the module <pyref module="url"><module>url</module></pyref>.</doc:par>
</doc:section>

<doc:section><doc:title>Automatic generation of image size attributes</doc:title>
<doc:par>The module <pyref module="xist.ns.specials"><module>xist.ns.specials</module></pyref>
contains an element <pyref module="xist.ns.specials" class="autoimg"><class>autoimg</class></pyref> that extends
<pyref module="xist.ns.html" class="img"><class>xist.ns.html.img</class></pyref>.
When converted to &html; via the <pyref module="xist.ns" class="Node" method="convert"><method>convert</method></pyref>
method the size of the image will be determined and the <lit>height</lit>
and <lit>width</lit> attributes will be set accordingly.</doc:par>

<doc:par>This is not the whole truth. When the <lit>width</lit> or <lit>height</lit>
attribute is already specified, the following happens:
%-formatting is used on the attribute value, the width and
height of the image is passed to the <lit>%</lit> operator as a dictionary
with the keys <lit>"width"</lit> and <lit>"height"</lit>.
The resulting string is <lit>eval()</lit>uated and its result is used for the attribute.
So to make an image twice as wide and high do the following:
<doc:programlisting>
&lt;autoimg src="foo.png" width="%(width)d*2" height="%(height)d*2"/&gt;
</doc:programlisting></doc:par>
</doc:section>

<doc:section><doc:title>Embedding Python code</doc:title>
<doc:par>It's possible to embed Python code into &xist; &xml; files. For this
&xist; supports two new processing instructions: <pyref module="xist.ns.code" class="Exec"><lit>code:exec</lit></pyref>
and <pyref module="xist.ns.code" class="Eval"><lit>code:eval</lit></pyref> (in the module
<pyref module="xist.ns.code"><module>xist.ns.code</module></pyref>. The content of
<pyref module="xist.ns.code" class="Exec"><lit>code:exec</lit></pyref> will be
executed when the processing instruction node is instantiated, i.e. when the
&xml; file is parsed, so anything you do there will be available afterwards.</doc:par>

<doc:par>The result of a call to <pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
for a <pyref module="xist.ns.code" class="Eval"><lit>code:eval</lit></pyref> processing instruction is whatever the
Python code in the content returns. The processing instruction content is treated as the body
of a function, so you can put multiple return statements there.
The converter is available as the parameter <arg>converter</arg> inside
the processing instruction. For example, consider the following &xml; file:
<doc:programlisting>
&lt;?code:exec
	# sum
	def gauss(top=100):
		sum = 0
		for i in xrange(top+1):
			sum += i
		return sum
?&gt;
&lt;b&gt;&lt;?code:eval return gauss()?&gt;&lt;/b&gt;
</doc:programlisting>
Parsing this file and calling 
<pyref module="xist.xsc" class="Node" method="convert"><method>convert</method></pyref> results in the following:
<doc:programlisting>
&lt;b&gt;5050&lt;/b&gt;
</doc:programlisting>
</doc:par>
</doc:section>
