<?xml version='1.0' encoding='iso-8859-1'?>
<section><title>&url;s</title>

<par>For &url; handling &xist; uses the module
<pyref module="ll.url"><module>ll.url</module></pyref>. Refer to its documentation
for the basic functionality (especially regarding the methods
<pyref module="ll.url" class="URL" method="__div__"><method>__div__</method></pyref>
and <pyref module="ll.url" class="URL" method="relative"><method>relative</method></pyref>).</par>

<par>When &xist; parses an &xml; resource it uses a so called <z>base</z> &url;.
This base &url; can be passed to all parsing functions. If it isn't specified
it defaults to the &url; of the resource being parsed. This base &url; will
be prepended to all &url;s that are read during parsing:</par>
<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import parsers</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = parsers.parsestring('&lt;img src="eggs.png"/&gt;', base="root:spam/index.html")</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.bytes()</input>
&lt;img src="root:spam/eggs.png" /&gt;
</tty>

<par>For publishing a base &url; can be specified too. &url;s will be published
relative to this base &url; with the exception of relative &url;s in the tree.
This means:</par>
<ulist>
<item>When you have a relative &url; (e.g. <lit>#top</lit>) generated by a <method>convert</method>
call, this &url; will stay the same when publishing.</item>
<item>Base &url;s for parsing should never be relative: Relative base
&url;s will be prepended to all relative &url;s in the file, but this will not be
reverted for publishing. In most cases the base &url; should be a
<lit>root</lit> &url; when you parse local files.</item>
<item>When you parse remote web pages you can either
omit the <arg>base</arg> argument, so it will default to the
&url; being parsing, so that links, images, etc. on the page
will still point back to their original location, or you
might want to use the empty &url; <lit>URL()</lit> as the
base, so you'll get all &url;s in the page as they are.</item>
<item><par>When &xist; is used as a compiler for static pages, you're
going to read source &xml; files, do a conversion and write the
result to a new target file. In this case you should probably
use the &url; of the target file for both parsing and
publishing. Let's assume we have an &url; <lit>#top</lit>
in the source file. When we use the <z>real</z> file names
for parsing and publishing like this:</par>
<prog>
node = parsers.parsefile("spam.htmlxsc", base="root:spam.htmlxsc")
node = node.conv()
node.write(open("spam.html", "wb"), base="root:spam.html")
</prog>
<par>the following will happen: The &url; <lit>#top</lit>
will be parsed as <lit>root:spam.htmlxsc#top</lit>. After
conversion this will be written to <filename>spam.html</filename>
relative to the &url; <lit>root:spam.html</lit>, which results
in <lit>spam.html#top</lit>, which works, but is not what you
want.</par>
<par>When you use <lit>root:spam.html</lit> both for parsing
and publishing, <lit>#top</lit> will be written to the target file
as expected.</par></item>
</ulist>

</section>


<section><title>Pretty printing &xml;</title>
<par>The method <method>pretty</method> can be used for pretty printing &xml;.
It returns a new version of the node, with additional white space between the
elements:</par>
<example>
<prog>
from ll.xist.ns import html
node = html.html(
	html.head(
		html.title(u"foo"),
	),
	html.body(
		html.div(
			html.h1(u"The ", html.em(u"foo"), u" page!"),
			html.p(u"Welcome to the ", html.em(u"foo"), u" page."),
		),
	),
)

print node.pretty().bytes()
</prog>
</example>
<par>This will print:</par>
<example>
<tty>
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;foo&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;
			&lt;h1&gt;The &lt;em&gt;foo&lt;/em&gt; page!&lt;/h1&gt;
			&lt;p&gt;Welcome to the &lt;em&gt;foo&lt;/em&gt; page.&lt;/p&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</tty>
</example>
<par>Element content will only be modified if it doesn't contain
<class>Text</class> nodes, so mixed content will not be touched.</par>
</section>


<section><title>Automatic generation of image size attributes</title>

<par>The module <pyref module="ll.xist.ns.htmlspecials"><module>ll.xist.ns.htmlspecials</module></pyref>
contains an element <pyref module="ll.xist.ns.htmlspecials" class="autoimg"><class>autoimg</class></pyref>
that extends <pyref module="ll.xist.ns.html" class="img"><class>ll.xist.ns.html.img</class></pyref>.
When converted to &html; via the <pyref module="ll.xist.ns" class="Node" method="convert"><method>convert</method></pyref>
method the size of the image will be determined and the <lit>height</lit>
and <lit>width</lit> attributes will be set accordingly (if those attributes
are not set already).</par>

</section>


<section><title>Embedding Python code</title>
<par>It's possible to embed Python code into &xist; &xml; files. For this
&xist; supports two new processing instructions:
<pyref module="ll.xist.ns.code" class="pyexec"><lit>pyexec</lit></pyref>
and <pyref module="ll.xist.ns.code" class="pyeval"><lit>pyeval</lit></pyref> (in the module
<pyref module="ll.xist.ns.code"><module>ll.xist.ns.code</module></pyref>). The content of
<pyref module="ll.xist.ns.code" class="pyexec"><lit>pyexec</lit></pyref> will be
executed when the processing instruction node is converted.</par>

<par>The result of a call to <pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
for a <pyref module="ll.xist.ns.code" class="pyeval"><lit>pyeval</lit></pyref> processing instruction is whatever the
Python code in the content returns. The processing instruction content is treated as the body
of a function, so you can put multiple return statements there.
The converter is available as the parameter <arg>converter</arg> inside
the processing instruction. For example, consider the following &xml; file:</par>

<prog>
&lt;?pyexec
	# sum
	def gauss(top=100):
		sum = 0
		for i in xrange(top+1):
			sum += i
		return sum
?&gt;
&lt;b&gt;&lt;?pyeval return gauss()?&gt;&lt;/b&gt;
</prog>

<par>Parsing this file and calling
<pyref module="ll.xist.xsc" class="Node" method="convert"><method>convert</method></pyref>
results in the following:</par>

<tty>
&lt;b&gt;5050&lt;/b&gt;
</tty>

</section>
