<?xml version='1.0' encoding='utf-8'?>
<spc:wrap xmlns="http://xmlns.livinglogic.de/xist/ns/doc" xmlns:spc="http://xmlns.livinglogic.de/xist/ns/specials">
<p>Apart from the <pyref module="ll.xist.xsc" class="Node" method="convert"><meth>convert</meth></pyref>
method, &xist; provides several tools for manipulating an &xml; tree.</p>


<section><h>The <meth>withsep</meth> method</h>

<p>The method <pyref module="ll.xist.xsc" class="Frag" method="withsep"><meth>withsep</meth></pyref>
can be used to put a separator node between the child nodes of an
<pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or a <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</p>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(range(10))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print(node.withsep(", ").string())</input>
<![CDATA[<div>0, 1, 2, 3, 4, 5, 6, 7, 8, 9</div>]]>
</tty>

</section>


<section><h>The <meth>shuffled</meth> method</h>

<p>The method <pyref module="ll.xist.xsc" class="Frag" method="shuffled"><meth>shuffled</meth></pyref>
returns a shuffled version of the <pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</p>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(range(10))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print(node.shuffled().withsep(", ").string())</input>
<![CDATA[<div>8, 1, 3, 6, 7, 5, 2, 9, 4, 0</div>]]>
</tty>

</section>


<section><h>The <meth>reversed</meth> method</h>

<p>The method <pyref module="ll.xist.xsc" class="Frag" method="reversed"><meth>reversed</meth></pyref>
returns a reversed version of an element or fragment:</p>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(range(10))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print(node.reversed().withsep(",").string())</input>
<![CDATA[<div>9,8,7,6,5,4,3,2,1,0</div>]]>
</tty>

</section>


<section><h>The <meth>mapped</meth> method</h>

<p>The method <pyref module="ll.xist.xsc" class="Node" method="mapped"><meth>mapped</meth></pyref>
recursively walks the tree and generates a new tree, where all the nodes are mapped
through a function. An example: To replace <lit>Python</lit> with <lit>Parrot</lit>
in every text node on the <a href="http://www.python.org/">Python page</a>, do the following:</p>

<prog>
from ll.xist import xsc, parse

def p2p(node, converter):
	if isinstance(node, xsc.Text):
		node = node.replace("Python", "Parrot")
		node = node.replace("python", "parrot")
	return node

node = parse.tree(parse.URL("http://www.python.org"), parse.Tidy(), parse.NS(html), parse.Node(pool=xsc.Pool(xml, html)))
node = node.mapped(p2p)
node.write(open("parrot_index.html", "wb"))
</prog>

<p>The function must either return a new node, in which case this
new node will be used instead of the old one, or return the
old node to tell <pyref module="ll.xist.xsc" class="Node" method="mapped"><meth>mapped</meth></pyref>
that it should recursively continue with the content of the node.</p>

</section>
</spc:wrap>
