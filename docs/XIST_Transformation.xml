<wrap>
<p>Apart from the <pyref module="ll.xist.xsc" class="Node" method="convert"><meth>convert</meth></pyref>
method, &xist; provides many tools for manipulating an &xml; tree.</p>


<section><h>The <meth>withsep</meth> method</h>

<p>The method <pyref module="ll.xist.xsc" class="Frag" method="withsep"><meth>withsep</meth></pyref>
can be used to put a seperator node between the child nodes of an
<pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or a <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</p>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(xrange(10))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.withsep(", ").bytes()</input>
&lt;div&gt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&lt;/div&gt;
</tty>

</section>


<section><h>The <meth>shuffled</meth> method</h>

<p>The method <pyref module="ll.xist.xsc" class="Frag" method="shuffled"><meth>shuffled</meth></pyref>
returns a shuffled version of the <pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</p>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(xrange(10))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.shuffled().withsep(", ").bytes()</input>
&lt;div&gt;8, 1, 3, 6, 7, 5, 2, 9, 4, 0&lt;/div&gt;
</tty>

</section>


<section><h>The <meth>reversed</meth> and <meth>sorted</meth> methods</h>

<p>There are methods named <pyref module="ll.xist.xsc" class="Frag" method="reversed"><meth>reversed</meth></pyref>
and <pyref module="ll.xist.xsc" class="Frag" method="sorted"><meth>sorted</meth></pyref> that
return a reversed or sorted version of an element or fragment:</p>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>def key(n):</input>
<prompt>... </prompt><input>	return unicode(n)</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(8,4,2,1,9,6,3,0,7,5)</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.sorted(key=key).reversed().withsep(",").bytes()</input>
&lt;div&gt;9,8,7,6,5,4,3,2,1,0&lt;/div&gt;
</tty>

</section>


<section><h>The <meth>mapped</meth> method</h>

<p>The method <pyref module="ll.xist.xsc" class="Node" method="mapped"><meth>mapped</meth></pyref>
recursively walks the tree and generates a new tree, where all the nodes are mapped
through a function. An example: To replace <lit>Python</lit> with <lit>Parrot</lit>
in every text node on the <a href="http://www.python.org/">Python page</a>, do the following:</p>

<prog>
from ll.xist import xsc, parsers

def p2p(node, converter):
	if isinstance(node, xsc.Text):
		node = node.replace(u"Python", u"Parrot")
		node = node.replace(u"python", u"parrot")
	return node

node = parsers.parseurl("http://www.python.org/", tidy=True)
node = node.mapped(p2p)
node.write(open("parrot_index.html", "wb"))
</prog>

<p>The function must either return a new node, in which case this
new node will be used instead of the old one, or return the
old node to tell <pyref module="ll.xist.xsc" class="Node" method="mapped"><meth>mapped</meth></pyref>
that it should recursively continue with the content of the node.</p>

</section>
</wrap>