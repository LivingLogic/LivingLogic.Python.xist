<section><title>Searching trees</title>

<par>There are two methods available for iterating through an &xml; tree and
finding nodes in the tree: The <method>walk</method> method and XFind
expressions.</par>

<section><title>The <method>walk</method> method</title>
<par>The method <pyref module="ll.xist.xsc" class="Node" method="walk"><method>walk</method></pyref>
is a generator. You pass a callable object to <method>walk</method>
which is used for determining which part of the tree should be searched and
which nodes should be returned.</par>

<par><module>ll.xist.xsc</module> provides several useful predefined classes for
specifying what should be returned from <method>walk</method>:
<pyref module="ll.xist.xsc" class="FindType"><class>FindType</class></pyref>
will search only the first level of the tree and will return any node that is an
instance of one of the classes passed to the constructor. So if you have an
instance of <class>ll.xist.ns.html.ul</class> named <lit>node</lit> you could
search for all <class>ll.xist.ns.html.li</class> elements inside with the
following code:</par>

<example><title>Searching for <class>li</class> inside <class>ul</class> with <method>walk</method></title>
<prog>
for cursor in node.content.walk(xsc.FindType(html.li)):
	print unicode(cursor.node)
</prog>
</example>

<par><pyref module="ll.xist.xsc" class="FindTypeAll"><class>FindTypeAll</class></pyref>
can be used when you want to search the complete tree. The following example
extracts all the links on the
<link href="http://www.python.org/">Python home page</link>:</par>

<example><title>Finding all links on the Python home page</title>
<prog>
from ll.xist import xsc, parsers
from ll.xist.ns import html

node = parsers.parseURL("http://www.python.org/", tidy=True)

for cursor in node.walk(xsc.FindTypeAll(html.a)):
	print cursor.node[u"href"]
</prog>
</example>

<par>This gives the output:</par>

<tty>
http://www.python.org/
http://www.python.org/search/
http://www.python.org/download/
http://www.python.org/doc/
http://www.python.org/Help.html
http://www.python.org/dev/
<rep>...</rep>
</tty>

<par>The following example will find all external links on the Python home
page:</par>

<example><title>Finding external links on the Python home page</title>
<prog>
from ll.xist import xsc, parsers
from ll.xist.ns import html

node = parsers.parseURL("http://www.python.org/", tidy=True)

def isextlink(cursor):
	if isinstance(cursor.node, html.a) and not unicode(cursor.node[u"href"]).startswith(u"http://www.python.org"):
		return (True, xsc.entercontent)
	return (xsc.entercontent,)

for cursor in node.walk(isextlink):
	print cursor.node[u"href"]
</prog>
</example>

<par>This gives the output:</par>

<tty>
http://www.jython.org/
http://sourceforge.net/tracker/?atid=105470&amp;group%5fid=5470
http://sourceforge.net/tracker/?atid=305470&amp;group%5fid=5470
http://sourceforge.net/cvs/?group%5fid=5470
http://www.python-in-business.org/
http://www.europython.org/
mailto:webmaster@python.org
<rep>...</rep>
</tty>

<par>The callable (<function>isextlink</function> in the example) will be called
for each node visited. The <arg>cursor</arg> argument has an attribute <lit>node</lit>
that is the node in question. For the other attributes see the
<pyref module="ll.xist.xsc" class="Cursor"><class>Cursor</class> class</pyref>.</par>

<par>The callable must return a sequence with the following entries:</par>

<dlist>
<term><lit>ll.xist.xsc.entercontent</lit></term><item>enter the content of this
element and continue searching;</item>
<term><lit>ll.xist.xsc.enterattrs</lit></term><item>enter the attributes of this
element and continue searching;</item>
<term>boolean value</term><item>If true, the node will be part of the result.</item>
</dlist>

<par>The sequence will be <z>executed</z> in the order you specify. To change
the top down traversal from our example to a bottom up traversal we could change
<function>isextlink</function> to the following (note the swapped tuple entries):</par>

<example><title>Bottom up link traversal function</title>
<prog>
def isextlink(node):
	if isinstance(node, html.a) and not unicode(node[u"href"]).startswith(u"http://www.python.org"):
		return <em>(xsc.entercontent, True)</em>
	return (xsc.entercontent,)
</prog>
</example>

<par>Note that the cursor yielded from <method>walk</method> will be reused by
subsequent <method>next</method> calls, so you should not modify the cursor and
you can't rely on attributes of the cursor after reentry to
<method>walk</method>.</par>

</section>

<section><title>XFind expressions</title>

<par>A second method exists for iterating through a tree: XFind expressions.
An XFind expression looks somewhat like an XPath expression, but is implemented
as a pure Python expression (overloading the division operators).</par>

<par>Our example from above that searched for <class>li</class>s inside
<class>ul</class>s can be rewritten as follows:</par>

<example><title>Searching for <class>li</class> inside <class>ul</class> with an XFind expression</title>
<prog>
for child in node/html.li:
	print unicode(child)
</prog>
</example>

<par>A XFind expression returns an iterator for certain parts of the &xml; tree.
In an XFind expression <lit><rep>a</rep>/<rep>b</rep></lit>,
<lit><rep>a</rep></lit> must be either a node or an iterator producing nodes
(note that an XFind expression itself is such an iterator, so
<lit><rep>a</rep></lit> itself might be a XFind expression).
<lit><rep>b</rep></lit> must be an XFind operator.</par>

<par>Every subclass of
<pyref module="ll.xist.xsc" class="Node"><class>ll.xist.xsc.Node</class></pyref>
is a XFind operator. If <lit><rep>b</rep></lit> is such a subclass,
<lit><rep>a</rep>/<rep>b</rep></lit> will produce any child nodes of the nodes
from <lit><rep>a</rep></lit> that is an instance of <lit><rep>b</rep></lit>.
If <lit><rep>b</rep></lit> is an attribute class, you will get attribute nodes
instead of child nodes. Other XFind operators can be found in the module
<pyref module="ll.xist.xfind"><module>ll.xist.xfind</module></pyref>. The
<lit>all</lit> operator will produce every node in the tree (except for
attributes):</par>

<prog>
from ll.xist import xfind
from ll.xist.ns import html

node = html.div(
	html.div(
		html.div(id=3),
		html.div(id=4),
		id=2,
	),
	html.div(
		html.div(id=6),
		html.div(id=7),
		id=5,
	),
	id=1
)

for child in node/xfind.all:
	print child["id"]
</prog>

<par>The output of this is:</par>

<tty>
1
2
3
4
5
6
7
</tty>

<par>The following example demonstrates how to find all links on the Python
homepage via an XFind expression:</par>

<prog>
from ll.xist import xfind, parsers
from ll.xist.ns import html

node = parsers.parseURL("http://www.python.org/", tidy=True)
for link in node/xfind.all/html.a:
	print link["href"]
</prog>

<par>An <lit>all</lit> operator in the middle of an XFind expression can be
abbreviated. The XFind expression from the last example
(<lit>node/xfind.all/html.a</lit>) can be rewritten like this:
<lit>node//html.a</lit>.</par>

<par>Another XFind operator is
<pyref module="ll.xist.xfind" class="contains"><class>contains</class></pyref>.
It acts as a filter, i.e. the nodes produced by
<lit><rep>a</rep>/xfind.contains(<rep>b</rep>)</lit> are a subset of the nodes
produced by <lit><rep>a</rep></lit>, those that contain child nodes of type
<lit>b</lit>. Searching for all links on the Python home page that contain
images can be done like this:</par>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xfind, parsers</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = parsers.parseURL("http://www.python.org/", tidy=True)</input>
<prompt>&gt;&gt;&gt; </prompt><input>for link in node//html.a/xfind.contains(html.img):</input>
<prompt>... </prompt><input>	print link["href"]</input>
<prompt>... </prompt><input></input>
http://www.python.org/
http://www.python.org/psf/donations.html
http://www.opensource.org/
</tty>

<par>Note that using the <lit>all</lit> operator twice in an XFind expression
currently won't give you the expected result, as nodes might be produced twice.</par>

<par>Calling <method>__getitem__</method> on an XFind operator gives you an
item operator. Such an item operator only returns a specific item (or slice) of
those nodes returned by the base iterator. An example:</par>

<prog>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>e = html.table(html.tr(html.td(j) for j in xrange(i, i+3)) for i in xrange(1, 10, 3))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print e.pretty().bytes()</input>
&lt;table&gt;
	&lt;tr&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;2&lt;/td&gt;
		&lt;td&gt;3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;4&lt;/td&gt;
		&lt;td&gt;5&lt;/td&gt;
		&lt;td&gt;6&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;7&lt;/td&gt;
		&lt;td&gt;8&lt;/td&gt;
		&lt;td&gt;9&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
<prompt>&gt;&gt;&gt; </prompt><input># Every cell</input>
<prompt>&gt;&gt;&gt; </prompt><input>for td in e/html.tr/html.td:</input>
<prompt>... </prompt><input>	print td</input>
<prompt>... </prompt><input></input>
1
2
3
4
5
6
7
8
9
<prompt>&gt;&gt;&gt; </prompt><input># Every first cell in each row</input>
<prompt>&gt;&gt;&gt; </prompt><input>for td in e/html.tr/html.td[0]:</input>
<prompt>... </prompt><input>	print td</input>
1
4
7
<prompt>&gt;&gt;&gt; </prompt><input># Every cell in the first row</input>
<prompt>&gt;&gt;&gt; </prompt><input>for td in e/html.tr[0]/html.td:</input>
<prompt>... </prompt><input>	print td</input>
1
2
3
<prompt>&gt;&gt;&gt; </prompt><input># The first of all cells</input>
<prompt>&gt;&gt;&gt; </prompt><input>for td in e/(html.tr/html.td)[0]:</input>
<prompt>... </prompt><input>	print td</input>
1
</prog>

</section>

</section>
