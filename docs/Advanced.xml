<section><title>Converter contexts</title>

<par>Converter contexts can be used to pass around information in recursive
calls to the <method>convert</method> and <method>mapped</method> methods.
A <pyref module="ll.xist.converters" class="Converter"><class>Converter</class></pyref>
object will be passed in all calls, so this object is the place to store
information. However if each element, procinst and entity class decided on its
own which attributes names to use, name collisions would be inevitale. To avoid
this, the following system is used.</par>

<par>When a class wants to store information in a converter, it has to define
a <class>Context</class> class (normally derived from the <class>Context</class>
class of its base class). The constructor must initialize the context object
to a initial state. You can get the context object for a certain class by treating
the converter as a dictionary with the class (or an instance) as the key like this:</par>

<example><title>Defining and using a converter context</title>
<prog>
from ll.xist import xsc

class counter(xsc.Element):
	class Context(xsc.Element.Context):
		def __init__(self):
			xsc.Element.Context.__init__(self)
			self.count = 0

	def convert(self, converter):
		context = converter[self]
		node = xsc.Text(context.count)
		context.count += 1
		return node
</prog>
</example>

</section>


<section><title>Chaining pool and extending namespaces</title>

<par>When using <pyref module="ll.xist.xsc" class="Pool">pools</pyref> it's
possible to do some sort of <z>namespace subclassing</z>.</par>

<par>Registering a module in a pool not only registers the element, procinst and
entity classes in the pool for parsing, but each attribute of the module (as
long as it's weak referencable) is available as an attribute of the pool
itself:</par>

<example><title>Pool attributes</title>
<prog>
from ll.xist import xsc
from ll.xist.ns import html

pool = xsc.Pool(html)
print pool.img
</prog>
</example>

<par>This outputs <lit><![CDATA[<element class ll.xist.ns.html:img at 0x3eed00>]]></lit>.</par>

<par>It's possible to chain pools together. When an attribute isn't found in
the first pool, it will be looked up in a second pool (the so called base
pool):</par>

<example><title>Pool chaining</title>
<prog>
from ll.xist import xsc
from ll.xist.ns import html, svg

hpool = xsc.Pool(html)
spool = xsc.Pool(svg, hpool)
print spool.img
</prog>
</example>

<par>Here the <lit>hpool</lit> (containing the <module>html</module> namespace)
will be used, when the attribute can't be found in <lit>spool</lit>. So this
will again give the output
<lit><![CDATA[<element class ll.xist.ns.html:img at 0x3eed00>]]></lit>.</par>

<par>It's possible to get automatic pool chaining. If a module has an attribute
<lit>__bases__</lit> (which must be a sequence of modules), they will
automatically be wrapped in a pool and used as the base pools for the pool
created for the first module. This makes it possible to <z>overwrite</z> element
classes in existing namespaces. For example to replace the <class>a</class>
class in <module>ll.xist.ns.html</module>, put the following into a module
<module>html2</module>:</par>

<example><title>Automatic pool chaining (<filename>html2.py</filename>)</title>
<prog>
from ll.xist.ns import html

__bases__ = [html]

class a(html.a):
	xmlns = html.xmlns

	def convert(self, converter):
		e = html.a(self.content, self.attrs, target="_top")
		return e.convert(converter)
</prog>
</example>

<par>Now you can use the module in a pool:</par>

<example><title>Using a pool chain</title>
<prog>
from ll.xist import xsc
import html2

pool = xsc.Pool(html2)
print pool.a, pool.b
</prog>
</example>

<par>This outputs:</par>
<tty><![CDATA[
<element class html2:a at 0x113ec40> <element class ll.xist.ns.html:b at 0x1101fe0>
]]></tty>

<par>Note that such a chained pool can of course used when parsing &xml;. The
parser will recursively search for the first class that has the appropriate
name when instantiating the tree nodes.</par>

</section>


<!--
<par>Each element class that belongs to a namespace can access its
namespace via the class attribute <lit>__ns__</lit>. When you're subclassing
namespace classes, the elements in the base namespace will be automatically
subclassed too. Of course you can explicitly subclass an element class too.
The following example shows the usefulness of this feature. Define your base
namespace like this and put it into <filename>navns.py</filename>:</par>

<prog>
from ll.xist import xsc
from ll.xist.ns import html

languages = [
	(u"Python", u"http://www.python.org/"),
	(u"Perl", u"http://www.perl.org/"),
	(u"PHP", u"http://www.php.net/"),
	(u"Java", u"http://java.sun.com/")
]

class navigation(xsc.Element):
	def convert(self, converter):
		node = self.__ns__.links()
		for (name, url) in languages:
			node.append(self.__ns__.link(name, href=url))
		return node.convert(converter)

class links(xsc.Element):
	def convert(self, converter):
		node = self.content
		return node.convert(converter)

class link(xsc.Element):
	class Attrs(xsc.Element.Attrs):
		class href(xsc.URLAttr): pass

	def convert(self, converter):
		node = html.div(html.a(self.content, href=self[u"href"]))
		return node.convert(converter)

class __ns__(xsc.Namespace):
	xmlname = "nav"
	xmlurl = "http://www.example.com/nav"
__ns__.makemod(vars())
</prog>

<par>This namespace defines a navigation element that generates <class>div</class>s
with links to various homepages for programming languages. We can use it like this:</par>
<tty>
<prompt>&gt;&gt;&gt; </prompt><input>import navns</input>
<prompt>&gt;&gt;&gt; </prompt><input>print navns.navigation().conv().bytes()</input>
&lt;div&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href="http://www.perl.org/"&gt;Perl&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href="http://www.php.net/"&gt;PHP&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href="http://java.sun.com/"&gt;Java&lt;/a&gt;&lt;/div&gt;
</tty>
<par>(Of course the output will all be on one line.)</par>

<par>Now we can define a derived namespace (in the file <filename>nav2ns.py</filename>)
that overwrites the element classes <class>links</class> and <class>link</class>
to change how the navigation looks:</par>

<prog>
from ll.xist import xsc
from ll.xist.ns import html

import navns

class __ns__(navns):
	class links(navns.links):
		def convert(self, converter):
			node = html.table(
				self.content,
				border=0,
				cellpadding=0,
				cellspacing=0,
				class_=u"navigation",
			)
			return node.convert(converter)

	class link(navns.link):
		def convert(self, converter):
			node = html.tr(
				html.td(
					html.a(
						self.content,
						href=self[u"href"],
					)
				)
			)
			return node.convert(converter)
__ns__.makemod(vars())
</prog>

<par>When we use the navigation element from the derived namespace we'll get
the following output:</par>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>import nav2ns</input>
<prompt>&gt;&gt;&gt; </prompt><input>print nav2ns.navigation().conv().bytes()</input>
&lt;table border="0" cellpadding="0" cellspacing="0" class="navigation"&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.perl.org/"&gt;Perl&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://www.php.net/"&gt;PHP&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href="http://java.sun.com/"&gt;Java&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</tty>
<par>(again all on one line.)</par>

<par>Notice that we automatically got an element class <class>nav2ns.navigation</class>,
that this element class inherited the <method>convert</method> method from its
base class and that the call to <method>convert</method> on the derived class
did instantiate the link classes from the derived namespace.</par>

</section>


<section><title>Namespaces as conversion targets</title>

<par>The <arg>converter</arg> argument passed to the <method>convert</method> method
has an attribute <lit>target</lit> which is a namespace class and specifies the target
namespace to which <self/> should be converted.</par>

<par>You can check which conversion is wanted with <function>issubclass</function>.
Once this is determined you can use element classes from the target to create the
required &xml; object tree. This makes it possible to customize the conversion by
passing a derived namespace to the <method>convert</method> method. To demonstrate
this, we change our example namespace to use the conversion target like this:</par>

<prog>
import navns

class __ns__(navns):
	class links(navns.links):
		def convert(self, converter):
			node = converter.target.table(
				self.content,
				border=0,
				cellpadding=0,
				cellspacing=0,
				class_=u"navigation",
			)
			return node.convert(converter)

	class link(navns.link):
		def convert(self, converter):
			target = converter.target
			node = target.tr(
				target.td(
					target.a(
						self.content,
						href=self[u"href"],
					)
				)
			)
			return node.convert(converter)
</prog>

<par>What we might want to do is have all links (i.e. all <class>ll.xist.ns.html.a</class>
elements) generated with an attribute <lit>target="_top"</lit>. For this we derive
a new namespace from <class>ll.xist.ns.html</class> and overwrite the <class>a</class>
element:</par>

<prog>
from ll.xist.ns import html

class __ns__(html):
	class a(html.a):
		def convert(self, converter):
			node = html.a(self.content, self.attrs, target=u"_top")
			return node.convert(converter)
</prog>

<par>Now we can pass this namespace as the conversion target and all links
will have a <lit>target="_top"</lit>.</par>
</section>
-->

<section><title>Validation and content models</title>

<par>When generating &html; you might want to make sure that your generated
code doesn't contain any illegal tag nesting (i.e. something bad like
<markup>&lt;p&gt;&lt;p&gt;foo&lt;/p&gt;&lt;/p&gt;</markup>). The module
<module>ll.xist.ns.html</module> does this automatically:</par>

<example>
<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.p(html.p(u"foo"))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.bytes()</input>
/Users/walter/checkouts/LivingLogic.Python.xist/src/ll/xist/sims.py:222: WrongElementWarning: element &lt;ll.xist.ns.html.p element object (1 child/no attrs) at 0x270b30&gt; may not contain element &lt;ll.xist.ns.html.p element object (1 child/no attrs) at 0x69850&gt;
  warnings.warn(WrongElementWarning(node, child, self.elements))
&lt;p&gt;&lt;p&gt;foo&lt;/p&gt;&lt;/p&gt;
</tty>
</example>

<par>For your own elements you can specify the content model too. This is done
by setting the class attribute <lit>model</lit> inside the element class.
<lit>model</lit> must be an object that provides a <method>checkvalid</method>
method. This method will be called during parsing or publishing with the element
as an argument. When invalid content is detected, the Python warning framework
should be used to issue a warning.</par>

<par>The module <module>ll.xist.sims</module> contains several classes that
provide simple validation methods:
<pyref module="ll.xist.sims" class="Empty"><class>Empty</class></pyref>
can be used to ensure that the element doesn't have any content (like
<markup>br</markup> and <markup>img</markup> in &html;).
<pyref module="ll.xist.sims" class="Any"><class>Any</class></pyref>
does allow any content.
<pyref module="ll.xist.sims" class="NoElements"><class>NoElements</class></pyref>
will warn about elements from the same namespace (elements from other namespaces
will be OK).
<pyref module="ll.xist.sims" class="NoElementsOrText"><class>NoElementsOrText</class></pyref>
will warn about elements from the same namespace and non-whitespace text content.
<pyref module="ll.xist.sims" class="Elements"><class>Elements</class></pyref>
will only allow the elements specified in the constructor.
<pyref module="ll.xist.sims" class="ElementsOrText"><class>ElementsOrText</class></pyref>
will only allow the elements specified in the constructor and text.</par>

<par>None of these classes will check the number of child elements or their
order.</par>

<par>For more info see the <pyref module="ll.xist.sims"><module>sims</module></pyref>
module.</par>
</section>
