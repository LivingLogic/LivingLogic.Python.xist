<section><title>Manipulating trees</title>
<par>&xist; provides many methods for manipulating an &xml; tree.</par>

<par>The method <pyref module="ll.xist.xsc" class="Frag" method="withsep"><method>withsep</method></pyref>
can be used to put a seperator node between the child nodes of an
<pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or a <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</par>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(*xrange(10))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.withsep(", ").bytes()</input>
&lt;div&gt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&lt;/div&gt;
</tty>

<par>The method <pyref module="ll.xist.xsc" class="Frag" method="shuffled"><method>shuffled</method></pyref>
returns a shuffled version of the <pyref module="ll.xist.xsc" class="Element"><class>Element</class></pyref>
or <pyref module="ll.xist.xsc" class="Frag"><class>Frag</class></pyref>:</par>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(*xrange(10))</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.shuffled().withsep(", ").bytes()</input>
&lt;div&gt;8, 1, 3, 6, 7, 5, 2, 9, 4, 0&lt;/div&gt;
</tty>

<par>There are methods named <pyref module="ll.xist.xsc" class="Frag" method="reversed"><method>reversed</method></pyref>
and <pyref module="ll.xist.xsc" class="Frag" method="sorted"><method>sorted</method></pyref> that
return a reversed or sorted version of an element or fragment:</par>

<tty>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist import xsc</input>
<prompt>&gt;&gt;&gt; </prompt><input>from ll.xist.ns import html</input>
<prompt>&gt;&gt;&gt; </prompt><input>def key(n):</input>
<prompt>... </prompt><input>   return unicode(n)</input>
<prompt>&gt;&gt;&gt; </prompt><input>node = html.div(8,4,2,1,9,6,3,0,7,5)</input>
<prompt>&gt;&gt;&gt; </prompt><input>print node.sorted(key=key).reversed().withsep(",").bytes()</input>
&lt;div&gt;9,8,7,6,5,4,3,2,1,0&lt;/div&gt;
</tty>

<par>The method <pyref module="ll.xist.xsc" class="Node" method="mapped"><method>mapped</method></pyref>
recursively walks the tree and generates a new tree, where all the nodes are mapped
through a function. An example: To replace <lit>Python</lit> with <lit>Parrot</lit>
in every text node on the <link href="http://www.python.org/">Python page</link>, do the following:</par>

<prog>
from ll.xist import xsc, parsers

def p2p(node, converter):
	if isinstance(node, xsc.Text):
		node = node.replace(u"Python", u"Parrot")
		node = node.replace(u"python", u"parrot")
	return node

node = parsers.parseURL("http://www.python.org/", tidy=True)
node = node.mapped(p2p)
node.write(open("parrot_index.html", "wb"))
</prog>

<par>The function must either return a new node, in which case this
new node will be used instead of the old one, or return the
old node to tell <pyref module="ll.xist.xsc" class="Node" method="mapped"><method>mapped</method></pyref>
that it should recursively continue with the content of the node.</par>
</section>
