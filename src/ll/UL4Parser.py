# Generated from src/ll/UL4Parser.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3b")
        buf.write("\u03c8\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\3\2\5\2f\n\2\3\2\7")
        buf.write("\2i\n\2\f\2\16\2l\13\2\3\2\3\2\3\3\3\3\7\3r\n\3\f\3\16")
        buf.write("\3u\13\3\3\3\3\3\7\3y\n\3\f\3\16\3|\13\3\3\3\5\3\177\n")
        buf.write("\3\3\3\5\3\u0082\n\3\3\3\3\3\3\4\3\4\7\4\u0088\n\4\f\4")
        buf.write("\16\4\u008b\13\4\3\4\3\4\7\4\u008f\n\4\f\4\16\4\u0092")
        buf.write("\13\4\3\4\3\4\7\4\u0096\n\4\f\4\16\4\u0099\13\4\3\4\3")
        buf.write("\4\3\5\3\5\7\5\u009f\n\5\f\5\16\5\u00a2\13\5\3\5\3\5\7")
        buf.write("\5\u00a6\n\5\f\5\16\5\u00a9\13\5\3\5\5\5\u00ac\n\5\3\5")
        buf.write("\7\5\u00af\n\5\f\5\16\5\u00b2\13\5\3\5\3\5\3\6\3\6\7\6")
        buf.write("\u00b8\n\6\f\6\16\6\u00bb\13\6\3\6\3\6\7\6\u00bf\n\6\f")
        buf.write("\6\16\6\u00c2\13\6\3\6\5\6\u00c5\n\6\3\6\5\6\u00c8\n\6")
        buf.write("\3\6\3\6\3\7\3\7\3\7\7\7\u00cf\n\7\f\7\16\7\u00d2\13\7")
        buf.write("\3\7\5\7\u00d5\n\7\3\b\6\b\u00d8\n\b\r\b\16\b\u00d9\3")
        buf.write("\t\6\t\u00dd\n\t\r\t\16\t\u00de\3\t\6\t\u00e2\n\t\r\t")
        buf.write("\16\t\u00e3\5\t\u00e6\n\t\3\n\3\n\3\13\3\13\3\f\3\f\3")
        buf.write("\r\3\r\5\r\u00f0\n\r\3\16\3\16\3\17\3\17\3\20\3\20\5\20")
        buf.write("\u00f8\n\20\3\21\3\21\3\22\3\22\3\23\3\23\3\24\3\24\3")
        buf.write("\24\3\24\3\24\3\24\3\24\3\24\5\24\u0108\n\24\3\25\3\25")
        buf.write("\3\25\5\25\u010d\n\25\3\26\3\26\3\26\3\26\3\26\3\26\7")
        buf.write("\26\u0115\n\26\f\26\16\26\u0118\13\26\3\26\5\26\u011b")
        buf.write("\n\26\3\26\3\26\5\26\u011f\n\26\3\27\3\27\3\27\3\27\3")
        buf.write("\27\3\27\3\27\3\27\5\27\u0129\n\27\3\27\3\27\3\30\3\30")
        buf.write("\3\30\3\30\3\30\3\30\3\30\7\30\u0134\n\30\f\30\16\30\u0137")
        buf.write("\13\30\3\30\5\30\u013a\n\30\3\30\3\30\5\30\u013e\n\30")
        buf.write("\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\5\31\u0148\n")
        buf.write("\31\3\31\3\31\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u0152")
        buf.write("\n\32\3\33\3\33\3\33\3\33\3\33\3\33\7\33\u015a\n\33\f")
        buf.write("\33\16\33\u015d\13\33\3\33\5\33\u0160\n\33\3\33\3\33\5")
        buf.write("\33\u0164\n\33\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34")
        buf.write("\3\34\3\34\5\34\u0170\n\34\3\34\3\34\3\35\3\35\3\35\3")
        buf.write("\35\3\35\3\35\3\35\5\35\u017b\n\35\3\36\3\36\3\36\3\36")
        buf.write("\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write("\3\36\5\36\u018d\n\36\3\37\3\37\3\37\3\37\3\37\3\37\3")
        buf.write("\37\3\37\3\37\3\37\3\37\3\37\7\37\u019b\n\37\f\37\16\37")
        buf.write("\u019e\13\37\3\37\5\37\u01a1\n\37\3\37\3\37\5\37\u01a5")
        buf.write("\n\37\3 \5 \u01a8\n \3 \3 \5 \u01ac\n \3!\3!\3!\3!\3!")
        buf.write("\3!\3!\3!\3!\5!\u01b7\n!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\5\"\u01c1\n\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\7\"\u0218\n\"\f\"\16")
        buf.write("\"\u021b\13\"\3\"\5\"\u021e\n\"\7\"\u0220\n\"\f\"\16\"")
        buf.write("\u0223\13\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\7\"\u0230\n\"\f\"\16\"\u0233\13\"\3#\3#\5#\u0237\n")
        buf.write("#\3$\3$\3$\3$\3$\3$\5$\u023f\n$\3%\3%\3%\3%\3%\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\5&\u0285\n&\3\'\3\'\3\'\3\'\3\'\3")
        buf.write("\'\5\'\u028d\n\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u0297")
        buf.write("\n\'\3\'\5\'\u029a\n\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'")
        buf.write("\3\'\3\'\3\'\7\'\u02a7\n\'\f\'\16\'\u02aa\13\'\3\'\3\'")
        buf.write("\3\'\5\'\u02af\n\'\3\'\3\'\3\'\5\'\u02b4\n\'\3\'\5\'\u02b7")
        buf.write("\n\'\3\'\3\'\3\'\3\'\3\'\3\'\7\'\u02bf\n\'\f\'\16\'\u02c2")
        buf.write("\13\'\3\'\3\'\3\'\3\'\3\'\7\'\u02c9\n\'\f\'\16\'\u02cc")
        buf.write("\13\'\3\'\3\'\3\'\5\'\u02d1\n\'\3\'\3\'\3\'\5\'\u02d6")
        buf.write("\n\'\3\'\5\'\u02d9\n\'\3\'\3\'\5\'\u02dd\n\'\3(\5(\u02e0")
        buf.write("\n(\3(\5(\u02e3\n(\3)\3)\3)\3)\3)\7)\u02ea\n)\f)\16)\u02ed")
        buf.write("\13)\3)\3)\3)\5)\u02f2\n)\3)\3)\3*\3*\3*\3*\3*\3*\3*\7")
        buf.write("*\u02fd\n*\f*\16*\u0300\13*\3*\3*\3*\5*\u0305\n*\3*\3")
        buf.write("*\3+\3+\3+\3+\3+\7+\u030e\n+\f+\16+\u0311\13+\3+\3+\3")
        buf.write("+\5+\u0316\n+\3+\3+\3,\3,\3,\3,\3,\7,\u031f\n,\f,\16,")
        buf.write("\u0322\13,\3,\3,\3,\3,\3,\7,\u0329\n,\f,\16,\u032c\13")
        buf.write(",\7,\u032e\n,\f,\16,\u0331\13,\3,\3,\3,\3,\7,\u0337\n")
        buf.write(",\f,\16,\u033a\13,\3,\3,\3,\5,\u033f\n,\3,\3,\3-\3-\3")
        buf.write("-\3-\3-\3-\3-\7-\u034a\n-\f-\16-\u034d\13-\3-\5-\u0350")
        buf.write("\n-\7-\u0352\n-\f-\16-\u0355\13-\3-\3-\3-\7-\u035a\n-")
        buf.write("\f-\16-\u035d\13-\3-\3-\3-\5-\u0362\n-\3-\3-\3.\3.\3.")
        buf.write("\3.\3.\3.\3.\7.\u036d\n.\f.\16.\u0370\13.\3.\5.\u0373")
        buf.write("\n.\7.\u0375\n.\f.\16.\u0378\13.\3.\3.\3.\7.\u037d\n.")
        buf.write("\f.\16.\u0380\13.\3.\3.\3.\5.\u0385\n.\3.\3.\3/\3/\7/")
        buf.write("\u038b\n/\f/\16/\u038e\13/\3/\3/\7/\u0392\n/\f/\16/\u0395")
        buf.write("\13/\3/\3/\7/\u0399\n/\f/\16/\u039c\13/\3/\3/\3\60\3\60")
        buf.write("\7\60\u03a2\n\60\f\60\16\60\u03a5\13\60\3\60\3\60\7\60")
        buf.write("\u03a9\n\60\f\60\16\60\u03ac\13\60\3\60\3\60\7\60\u03b0")
        buf.write("\n\60\f\60\16\60\u03b3\13\60\3\60\3\60\3\61\3\61\3\61")
        buf.write("\3\61\3\61\3\61\3\61\3\61\3\61\5\61\u03c0\n\61\3\62\3")
        buf.write("\62\3\62\3\62\5\62\u03c6\n\62\3\62\2\3B\63\2\4\6\b\n\f")
        buf.write("\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@")
        buf.write("BDFHJLNPRTVXZ\\^`b\2\5\4\2\5\5\7\7\3\2  \4\2\4\4\b\b\2")
        buf.write("\u043f\2e\3\2\2\2\4o\3\2\2\2\6\u0085\3\2\2\2\b\u009c\3")
        buf.write("\2\2\2\n\u00b5\3\2\2\2\f\u00d4\3\2\2\2\16\u00d7\3\2\2")
        buf.write("\2\20\u00e5\3\2\2\2\22\u00e7\3\2\2\2\24\u00e9\3\2\2\2")
        buf.write("\26\u00eb\3\2\2\2\30\u00ef\3\2\2\2\32\u00f1\3\2\2\2\34")
        buf.write("\u00f3\3\2\2\2\36\u00f7\3\2\2\2 \u00f9\3\2\2\2\"\u00fb")
        buf.write("\3\2\2\2$\u00fd\3\2\2\2&\u0107\3\2\2\2(\u010c\3\2\2\2")
        buf.write("*\u011e\3\2\2\2,\u0120\3\2\2\2.\u013d\3\2\2\2\60\u013f")
        buf.write("\3\2\2\2\62\u0151\3\2\2\2\64\u0163\3\2\2\2\66\u0165\3")
        buf.write("\2\2\28\u0173\3\2\2\2:\u018c\3\2\2\2<\u01a4\3\2\2\2>\u01a7")
        buf.write("\3\2\2\2@\u01b6\3\2\2\2B\u01c0\3\2\2\2D\u0236\3\2\2\2")
        buf.write("F\u023e\3\2\2\2H\u0240\3\2\2\2J\u0284\3\2\2\2L\u02dc\3")
        buf.write("\2\2\2N\u02df\3\2\2\2P\u02e4\3\2\2\2R\u02f5\3\2\2\2T\u0308")
        buf.write("\3\2\2\2V\u0319\3\2\2\2X\u0342\3\2\2\2Z\u0365\3\2\2\2")
        buf.write("\\\u0388\3\2\2\2^\u039f\3\2\2\2`\u03bf\3\2\2\2b\u03c5")
        buf.write("\3\2\2\2df\5\4\3\2ed\3\2\2\2ef\3\2\2\2fj\3\2\2\2gi\5b")
        buf.write("\62\2hg\3\2\2\2il\3\2\2\2jh\3\2\2\2jk\3\2\2\2km\3\2\2")
        buf.write("\2lj\3\2\2\2mn\7\2\2\3n\3\3\2\2\2os\t\2\2\2pr\7\n\2\2")
        buf.write("qp\3\2\2\2ru\3\2\2\2sq\3\2\2\2st\3\2\2\2tv\3\2\2\2us\3")
        buf.write("\2\2\2vz\7\16\2\2wy\7\n\2\2xw\3\2\2\2y|\3\2\2\2zx\3\2")
        buf.write("\2\2z{\3\2\2\2{~\3\2\2\2|z\3\2\2\2}\177\5\24\13\2~}\3")
        buf.write("\2\2\2~\177\3\2\2\2\177\u0081\3\2\2\2\u0080\u0082\5L\'")
        buf.write("\2\u0081\u0080\3\2\2\2\u0081\u0082\3\2\2\2\u0082\u0083")
        buf.write("\3\2\2\2\u0083\u0084\7\"\2\2\u0084\5\3\2\2\2\u0085\u0089")
        buf.write("\t\2\2\2\u0086\u0088\7\n\2\2\u0087\u0086\3\2\2\2\u0088")
        buf.write("\u008b\3\2\2\2\u0089\u0087\3\2\2\2\u0089\u008a\3\2\2\2")
        buf.write("\u008a\u008c\3\2\2\2\u008b\u0089\3\2\2\2\u008c\u0090\7")
        buf.write("\13\2\2\u008d\u008f\7\35\2\2\u008e\u008d\3\2\2\2\u008f")
        buf.write("\u0092\3\2\2\2\u0090\u008e\3\2\2\2\u0090\u0091\3\2\2\2")
        buf.write("\u0091\u0093\3\2\2\2\u0092\u0090\3\2\2\2\u0093\u0097\7")
        buf.write("\34\2\2\u0094\u0096\7\35\2\2\u0095\u0094\3\2\2\2\u0096")
        buf.write("\u0099\3\2\2\2\u0097\u0095\3\2\2\2\u0097\u0098\3\2\2\2")
        buf.write("\u0098\u009a\3\2\2\2\u0099\u0097\3\2\2\2\u009a\u009b\7")
        buf.write("\36\2\2\u009b\7\3\2\2\2\u009c\u00a0\t\2\2\2\u009d\u009f")
        buf.write("\7\n\2\2\u009e\u009d\3\2\2\2\u009f\u00a2\3\2\2\2\u00a0")
        buf.write("\u009e\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1\u00a3\3\2\2\2")
        buf.write("\u00a2\u00a0\3\2\2\2\u00a3\u00a7\7\f\2\2\u00a4\u00a6\7")
        buf.write("\n\2\2\u00a5\u00a4\3\2\2\2\u00a6\u00a9\3\2\2\2\u00a7\u00a5")
        buf.write("\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00ab\3\2\2\2\u00a9")
        buf.write("\u00a7\3\2\2\2\u00aa\u00ac\5\f\7\2\u00ab\u00aa\3\2\2\2")
        buf.write("\u00ab\u00ac\3\2\2\2\u00ac\u00b0\3\2\2\2\u00ad\u00af\7")
        buf.write(" \2\2\u00ae\u00ad\3\2\2\2\u00af\u00b2\3\2\2\2\u00b0\u00ae")
        buf.write("\3\2\2\2\u00b0\u00b1\3\2\2\2\u00b1\u00b3\3\2\2\2\u00b2")
        buf.write("\u00b0\3\2\2\2\u00b3\u00b4\7!\2\2\u00b4\t\3\2\2\2\u00b5")
        buf.write("\u00b9\t\2\2\2\u00b6\u00b8\7\n\2\2\u00b7\u00b6\3\2\2\2")
        buf.write("\u00b8\u00bb\3\2\2\2\u00b9\u00b7\3\2\2\2\u00b9\u00ba\3")
        buf.write("\2\2\2\u00ba\u00bc\3\2\2\2\u00bb\u00b9\3\2\2\2\u00bc\u00c0")
        buf.write("\7\r\2\2\u00bd\u00bf\7\n\2\2\u00be\u00bd\3\2\2\2\u00bf")
        buf.write("\u00c2\3\2\2\2\u00c0\u00be\3\2\2\2\u00c0\u00c1\3\2\2\2")
        buf.write("\u00c1\u00c4\3\2\2\2\u00c2\u00c0\3\2\2\2\u00c3\u00c5\5")
        buf.write("\f\7\2\u00c4\u00c3\3\2\2\2\u00c4\u00c5\3\2\2\2\u00c5\u00c7")
        buf.write("\3\2\2\2\u00c6\u00c8\7 \2\2\u00c7\u00c6\3\2\2\2\u00c7")
        buf.write("\u00c8\3\2\2\2\u00c8\u00c9\3\2\2\2\u00c9\u00ca\7!\2\2")
        buf.write("\u00ca\13\3\2\2\2\u00cb\u00d5\n\3\2\2\u00cc\u00d0\n\3")
        buf.write("\2\2\u00cd\u00cf\7\37\2\2\u00ce\u00cd\3\2\2\2\u00cf\u00d2")
        buf.write("\3\2\2\2\u00d0\u00ce\3\2\2\2\u00d0\u00d1\3\2\2\2\u00d1")
        buf.write("\u00d3\3\2\2\2\u00d2\u00d0\3\2\2\2\u00d3\u00d5\n\3\2\2")
        buf.write("\u00d4\u00cb\3\2\2\2\u00d4\u00cc\3\2\2\2\u00d5\r\3\2\2")
        buf.write("\2\u00d6\u00d8\7\3\2\2\u00d7\u00d6\3\2\2\2\u00d8\u00d9")
        buf.write("\3\2\2\2\u00d9\u00d7\3\2\2\2\u00d9\u00da\3\2\2\2\u00da")
        buf.write("\17\3\2\2\2\u00db\u00dd\7\6\2\2\u00dc\u00db\3\2\2\2\u00dd")
        buf.write("\u00de\3\2\2\2\u00de\u00dc\3\2\2\2\u00de\u00df\3\2\2\2")
        buf.write("\u00df\u00e6\3\2\2\2\u00e0\u00e2\7\t\2\2\u00e1\u00e0\3")
        buf.write("\2\2\2\u00e2\u00e3\3\2\2\2\u00e3\u00e1\3\2\2\2\u00e3\u00e4")
        buf.write("\3\2\2\2\u00e4\u00e6\3\2\2\2\u00e5\u00dc\3\2\2\2\u00e5")
        buf.write("\u00e1\3\2\2\2\u00e6\21\3\2\2\2\u00e7\u00e8\t\4\2\2\u00e8")
        buf.write("\23\3\2\2\2\u00e9\u00ea\7Z\2\2\u00ea\25\3\2\2\2\u00eb")
        buf.write("\u00ec\7+\2\2\u00ec\27\3\2\2\2\u00ed\u00f0\7-\2\2\u00ee")
        buf.write("\u00f0\7,\2\2\u00ef\u00ed\3\2\2\2\u00ef\u00ee\3\2\2\2")
        buf.write("\u00f0\31\3\2\2\2\u00f1\u00f2\7[\2\2\u00f2\33\3\2\2\2")
        buf.write("\u00f3\u00f4\7\\\2\2\u00f4\35\3\2\2\2\u00f5\u00f8\7a\2")
        buf.write("\2\u00f6\u00f8\7b\2\2\u00f7\u00f5\3\2\2\2\u00f7\u00f6")
        buf.write("\3\2\2\2\u00f8\37\3\2\2\2\u00f9\u00fa\7]\2\2\u00fa!\3")
        buf.write("\2\2\2\u00fb\u00fc\7]\2\2\u00fc#\3\2\2\2\u00fd\u00fe\7")
        buf.write("_\2\2\u00fe%\3\2\2\2\u00ff\u0108\5\26\f\2\u0100\u0108")
        buf.write("\5\30\r\2\u0101\u0108\5\32\16\2\u0102\u0108\5\34\17\2")
        buf.write("\u0103\u0108\5\36\20\2\u0104\u0108\5 \21\2\u0105\u0108")
        buf.write("\5\"\22\2\u0106\u0108\5$\23\2\u0107\u00ff\3\2\2\2\u0107")
        buf.write("\u0100\3\2\2\2\u0107\u0101\3\2\2\2\u0107\u0102\3\2\2\2")
        buf.write("\u0107\u0103\3\2\2\2\u0107\u0104\3\2\2\2\u0107\u0105\3")
        buf.write("\2\2\2\u0107\u0106\3\2\2\2\u0108\'\3\2\2\2\u0109\u010d")
        buf.write("\5B\"\2\u010a\u010b\79\2\2\u010b\u010d\5B\"\2\u010c\u0109")
        buf.write("\3\2\2\2\u010c\u010a\3\2\2\2\u010d)\3\2\2\2\u010e\u010f")
        buf.write("\7\64\2\2\u010f\u011f\7\65\2\2\u0110\u0111\7\64\2\2\u0111")
        buf.write("\u0116\5(\25\2\u0112\u0113\7F\2\2\u0113\u0115\5(\25\2")
        buf.write("\u0114\u0112\3\2\2\2\u0115\u0118\3\2\2\2\u0116\u0114\3")
        buf.write("\2\2\2\u0116\u0117\3\2\2\2\u0117\u011a\3\2\2\2\u0118\u0116")
        buf.write("\3\2\2\2\u0119\u011b\7F\2\2\u011a\u0119\3\2\2\2\u011a")
        buf.write("\u011b\3\2\2\2\u011b\u011c\3\2\2\2\u011c\u011d\7\65\2")
        buf.write("\2\u011d\u011f\3\2\2\2\u011e\u010e\3\2\2\2\u011e\u0110")
        buf.write("\3\2\2\2\u011f+\3\2\2\2\u0120\u0121\7\64\2\2\u0121\u0122")
        buf.write("\5B\"\2\u0122\u0123\7#\2\2\u0123\u0124\5<\37\2\u0124\u0125")
        buf.write("\7$\2\2\u0125\u0128\5B\"\2\u0126\u0127\7%\2\2\u0127\u0129")
        buf.write("\5B\"\2\u0128\u0126\3\2\2\2\u0128\u0129\3\2\2\2\u0129")
        buf.write("\u012a\3\2\2\2\u012a\u012b\7\65\2\2\u012b-\3\2\2\2\u012c")
        buf.write("\u012d\7\66\2\2\u012d\u012e\7=\2\2\u012e\u013e\7\67\2")
        buf.write("\2\u012f\u0130\7\66\2\2\u0130\u0135\5(\25\2\u0131\u0132")
        buf.write("\7F\2\2\u0132\u0134\5(\25\2\u0133\u0131\3\2\2\2\u0134")
        buf.write("\u0137\3\2\2\2\u0135\u0133\3\2\2\2\u0135\u0136\3\2\2\2")
        buf.write("\u0136\u0139\3\2\2\2\u0137\u0135\3\2\2\2\u0138\u013a\7")
        buf.write("F\2\2\u0139\u0138\3\2\2\2\u0139\u013a\3\2\2\2\u013a\u013b")
        buf.write("\3\2\2\2\u013b\u013c\7\67\2\2\u013c\u013e\3\2\2\2\u013d")
        buf.write("\u012c\3\2\2\2\u013d\u012f\3\2\2\2\u013e/\3\2\2\2\u013f")
        buf.write("\u0140\7\66\2\2\u0140\u0141\5B\"\2\u0141\u0142\7#\2\2")
        buf.write("\u0142\u0143\5<\37\2\u0143\u0144\7$\2\2\u0144\u0147\5")
        buf.write("B\"\2\u0145\u0146\7%\2\2\u0146\u0148\5B\"\2\u0147\u0145")
        buf.write("\3\2\2\2\u0147\u0148\3\2\2\2\u0148\u0149\3\2\2\2\u0149")
        buf.write("\u014a\7\67\2\2\u014a\61\3\2\2\2\u014b\u014c\5B\"\2\u014c")
        buf.write("\u014d\7G\2\2\u014d\u014e\5B\"\2\u014e\u0152\3\2\2\2\u014f")
        buf.write("\u0150\78\2\2\u0150\u0152\5B\"\2\u0151\u014b\3\2\2\2\u0151")
        buf.write("\u014f\3\2\2\2\u0152\63\3\2\2\2\u0153\u0154\7\66\2\2\u0154")
        buf.write("\u0164\7\67\2\2\u0155\u0156\7\66\2\2\u0156\u015b\5\62")
        buf.write("\32\2\u0157\u0158\7F\2\2\u0158\u015a\5\62\32\2\u0159\u0157")
        buf.write("\3\2\2\2\u015a\u015d\3\2\2\2\u015b\u0159\3\2\2\2\u015b")
        buf.write("\u015c\3\2\2\2\u015c\u015f\3\2\2\2\u015d\u015b\3\2\2\2")
        buf.write("\u015e\u0160\7F\2\2\u015f\u015e\3\2\2\2\u015f\u0160\3")
        buf.write("\2\2\2\u0160\u0161\3\2\2\2\u0161\u0162\7\67\2\2\u0162")
        buf.write("\u0164\3\2\2\2\u0163\u0153\3\2\2\2\u0163\u0155\3\2\2\2")
        buf.write("\u0164\65\3\2\2\2\u0165\u0166\7\66\2\2\u0166\u0167\5B")
        buf.write("\"\2\u0167\u0168\7G\2\2\u0168\u0169\5B\"\2\u0169\u016a")
        buf.write("\7#\2\2\u016a\u016b\5<\37\2\u016b\u016c\7$\2\2\u016c\u016f")
        buf.write("\5B\"\2\u016d\u016e\7%\2\2\u016e\u0170\5B\"\2\u016f\u016d")
        buf.write("\3\2\2\2\u016f\u0170\3\2\2\2\u0170\u0171\3\2\2\2\u0171")
        buf.write("\u0172\7\67\2\2\u0172\67\3\2\2\2\u0173\u0174\5B\"\2\u0174")
        buf.write("\u0175\7#\2\2\u0175\u0176\5<\37\2\u0176\u0177\7$\2\2\u0177")
        buf.write("\u017a\5B\"\2\u0178\u0179\7%\2\2\u0179\u017b\5B\"\2\u017a")
        buf.write("\u0178\3\2\2\2\u017a\u017b\3\2\2\2\u017b9\3\2\2\2\u017c")
        buf.write("\u018d\5\24\13\2\u017d\u018d\5&\24\2\u017e\u018d\5*\26")
        buf.write("\2\u017f\u018d\5,\27\2\u0180\u018d\5.\30\2\u0181\u018d")
        buf.write("\5\60\31\2\u0182\u018d\5\64\33\2\u0183\u018d\5\66\34\2")
        buf.write("\u0184\u0185\7\62\2\2\u0185\u0186\58\35\2\u0186\u0187")
        buf.write("\7\63\2\2\u0187\u018d\3\2\2\2\u0188\u0189\7\62\2\2\u0189")
        buf.write("\u018a\5B\"\2\u018a\u018b\7\63\2\2\u018b\u018d\3\2\2\2")
        buf.write("\u018c\u017c\3\2\2\2\u018c\u017d\3\2\2\2\u018c\u017e\3")
        buf.write("\2\2\2\u018c\u017f\3\2\2\2\u018c\u0180\3\2\2\2\u018c\u0181")
        buf.write("\3\2\2\2\u018c\u0182\3\2\2\2\u018c\u0183\3\2\2\2\u018c")
        buf.write("\u0184\3\2\2\2\u018c\u0188\3\2\2\2\u018d;\3\2\2\2\u018e")
        buf.write("\u01a5\5B\"\2\u018f\u0190\7\62\2\2\u0190\u0191\5<\37\2")
        buf.write("\u0191\u0192\7F\2\2\u0192\u0193\7\63\2\2\u0193\u01a5\3")
        buf.write("\2\2\2\u0194\u0195\7\62\2\2\u0195\u0196\5<\37\2\u0196")
        buf.write("\u0197\7F\2\2\u0197\u019c\5<\37\2\u0198\u0199\7F\2\2\u0199")
        buf.write("\u019b\5<\37\2\u019a\u0198\3\2\2\2\u019b\u019e\3\2\2\2")
        buf.write("\u019c\u019a\3\2\2\2\u019c\u019d\3\2\2\2\u019d\u01a0\3")
        buf.write("\2\2\2\u019e\u019c\3\2\2\2\u019f\u01a1\7F\2\2\u01a0\u019f")
        buf.write("\3\2\2\2\u01a0\u01a1\3\2\2\2\u01a1\u01a2\3\2\2\2\u01a2")
        buf.write("\u01a3\7\63\2\2\u01a3\u01a5\3\2\2\2\u01a4\u018e\3\2\2")
        buf.write("\2\u01a4\u018f\3\2\2\2\u01a4\u0194\3\2\2\2\u01a5=\3\2")
        buf.write("\2\2\u01a6\u01a8\5B\"\2\u01a7\u01a6\3\2\2\2\u01a7\u01a8")
        buf.write("\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9\u01ab\7G\2\2\u01aa")
        buf.write("\u01ac\5B\"\2\u01ab\u01aa\3\2\2\2\u01ab\u01ac\3\2\2\2")
        buf.write("\u01ac?\3\2\2\2\u01ad\u01b7\5D#\2\u01ae\u01af\5\24\13")
        buf.write("\2\u01af\u01b0\7E\2\2\u01b0\u01b1\5D#\2\u01b1\u01b7\3")
        buf.write("\2\2\2\u01b2\u01b3\79\2\2\u01b3\u01b7\5D#\2\u01b4\u01b5")
        buf.write("\78\2\2\u01b5\u01b7\5D#\2\u01b6\u01ad\3\2\2\2\u01b6\u01ae")
        buf.write("\3\2\2\2\u01b6\u01b2\3\2\2\2\u01b6\u01b4\3\2\2\2\u01b7")
        buf.write("A\3\2\2\2\u01b8\u01b9\b\"\1\2\u01b9\u01c1\5:\36\2\u01ba")
        buf.write("\u01bb\7;\2\2\u01bb\u01c1\5B\"\35\u01bc\u01bd\7H\2\2\u01bd")
        buf.write("\u01c1\5B\"\34\u01be\u01bf\7\'\2\2\u01bf\u01c1\5B\"\6")
        buf.write("\u01c0\u01b8\3\2\2\2\u01c0\u01ba\3\2\2\2\u01c0\u01bc\3")
        buf.write("\2\2\2\u01c0\u01be\3\2\2\2\u01c1\u0231\3\2\2\2\u01c2\u01c3")
        buf.write("\f\33\2\2\u01c3\u01c4\79\2\2\u01c4\u0230\5B\"\34\u01c5")
        buf.write("\u01c6\f\32\2\2\u01c6\u01c7\7=\2\2\u01c7\u0230\5B\"\33")
        buf.write("\u01c8\u01c9\f\31\2\2\u01c9\u01ca\7<\2\2\u01ca\u0230\5")
        buf.write("B\"\32\u01cb\u01cc\f\30\2\2\u01cc\u01cd\7>\2\2\u01cd\u0230")
        buf.write("\5B\"\31\u01ce\u01cf\f\27\2\2\u01cf\u01d0\7:\2\2\u01d0")
        buf.write("\u0230\5B\"\30\u01d1\u01d2\f\26\2\2\u01d2\u01d3\7;\2\2")
        buf.write("\u01d3\u0230\5B\"\27\u01d4\u01d5\f\25\2\2\u01d5\u01d6")
        buf.write("\7L\2\2\u01d6\u0230\5B\"\26\u01d7\u01d8\f\24\2\2\u01d8")
        buf.write("\u01d9\7M\2\2\u01d9\u0230\5B\"\25\u01da\u01db\f\23\2\2")
        buf.write("\u01db\u01dc\7I\2\2\u01dc\u0230\5B\"\24\u01dd\u01de\f")
        buf.write("\22\2\2\u01de\u01df\7J\2\2\u01df\u0230\5B\"\23\u01e0\u01e1")
        buf.write("\f\21\2\2\u01e1\u01e2\7N\2\2\u01e2\u0230\5B\"\22\u01e3")
        buf.write("\u01e4\f\20\2\2\u01e4\u01e5\7?\2\2\u01e5\u0230\5B\"\21")
        buf.write("\u01e6\u01e7\f\17\2\2\u01e7\u01e8\7@\2\2\u01e8\u0230\5")
        buf.write("B\"\20\u01e9\u01ea\f\16\2\2\u01ea\u01eb\7B\2\2\u01eb\u0230")
        buf.write("\5B\"\17\u01ec\u01ed\f\r\2\2\u01ed\u01ee\7A\2\2\u01ee")
        buf.write("\u0230\5B\"\16\u01ef\u01f0\f\f\2\2\u01f0\u01f1\7D\2\2")
        buf.write("\u01f1\u0230\5B\"\r\u01f2\u01f3\f\13\2\2\u01f3\u01f4\7")
        buf.write("C\2\2\u01f4\u0230\5B\"\f\u01f5\u01f6\f\n\2\2\u01f6\u01f7")
        buf.write("\7$\2\2\u01f7\u0230\5B\"\13\u01f8\u01f9\f\t\2\2\u01f9")
        buf.write("\u01fa\7\'\2\2\u01fa\u01fb\7$\2\2\u01fb\u0230\5B\"\n\u01fc")
        buf.write("\u01fd\f\b\2\2\u01fd\u01fe\7(\2\2\u01fe\u0230\5B\"\t\u01ff")
        buf.write("\u0200\f\7\2\2\u0200\u0201\7(\2\2\u0201\u0202\7\'\2\2")
        buf.write("\u0202\u0230\5B\"\b\u0203\u0204\f\5\2\2\u0204\u0205\7")
        buf.write(")\2\2\u0205\u0230\5B\"\6\u0206\u0207\f\4\2\2\u0207\u0208")
        buf.write("\7*\2\2\u0208\u0230\5B\"\5\u0209\u020a\f\3\2\2\u020a\u020b")
        buf.write("\7%\2\2\u020b\u020c\5B\"\2\u020c\u020d\7&\2\2\u020d\u020e")
        buf.write("\5B\"\4\u020e\u0230\3\2\2\2\u020f\u0210\f!\2\2\u0210\u0211")
        buf.write("\7K\2\2\u0211\u0230\5\24\13\2\u0212\u0213\f \2\2\u0213")
        buf.write("\u0221\7\62\2\2\u0214\u0219\5@!\2\u0215\u0216\7F\2\2\u0216")
        buf.write("\u0218\5@!\2\u0217\u0215\3\2\2\2\u0218\u021b\3\2\2\2\u0219")
        buf.write("\u0217\3\2\2\2\u0219\u021a\3\2\2\2\u021a\u021d\3\2\2\2")
        buf.write("\u021b\u0219\3\2\2\2\u021c\u021e\7F\2\2\u021d\u021c\3")
        buf.write("\2\2\2\u021d\u021e\3\2\2\2\u021e\u0220\3\2\2\2\u021f\u0214")
        buf.write("\3\2\2\2\u0220\u0223\3\2\2\2\u0221\u021f\3\2\2\2\u0221")
        buf.write("\u0222\3\2\2\2\u0222\u0224\3\2\2\2\u0223\u0221\3\2\2\2")
        buf.write("\u0224\u0230\7\63\2\2\u0225\u0226\f\37\2\2\u0226\u0227")
        buf.write("\7\64\2\2\u0227\u0228\5B\"\2\u0228\u0229\7\65\2\2\u0229")
        buf.write("\u0230\3\2\2\2\u022a\u022b\f\36\2\2\u022b\u022c\7\64\2")
        buf.write("\2\u022c\u022d\5> \2\u022d\u022e\7\65\2\2\u022e\u0230")
        buf.write("\3\2\2\2\u022f\u01c2\3\2\2\2\u022f\u01c5\3\2\2\2\u022f")
        buf.write("\u01c8\3\2\2\2\u022f\u01cb\3\2\2\2\u022f\u01ce\3\2\2\2")
        buf.write("\u022f\u01d1\3\2\2\2\u022f\u01d4\3\2\2\2\u022f\u01d7\3")
        buf.write("\2\2\2\u022f\u01da\3\2\2\2\u022f\u01dd\3\2\2\2\u022f\u01e0")
        buf.write("\3\2\2\2\u022f\u01e3\3\2\2\2\u022f\u01e6\3\2\2\2\u022f")
        buf.write("\u01e9\3\2\2\2\u022f\u01ec\3\2\2\2\u022f\u01ef\3\2\2\2")
        buf.write("\u022f\u01f2\3\2\2\2\u022f\u01f5\3\2\2\2\u022f\u01f8\3")
        buf.write("\2\2\2\u022f\u01fc\3\2\2\2\u022f\u01ff\3\2\2\2\u022f\u0203")
        buf.write("\3\2\2\2\u022f\u0206\3\2\2\2\u022f\u0209\3\2\2\2\u022f")
        buf.write("\u020f\3\2\2\2\u022f\u0212\3\2\2\2\u022f\u0225\3\2\2\2")
        buf.write("\u022f\u022a\3\2\2\2\u0230\u0233\3\2\2\2\u0231\u022f\3")
        buf.write("\2\2\2\u0231\u0232\3\2\2\2\u0232C\3\2\2\2\u0233\u0231")
        buf.write("\3\2\2\2\u0234\u0237\58\35\2\u0235\u0237\5B\"\2\u0236")
        buf.write("\u0234\3\2\2\2\u0236\u0235\3\2\2\2\u0237E\3\2\2\2\u0238")
        buf.write("\u0239\58\35\2\u0239\u023a\7\2\2\3\u023a\u023f\3\2\2\2")
        buf.write("\u023b\u023c\5B\"\2\u023c\u023d\7\2\2\3\u023d\u023f\3")
        buf.write("\2\2\2\u023e\u0238\3\2\2\2\u023e\u023b\3\2\2\2\u023fG")
        buf.write("\3\2\2\2\u0240\u0241\5<\37\2\u0241\u0242\7$\2\2\u0242")
        buf.write("\u0243\5B\"\2\u0243\u0244\7\2\2\3\u0244I\3\2\2\2\u0245")
        buf.write("\u0246\5<\37\2\u0246\u0247\7E\2\2\u0247\u0248\5B\"\2\u0248")
        buf.write("\u0249\7\2\2\3\u0249\u0285\3\2\2\2\u024a\u024b\5B\"\2")
        buf.write("\u024b\u024c\7O\2\2\u024c\u024d\5B\"\2\u024d\u024e\7\2")
        buf.write("\2\3\u024e\u0285\3\2\2\2\u024f\u0250\5B\"\2\u0250\u0251")
        buf.write("\7P\2\2\u0251\u0252\5B\"\2\u0252\u0253\7\2\2\3\u0253\u0285")
        buf.write("\3\2\2\2\u0254\u0255\5B\"\2\u0255\u0256\7Q\2\2\u0256\u0257")
        buf.write("\5B\"\2\u0257\u0258\7\2\2\3\u0258\u0285\3\2\2\2\u0259")
        buf.write("\u025a\5B\"\2\u025a\u025b\7R\2\2\u025b\u025c\5B\"\2\u025c")
        buf.write("\u025d\7\2\2\3\u025d\u0285\3\2\2\2\u025e\u025f\5B\"\2")
        buf.write("\u025f\u0260\7S\2\2\u0260\u0261\5B\"\2\u0261\u0262\7\2")
        buf.write("\2\3\u0262\u0285\3\2\2\2\u0263\u0264\5B\"\2\u0264\u0265")
        buf.write("\7T\2\2\u0265\u0266\5B\"\2\u0266\u0267\7\2\2\3\u0267\u0285")
        buf.write("\3\2\2\2\u0268\u0269\5B\"\2\u0269\u026a\7U\2\2\u026a\u026b")
        buf.write("\5B\"\2\u026b\u026c\7\2\2\3\u026c\u0285\3\2\2\2\u026d")
        buf.write("\u026e\5B\"\2\u026e\u026f\7V\2\2\u026f\u0270\5B\"\2\u0270")
        buf.write("\u0271\7\2\2\3\u0271\u0285\3\2\2\2\u0272\u0273\5B\"\2")
        buf.write("\u0273\u0274\7W\2\2\u0274\u0275\5B\"\2\u0275\u0276\7\2")
        buf.write("\2\3\u0276\u0285\3\2\2\2\u0277\u0278\5B\"\2\u0278\u0279")
        buf.write("\7X\2\2\u0279\u027a\5B\"\2\u027a\u027b\7\2\2\3\u027b\u0285")
        buf.write("\3\2\2\2\u027c\u027d\5B\"\2\u027d\u027e\7Y\2\2\u027e\u027f")
        buf.write("\5B\"\2\u027f\u0280\7\2\2\3\u0280\u0285\3\2\2\2\u0281")
        buf.write("\u0282\5F$\2\u0282\u0283\7\2\2\3\u0283\u0285\3\2\2\2\u0284")
        buf.write("\u0245\3\2\2\2\u0284\u024a\3\2\2\2\u0284\u024f\3\2\2\2")
        buf.write("\u0284\u0254\3\2\2\2\u0284\u0259\3\2\2\2\u0284\u025e\3")
        buf.write("\2\2\2\u0284\u0263\3\2\2\2\u0284\u0268\3\2\2\2\u0284\u026d")
        buf.write("\3\2\2\2\u0284\u0272\3\2\2\2\u0284\u0277\3\2\2\2\u0284")
        buf.write("\u027c\3\2\2\2\u0284\u0281\3\2\2\2\u0285K\3\2\2\2\u0286")
        buf.write("\u0287\7\62\2\2\u0287\u02dd\7\63\2\2\u0288\u0289\7\62")
        buf.write("\2\2\u0289\u028a\78\2\2\u028a\u028c\5\24\13\2\u028b\u028d")
        buf.write("\7F\2\2\u028c\u028b\3\2\2\2\u028c\u028d\3\2\2\2\u028d")
        buf.write("\u028e\3\2\2\2\u028e\u028f\7\63\2\2\u028f\u02dd\3\2\2")
        buf.write("\2\u0290\u0291\7\62\2\2\u0291\u0292\79\2\2\u0292\u0296")
        buf.write("\5\24\13\2\u0293\u0294\7F\2\2\u0294\u0295\78\2\2\u0295")
        buf.write("\u0297\5\24\13\2\u0296\u0293\3\2\2\2\u0296\u0297\3\2\2")
        buf.write("\2\u0297\u0299\3\2\2\2\u0298\u029a\7F\2\2\u0299\u0298")
        buf.write("\3\2\2\2\u0299\u029a\3\2\2\2\u029a\u029b\3\2\2\2\u029b")
        buf.write("\u029c\7\63\2\2\u029c\u02dd\3\2\2\2\u029d\u029e\7\62\2")
        buf.write("\2\u029e\u029f\5\24\13\2\u029f\u02a0\7E\2\2\u02a0\u02a8")
        buf.write("\5D#\2\u02a1\u02a2\7F\2\2\u02a2\u02a3\5\24\13\2\u02a3")
        buf.write("\u02a4\7E\2\2\u02a4\u02a5\5D#\2\u02a5\u02a7\3\2\2\2\u02a6")
        buf.write("\u02a1\3\2\2\2\u02a7\u02aa\3\2\2\2\u02a8\u02a6\3\2\2\2")
        buf.write("\u02a8\u02a9\3\2\2\2\u02a9\u02ae\3\2\2\2\u02aa\u02a8\3")
        buf.write("\2\2\2\u02ab\u02ac\7F\2\2\u02ac\u02ad\79\2\2\u02ad\u02af")
        buf.write("\5\24\13\2\u02ae\u02ab\3\2\2\2\u02ae\u02af\3\2\2\2\u02af")
        buf.write("\u02b3\3\2\2\2\u02b0\u02b1\7F\2\2\u02b1\u02b2\78\2\2\u02b2")
        buf.write("\u02b4\5\24\13\2\u02b3\u02b0\3\2\2\2\u02b3\u02b4\3\2\2")
        buf.write("\2\u02b4\u02b6\3\2\2\2\u02b5\u02b7\7F\2\2\u02b6\u02b5")
        buf.write("\3\2\2\2\u02b6\u02b7\3\2\2\2\u02b7\u02b8\3\2\2\2\u02b8")
        buf.write("\u02b9\7\63\2\2\u02b9\u02dd\3\2\2\2\u02ba\u02bb\7\62\2")
        buf.write("\2\u02bb\u02c0\5\24\13\2\u02bc\u02bd\7F\2\2\u02bd\u02bf")
        buf.write("\5\24\13\2\u02be\u02bc\3\2\2\2\u02bf\u02c2\3\2\2\2\u02c0")
        buf.write("\u02be\3\2\2\2\u02c0\u02c1\3\2\2\2\u02c1\u02ca\3\2\2\2")
        buf.write("\u02c2\u02c0\3\2\2\2\u02c3\u02c4\7F\2\2\u02c4\u02c5\5")
        buf.write("\24\13\2\u02c5\u02c6\7E\2\2\u02c6\u02c7\5D#\2\u02c7\u02c9")
        buf.write("\3\2\2\2\u02c8\u02c3\3\2\2\2\u02c9\u02cc\3\2\2\2\u02ca")
        buf.write("\u02c8\3\2\2\2\u02ca\u02cb\3\2\2\2\u02cb\u02d0\3\2\2\2")
        buf.write("\u02cc\u02ca\3\2\2\2\u02cd\u02ce\7F\2\2\u02ce\u02cf\7")
        buf.write("9\2\2\u02cf\u02d1\5\24\13\2\u02d0\u02cd\3\2\2\2\u02d0")
        buf.write("\u02d1\3\2\2\2\u02d1\u02d5\3\2\2\2\u02d2\u02d3\7F\2\2")
        buf.write("\u02d3\u02d4\78\2\2\u02d4\u02d6\5\24\13\2\u02d5\u02d2")
        buf.write("\3\2\2\2\u02d5\u02d6\3\2\2\2\u02d6\u02d8\3\2\2\2\u02d7")
        buf.write("\u02d9\7F\2\2\u02d8\u02d7\3\2\2\2\u02d8\u02d9\3\2\2\2")
        buf.write("\u02d9\u02da\3\2\2\2\u02da\u02db\7\63\2\2\u02db\u02dd")
        buf.write("\3\2\2\2\u02dc\u0286\3\2\2\2\u02dc\u0288\3\2\2\2\u02dc")
        buf.write("\u0290\3\2\2\2\u02dc\u029d\3\2\2\2\u02dc\u02ba\3\2\2\2")
        buf.write("\u02ddM\3\2\2\2\u02de\u02e0\5\24\13\2\u02df\u02de\3\2")
        buf.write("\2\2\u02df\u02e0\3\2\2\2\u02e0\u02e2\3\2\2\2\u02e1\u02e3")
        buf.write("\5L\'\2\u02e2\u02e1\3\2\2\2\u02e2\u02e3\3\2\2\2\u02e3")
        buf.write("O\3\2\2\2\u02e4\u02e5\t\2\2\2\u02e5\u02e6\7\17\2\2\u02e6")
        buf.write("\u02e7\5N(\2\u02e7\u02eb\7\"\2\2\u02e8\u02ea\5`\61\2\u02e9")
        buf.write("\u02e8\3\2\2\2\u02ea\u02ed\3\2\2\2\u02eb\u02e9\3\2\2\2")
        buf.write("\u02eb\u02ec\3\2\2\2\u02ec\u02ee\3\2\2\2\u02ed\u02eb\3")
        buf.write("\2\2\2\u02ee\u02ef\t\2\2\2\u02ef\u02f1\7\32\2\2\u02f0")
        buf.write("\u02f2\7.\2\2\u02f1\u02f0\3\2\2\2\u02f1\u02f2\3\2\2\2")
        buf.write("\u02f2\u02f3\3\2\2\2\u02f3\u02f4\7\"\2\2\u02f4Q\3\2\2")
        buf.write("\2\u02f5\u02f6\t\2\2\2\u02f6\u02f7\7\20\2\2\u02f7\u02f8")
        buf.write("\5<\37\2\u02f8\u02f9\7$\2\2\u02f9\u02fa\5B\"\2\u02fa\u02fe")
        buf.write("\7\"\2\2\u02fb\u02fd\5`\61\2\u02fc\u02fb\3\2\2\2\u02fd")
        buf.write("\u0300\3\2\2\2\u02fe\u02fc\3\2\2\2\u02fe\u02ff\3\2\2\2")
        buf.write("\u02ff\u0301\3\2\2\2\u0300\u02fe\3\2\2\2\u0301\u0302\t")
        buf.write("\2\2\2\u0302\u0304\7\32\2\2\u0303\u0305\7#\2\2\u0304\u0303")
        buf.write("\3\2\2\2\u0304\u0305\3\2\2\2\u0305\u0306\3\2\2\2\u0306")
        buf.write("\u0307\7\"\2\2\u0307S\3\2\2\2\u0308\u0309\t\2\2\2\u0309")
        buf.write("\u030a\7\21\2\2\u030a\u030b\5B\"\2\u030b\u030f\7\"\2\2")
        buf.write("\u030c\u030e\5`\61\2\u030d\u030c\3\2\2\2\u030e\u0311\3")
        buf.write("\2\2\2\u030f\u030d\3\2\2\2\u030f\u0310\3\2\2\2\u0310\u0312")
        buf.write("\3\2\2\2\u0311\u030f\3\2\2\2\u0312\u0313\t\2\2\2\u0313")
        buf.write("\u0315\7\32\2\2\u0314\u0316\7/\2\2\u0315\u0314\3\2\2\2")
        buf.write("\u0315\u0316\3\2\2\2\u0316\u0317\3\2\2\2\u0317\u0318\7")
        buf.write("\"\2\2\u0318U\3\2\2\2\u0319\u031a\t\2\2\2\u031a\u031b")
        buf.write("\7\22\2\2\u031b\u031c\5B\"\2\u031c\u0320\7\"\2\2\u031d")
        buf.write("\u031f\5`\61\2\u031e\u031d\3\2\2\2\u031f\u0322\3\2\2\2")
        buf.write("\u0320\u031e\3\2\2\2\u0320\u0321\3\2\2\2\u0321\u032f\3")
        buf.write("\2\2\2\u0322\u0320\3\2\2\2\u0323\u0324\t\2\2\2\u0324\u0325")
        buf.write("\7\23\2\2\u0325\u0326\5B\"\2\u0326\u032a\7\"\2\2\u0327")
        buf.write("\u0329\5`\61\2\u0328\u0327\3\2\2\2\u0329\u032c\3\2\2\2")
        buf.write("\u032a\u0328\3\2\2\2\u032a\u032b\3\2\2\2\u032b\u032e\3")
        buf.write("\2\2\2\u032c\u032a\3\2\2\2\u032d\u0323\3\2\2\2\u032e\u0331")
        buf.write("\3\2\2\2\u032f\u032d\3\2\2\2\u032f\u0330\3\2\2\2\u0330")
        buf.write("\u0332\3\2\2\2\u0331\u032f\3\2\2\2\u0332\u0333\t\2\2\2")
        buf.write("\u0333\u0334\7\24\2\2\u0334\u0338\7\"\2\2\u0335\u0337")
        buf.write("\5`\61\2\u0336\u0335\3\2\2\2\u0337\u033a\3\2\2\2\u0338")
        buf.write("\u0336\3\2\2\2\u0338\u0339\3\2\2\2\u0339\u033b\3\2\2\2")
        buf.write("\u033a\u0338\3\2\2\2\u033b\u033c\t\2\2\2\u033c\u033e\7")
        buf.write("\32\2\2\u033d\u033f\7%\2\2\u033e\u033d\3\2\2\2\u033e\u033f")
        buf.write("\3\2\2\2\u033f\u0340\3\2\2\2\u0340\u0341\7\"\2\2\u0341")
        buf.write("W\3\2\2\2\u0342\u0343\t\2\2\2\u0343\u0344\7\25\2\2\u0344")
        buf.write("\u0345\5B\"\2\u0345\u0353\7\62\2\2\u0346\u034b\5@!\2\u0347")
        buf.write("\u0348\7F\2\2\u0348\u034a\5@!\2\u0349\u0347\3\2\2\2\u034a")
        buf.write("\u034d\3\2\2\2\u034b\u0349\3\2\2\2\u034b\u034c\3\2\2\2")
        buf.write("\u034c\u034f\3\2\2\2\u034d\u034b\3\2\2\2\u034e\u0350\7")
        buf.write("F\2\2\u034f\u034e\3\2\2\2\u034f\u0350\3\2\2\2\u0350\u0352")
        buf.write("\3\2\2\2\u0351\u0346\3\2\2\2\u0352\u0355\3\2\2\2\u0353")
        buf.write("\u0351\3\2\2\2\u0353\u0354\3\2\2\2\u0354\u0356\3\2\2\2")
        buf.write("\u0355\u0353\3\2\2\2\u0356\u0357\7\63\2\2\u0357\u035b")
        buf.write("\7\"\2\2\u0358\u035a\5`\61\2\u0359\u0358\3\2\2\2\u035a")
        buf.write("\u035d\3\2\2\2\u035b\u0359\3\2\2\2\u035b\u035c\3\2\2\2")
        buf.write("\u035c\u035e\3\2\2\2\u035d\u035b\3\2\2\2\u035e\u035f\t")
        buf.write("\2\2\2\u035f\u0361\7\32\2\2\u0360\u0362\7\60\2\2\u0361")
        buf.write("\u0360\3\2\2\2\u0361\u0362\3\2\2\2\u0362\u0363\3\2\2\2")
        buf.write("\u0363\u0364\7\"\2\2\u0364Y\3\2\2\2\u0365\u0366\t\2\2")
        buf.write("\2\u0366\u0367\7\26\2\2\u0367\u0368\5B\"\2\u0368\u0376")
        buf.write("\7\62\2\2\u0369\u036e\5@!\2\u036a\u036b\7F\2\2\u036b\u036d")
        buf.write("\5@!\2\u036c\u036a\3\2\2\2\u036d\u0370\3\2\2\2\u036e\u036c")
        buf.write("\3\2\2\2\u036e\u036f\3\2\2\2\u036f\u0372\3\2\2\2\u0370")
        buf.write("\u036e\3\2\2\2\u0371\u0373\7F\2\2\u0372\u0371\3\2\2\2")
        buf.write("\u0372\u0373\3\2\2\2\u0373\u0375\3\2\2\2\u0374\u0369\3")
        buf.write("\2\2\2\u0375\u0378\3\2\2\2\u0376\u0374\3\2\2\2\u0376\u0377")
        buf.write("\3\2\2\2\u0377\u0379\3\2\2\2\u0378\u0376\3\2\2\2\u0379")
        buf.write("\u037a\7\63\2\2\u037a\u037e\7\"\2\2\u037b\u037d\5`\61")
        buf.write("\2\u037c\u037b\3\2\2\2\u037d\u0380\3\2\2\2\u037e\u037c")
        buf.write("\3\2\2\2\u037e\u037f\3\2\2\2\u037f\u0381\3\2\2\2\u0380")
        buf.write("\u037e\3\2\2\2\u0381\u0382\t\2\2\2\u0382\u0384\7\32\2")
        buf.write("\2\u0383\u0385\7\61\2\2\u0384\u0383\3\2\2\2\u0384\u0385")
        buf.write("\3\2\2\2\u0385\u0386\3\2\2\2\u0386\u0387\7\"\2\2\u0387")
        buf.write("[\3\2\2\2\u0388\u038c\t\2\2\2\u0389\u038b\7\n\2\2\u038a")
        buf.write("\u0389\3\2\2\2\u038b\u038e\3\2\2\2\u038c\u038a\3\2\2\2")
        buf.write("\u038c\u038d\3\2\2\2\u038d\u038f\3\2\2\2\u038e\u038c\3")
        buf.write("\2\2\2\u038f\u0393\7\27\2\2\u0390\u0392\7 \2\2\u0391\u0390")
        buf.write("\3\2\2\2\u0392\u0395\3\2\2\2\u0393\u0391\3\2\2\2\u0393")
        buf.write("\u0394\3\2\2\2\u0394\u0396\3\2\2\2\u0395\u0393\3\2\2\2")
        buf.write("\u0396\u039a\5B\"\2\u0397\u0399\7 \2\2\u0398\u0397\3\2")
        buf.write("\2\2\u0399\u039c\3\2\2\2\u039a\u0398\3\2\2\2\u039a\u039b")
        buf.write("\3\2\2\2\u039b\u039d\3\2\2\2\u039c\u039a\3\2\2\2\u039d")
        buf.write("\u039e\7\"\2\2\u039e]\3\2\2\2\u039f\u03a3\t\2\2\2\u03a0")
        buf.write("\u03a2\7\n\2\2\u03a1\u03a0\3\2\2\2\u03a2\u03a5\3\2\2\2")
        buf.write("\u03a3\u03a1\3\2\2\2\u03a3\u03a4\3\2\2\2\u03a4\u03a6\3")
        buf.write("\2\2\2\u03a5\u03a3\3\2\2\2\u03a6\u03aa\7\30\2\2\u03a7")
        buf.write("\u03a9\7 \2\2\u03a8\u03a7\3\2\2\2\u03a9\u03ac\3\2\2\2")
        buf.write("\u03aa\u03a8\3\2\2\2\u03aa\u03ab\3\2\2\2\u03ab\u03ad\3")
        buf.write("\2\2\2\u03ac\u03aa\3\2\2\2\u03ad\u03b1\5B\"\2\u03ae\u03b0")
        buf.write("\7 \2\2\u03af\u03ae\3\2\2\2\u03b0\u03b3\3\2\2\2\u03b1")
        buf.write("\u03af\3\2\2\2\u03b1\u03b2\3\2\2\2\u03b2\u03b4\3\2\2\2")
        buf.write("\u03b3\u03b1\3\2\2\2\u03b4\u03b5\7\"\2\2\u03b5_\3\2\2")
        buf.write("\2\u03b6\u03c0\5P)\2\u03b7\u03c0\5R*\2\u03b8\u03c0\5T")
        buf.write("+\2\u03b9\u03c0\5V,\2\u03ba\u03c0\5\\/\2\u03bb\u03c0\5")
        buf.write("^\60\2\u03bc\u03c0\5\16\b\2\u03bd\u03c0\5\20\t\2\u03be")
        buf.write("\u03c0\5\22\n\2\u03bf\u03b6\3\2\2\2\u03bf\u03b7\3\2\2")
        buf.write("\2\u03bf\u03b8\3\2\2\2\u03bf\u03b9\3\2\2\2\u03bf\u03ba")
        buf.write("\3\2\2\2\u03bf\u03bb\3\2\2\2\u03bf\u03bc\3\2\2\2\u03bf")
        buf.write("\u03bd\3\2\2\2\u03bf\u03be\3\2\2\2\u03c0a\3\2\2\2\u03c1")
        buf.write("\u03c6\5\6\4\2\u03c2\u03c6\5\b\5\2\u03c3\u03c6\5\n\6\2")
        buf.write("\u03c4\u03c6\5`\61\2\u03c5\u03c1\3\2\2\2\u03c5\u03c2\3")
        buf.write("\2\2\2\u03c5\u03c3\3\2\2\2\u03c5\u03c4\3\2\2\2\u03c6c")
        buf.write("\3\2\2\2gejsz~\u0081\u0089\u0090\u0097\u00a0\u00a7\u00ab")
        buf.write("\u00b0\u00b9\u00c0\u00c4\u00c7\u00d0\u00d4\u00d9\u00de")
        buf.write("\u00e3\u00e5\u00ef\u00f7\u0107\u010c\u0116\u011a\u011e")
        buf.write("\u0128\u0135\u0139\u013d\u0147\u0151\u015b\u015f\u0163")
        buf.write("\u016f\u017a\u018c\u019c\u01a0\u01a4\u01a7\u01ab\u01b6")
        buf.write("\u01c0\u0219\u021d\u0221\u022f\u0231\u0236\u023e\u0284")
        buf.write("\u028c\u0296\u0299\u02a8\u02ae\u02b3\u02b6\u02c0\u02ca")
        buf.write("\u02d0\u02d5\u02d8\u02dc\u02df\u02e2\u02eb\u02f1\u02fe")
        buf.write("\u0304\u030f\u0315\u0320\u032a\u032f\u0338\u033e\u034b")
        buf.write("\u034f\u0353\u035b\u0361\u036e\u0372\u0376\u037e\u0384")
        buf.write("\u038c\u0393\u039a\u03a3\u03aa\u03b1\u03bf\u03c5")
        return buf.getvalue()


class UL4Parser ( Parser ):

    grammarFileName = "UL4Parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'whitespace'", "'doc'", "'note'", "'ul4'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'elif'", "<INVALID>", "<INVALID>", "<INVALID>", "'print'", 
                     "'printx'", "'code'", "'end'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'in'", "<INVALID>", 
                     "<INVALID>", "'not'", "'is'", "'and'", "'or'", "'None'", 
                     "'True'", "'False'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'('", "')'", "'['", "']'", "'{'", "'}'", 
                     "'**'", "'*'", "'+'", "'-'", "'//'", "'/'", "'%'", 
                     "'=='", "'!='", "'<='", "'<'", "'>='", "'>'", "'='", 
                     "','", "':'", "'~'", "'&'", "'^'", "'.'", "'<<'", "'>>'", 
                     "'|'", "'+='", "'-='", "'*='", "'//='", "'/='", "'%='", 
                     "'<<='", "'>>='", "'&='", "'^='", "'|='" ]

    symbolicNames = [ "<INVALID>", "DEFAULT_INDENT", "DEFAULT_LINEEND", 
                      "DEFAULT_MAYBETAG", "DEFAULT_OTHER", "TEXT_MAYBETAG", 
                      "TEXT_LINEEND", "TEXT_OTHER", "MAYBETAG_WS", "MAYBETAG_WHITESPACE", 
                      "MAYBETAG_DOC", "MAYBETAG_NOTE", "MAYBETAG_UL4", "MAYBETAG_DEF", 
                      "MAYBETAG_FOR", "MAYBETAG_WHILE", "MAYBETAG_IF", "MAYBETAG_ELIF", 
                      "MAYBETAG_ELSE", "MAYBETAG_RENDERBLOCK", "MAYBETAG_RENDERBLOCKS", 
                      "MAYBETAG_PRINT", "MAYBETAG_PRINTX", "MAYBETAG_CODE", 
                      "MAYBETAG_END", "MAYBETAG_OTHER", "WHITESPACE_VALUE", 
                      "WHITESPACE_WS", "WHITESPACE_ENDDELIM", "TEXTTAG_TEXT", 
                      "TEXTTAG_WS", "TEXTTAG_ENDDELIM", "ENDDELIM", "FOR", 
                      "IN", "IF", "ELSE", "NOT", "IS", "AND", "OR", "NONE", 
                      "TRUE", "FALSE", "DEF", "WHILE", "RENDERBLOCK", "RENDERBLOCKS", 
                      "PARENS_OPEN", "PARENS_CLOSE", "BRACKET_OPEN", "BRACKET_CLOSE", 
                      "BRACE_OPEN", "BRACE_CLOSE", "STAR_STAR", "STAR", 
                      "PLUS", "MINUS", "SLASH_SLASH", "SLASH", "PERCENT", 
                      "EQUAL", "NOT_EQUAL", "LESS_THAN_OR_EQUAL", "LESS_THAN", 
                      "GREATER_THAN_OR_EQUAL", "GREATER_THAN", "ASSIGN", 
                      "COMMA", "COLON", "TILDE", "AMPERSAND", "CARET", "DOT", 
                      "SHIFTLEFT", "SHIFTRIGHT", "BAR", "AUGADD", "AUGSUB", 
                      "AUGMUL", "AUGFLOORDIV", "AUGTRUEDIV", "AUGMOD", "AUGSHIFTLEFT", 
                      "AUGSHIFTRIGHT", "AUGAND", "AUGXOR", "AUGOR", "NAME", 
                      "INT", "FLOAT", "DATE", "DATETIME", "COLOR", "WS", 
                      "STRING", "STRING3" ]

    RULE_template = 0
    RULE_ul4tag = 1
    RULE_whitespacetag = 2
    RULE_doctag = 3
    RULE_notetag = 4
    RULE_texttag_content = 5
    RULE_indent = 6
    RULE_text = 7
    RULE_lineend = 8
    RULE_name = 9
    RULE_none_literal = 10
    RULE_bool_literal = 11
    RULE_integer_literal = 12
    RULE_float_literal = 13
    RULE_string_literal = 14
    RULE_date_literal = 15
    RULE_datetime_literal = 16
    RULE_color_literal = 17
    RULE_literal = 18
    RULE_seqitem = 19
    RULE_list_display = 20
    RULE_listcomprehension = 21
    RULE_set_display = 22
    RULE_setcomprehension = 23
    RULE_dictitem = 24
    RULE_dict_display = 25
    RULE_dictcomprehension = 26
    RULE_generatorexpression = 27
    RULE_atom = 28
    RULE_nestedlvalue = 29
    RULE_slice_ = 30
    RULE_argument = 31
    RULE_expr = 32
    RULE_exprarg = 33
    RULE_expression = 34
    RULE_for_ = 35
    RULE_stmt = 36
    RULE_signature = 37
    RULE_definition = 38
    RULE_defblock = 39
    RULE_forblock = 40
    RULE_whileblock = 41
    RULE_ifblock = 42
    RULE_renderblockblock = 43
    RULE_renderblocksblock = 44
    RULE_printtag = 45
    RULE_printxtag = 46
    RULE_block_content = 47
    RULE_template_content = 48

    ruleNames =  [ "template", "ul4tag", "whitespacetag", "doctag", "notetag", 
                   "texttag_content", "indent", "text", "lineend", "name", 
                   "none_literal", "bool_literal", "integer_literal", "float_literal", 
                   "string_literal", "date_literal", "datetime_literal", 
                   "color_literal", "literal", "seqitem", "list_display", 
                   "listcomprehension", "set_display", "setcomprehension", 
                   "dictitem", "dict_display", "dictcomprehension", "generatorexpression", 
                   "atom", "nestedlvalue", "slice_", "argument", "expr", 
                   "exprarg", "expression", "for_", "stmt", "signature", 
                   "definition", "defblock", "forblock", "whileblock", "ifblock", 
                   "renderblockblock", "renderblocksblock", "printtag", 
                   "printxtag", "block_content", "template_content" ]

    EOF = Token.EOF
    DEFAULT_INDENT=1
    DEFAULT_LINEEND=2
    DEFAULT_MAYBETAG=3
    DEFAULT_OTHER=4
    TEXT_MAYBETAG=5
    TEXT_LINEEND=6
    TEXT_OTHER=7
    MAYBETAG_WS=8
    MAYBETAG_WHITESPACE=9
    MAYBETAG_DOC=10
    MAYBETAG_NOTE=11
    MAYBETAG_UL4=12
    MAYBETAG_DEF=13
    MAYBETAG_FOR=14
    MAYBETAG_WHILE=15
    MAYBETAG_IF=16
    MAYBETAG_ELIF=17
    MAYBETAG_ELSE=18
    MAYBETAG_RENDERBLOCK=19
    MAYBETAG_RENDERBLOCKS=20
    MAYBETAG_PRINT=21
    MAYBETAG_PRINTX=22
    MAYBETAG_CODE=23
    MAYBETAG_END=24
    MAYBETAG_OTHER=25
    WHITESPACE_VALUE=26
    WHITESPACE_WS=27
    WHITESPACE_ENDDELIM=28
    TEXTTAG_TEXT=29
    TEXTTAG_WS=30
    TEXTTAG_ENDDELIM=31
    ENDDELIM=32
    FOR=33
    IN=34
    IF=35
    ELSE=36
    NOT=37
    IS=38
    AND=39
    OR=40
    NONE=41
    TRUE=42
    FALSE=43
    DEF=44
    WHILE=45
    RENDERBLOCK=46
    RENDERBLOCKS=47
    PARENS_OPEN=48
    PARENS_CLOSE=49
    BRACKET_OPEN=50
    BRACKET_CLOSE=51
    BRACE_OPEN=52
    BRACE_CLOSE=53
    STAR_STAR=54
    STAR=55
    PLUS=56
    MINUS=57
    SLASH_SLASH=58
    SLASH=59
    PERCENT=60
    EQUAL=61
    NOT_EQUAL=62
    LESS_THAN_OR_EQUAL=63
    LESS_THAN=64
    GREATER_THAN_OR_EQUAL=65
    GREATER_THAN=66
    ASSIGN=67
    COMMA=68
    COLON=69
    TILDE=70
    AMPERSAND=71
    CARET=72
    DOT=73
    SHIFTLEFT=74
    SHIFTRIGHT=75
    BAR=76
    AUGADD=77
    AUGSUB=78
    AUGMUL=79
    AUGFLOORDIV=80
    AUGTRUEDIV=81
    AUGMOD=82
    AUGSHIFTLEFT=83
    AUGSHIFTRIGHT=84
    AUGAND=85
    AUGXOR=86
    AUGOR=87
    NAME=88
    INT=89
    FLOAT=90
    DATE=91
    DATETIME=92
    COLOR=93
    WS=94
    STRING=95
    STRING3=96

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class TemplateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_template

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TopLevelContext(TemplateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.TemplateContext
            super().__init__(parser)
            self.head = None # Ul4tagContext
            self._template_content = None # Template_contentContext
            self.content = list() # of Template_contentContexts
            self.copyFrom(ctx)

        def EOF(self):
            return self.getToken(UL4Parser.EOF, 0)
        def ul4tag(self):
            return self.getTypedRuleContext(UL4Parser.Ul4tagContext,0)

        def template_content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.Template_contentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.Template_contentContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopLevel" ):
                return visitor.visitTopLevel(self)
            else:
                return visitor.visitChildren(self)



    def template(self):

        localctx = UL4Parser.TemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_template)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.TopLevelContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 98
                localctx.head = self.ul4tag()


            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << UL4Parser.DEFAULT_INDENT) | (1 << UL4Parser.DEFAULT_LINEEND) | (1 << UL4Parser.DEFAULT_MAYBETAG) | (1 << UL4Parser.DEFAULT_OTHER) | (1 << UL4Parser.TEXT_MAYBETAG) | (1 << UL4Parser.TEXT_LINEEND) | (1 << UL4Parser.TEXT_OTHER))) != 0):
                self.state = 101
                localctx._template_content = self.template_content()
                localctx.content.append(localctx._template_content)
                self.state = 106
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 107
            self.match(UL4Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ul4tagContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_ul4tag

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TagUL4Context(Ul4tagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Ul4tagContext
            super().__init__(parser)
            self.templatename = None # NameContext
            self.templatesignature = None # SignatureContext
            self.copyFrom(ctx)

        def MAYBETAG_UL4(self):
            return self.getToken(UL4Parser.MAYBETAG_UL4, 0)
        def ENDDELIM(self):
            return self.getToken(UL4Parser.ENDDELIM, 0)
        def DEFAULT_MAYBETAG(self):
            return self.getToken(UL4Parser.DEFAULT_MAYBETAG, 0)
        def TEXT_MAYBETAG(self):
            return self.getToken(UL4Parser.TEXT_MAYBETAG, 0)
        def MAYBETAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.MAYBETAG_WS)
            else:
                return self.getToken(UL4Parser.MAYBETAG_WS, i)
        def name(self):
            return self.getTypedRuleContext(UL4Parser.NameContext,0)

        def signature(self):
            return self.getTypedRuleContext(UL4Parser.SignatureContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTagUL4" ):
                return visitor.visitTagUL4(self)
            else:
                return visitor.visitChildren(self)



    def ul4tag(self):

        localctx = UL4Parser.Ul4tagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_ul4tag)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.TagUL4Context(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.MAYBETAG_WS:
                self.state = 110
                self.match(UL4Parser.MAYBETAG_WS)
                self.state = 115
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 116
            self.match(UL4Parser.MAYBETAG_UL4)
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.MAYBETAG_WS:
                self.state = 117
                self.match(UL4Parser.MAYBETAG_WS)
                self.state = 122
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.NAME:
                self.state = 123
                localctx.templatename = self.name()


            self.state = 127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.PARENS_OPEN:
                self.state = 126
                localctx.templatesignature = self.signature()


            self.state = 129
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhitespacetagContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_whitespacetag

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TagWhitespaceContext(WhitespacetagContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.WhitespacetagContext
            super().__init__(parser)
            self.whitespace = None # Token
            self.copyFrom(ctx)

        def MAYBETAG_WHITESPACE(self):
            return self.getToken(UL4Parser.MAYBETAG_WHITESPACE, 0)
        def WHITESPACE_ENDDELIM(self):
            return self.getToken(UL4Parser.WHITESPACE_ENDDELIM, 0)
        def DEFAULT_MAYBETAG(self):
            return self.getToken(UL4Parser.DEFAULT_MAYBETAG, 0)
        def TEXT_MAYBETAG(self):
            return self.getToken(UL4Parser.TEXT_MAYBETAG, 0)
        def WHITESPACE_VALUE(self):
            return self.getToken(UL4Parser.WHITESPACE_VALUE, 0)
        def MAYBETAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.MAYBETAG_WS)
            else:
                return self.getToken(UL4Parser.MAYBETAG_WS, i)
        def WHITESPACE_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.WHITESPACE_WS)
            else:
                return self.getToken(UL4Parser.WHITESPACE_WS, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTagWhitespace" ):
                return visitor.visitTagWhitespace(self)
            else:
                return visitor.visitChildren(self)



    def whitespacetag(self):

        localctx = UL4Parser.WhitespacetagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_whitespacetag)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.TagWhitespaceContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.MAYBETAG_WS:
                self.state = 132
                self.match(UL4Parser.MAYBETAG_WS)
                self.state = 137
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 138
            self.match(UL4Parser.MAYBETAG_WHITESPACE)
            self.state = 142
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.WHITESPACE_WS:
                self.state = 139
                self.match(UL4Parser.WHITESPACE_WS)
                self.state = 144
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 145
            localctx.whitespace = self.match(UL4Parser.WHITESPACE_VALUE)
            self.state = 149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.WHITESPACE_WS:
                self.state = 146
                self.match(UL4Parser.WHITESPACE_WS)
                self.state = 151
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 152
            self.match(UL4Parser.WHITESPACE_ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoctagContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAYBETAG_DOC(self):
            return self.getToken(UL4Parser.MAYBETAG_DOC, 0)

        def TEXTTAG_ENDDELIM(self):
            return self.getToken(UL4Parser.TEXTTAG_ENDDELIM, 0)

        def DEFAULT_MAYBETAG(self):
            return self.getToken(UL4Parser.DEFAULT_MAYBETAG, 0)

        def TEXT_MAYBETAG(self):
            return self.getToken(UL4Parser.TEXT_MAYBETAG, 0)

        def MAYBETAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.MAYBETAG_WS)
            else:
                return self.getToken(UL4Parser.MAYBETAG_WS, i)

        def texttag_content(self):
            return self.getTypedRuleContext(UL4Parser.Texttag_contentContext,0)


        def TEXTTAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXTTAG_WS)
            else:
                return self.getToken(UL4Parser.TEXTTAG_WS, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_doctag

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoctag" ):
                return visitor.visitDoctag(self)
            else:
                return visitor.visitChildren(self)




    def doctag(self):

        localctx = UL4Parser.DoctagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_doctag)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.MAYBETAG_WS:
                self.state = 155
                self.match(UL4Parser.MAYBETAG_WS)
                self.state = 160
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 161
            self.match(UL4Parser.MAYBETAG_DOC)
            self.state = 165
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 162
                    self.match(UL4Parser.MAYBETAG_WS) 
                self.state = 167
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

            self.state = 169
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 168
                self.texttag_content()


            self.state = 174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.TEXTTAG_WS:
                self.state = 171
                self.match(UL4Parser.TEXTTAG_WS)
                self.state = 176
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 177
            self.match(UL4Parser.TEXTTAG_ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotetagContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAYBETAG_NOTE(self):
            return self.getToken(UL4Parser.MAYBETAG_NOTE, 0)

        def TEXTTAG_ENDDELIM(self):
            return self.getToken(UL4Parser.TEXTTAG_ENDDELIM, 0)

        def DEFAULT_MAYBETAG(self):
            return self.getToken(UL4Parser.DEFAULT_MAYBETAG, 0)

        def TEXT_MAYBETAG(self):
            return self.getToken(UL4Parser.TEXT_MAYBETAG, 0)

        def MAYBETAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.MAYBETAG_WS)
            else:
                return self.getToken(UL4Parser.MAYBETAG_WS, i)

        def texttag_content(self):
            return self.getTypedRuleContext(UL4Parser.Texttag_contentContext,0)


        def TEXTTAG_WS(self):
            return self.getToken(UL4Parser.TEXTTAG_WS, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_notetag

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotetag" ):
                return visitor.visitNotetag(self)
            else:
                return visitor.visitChildren(self)




    def notetag(self):

        localctx = UL4Parser.NotetagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_notetag)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.MAYBETAG_WS:
                self.state = 180
                self.match(UL4Parser.MAYBETAG_WS)
                self.state = 185
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 186
            self.match(UL4Parser.MAYBETAG_NOTE)
            self.state = 190
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 187
                    self.match(UL4Parser.MAYBETAG_WS) 
                self.state = 192
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

            self.state = 194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 193
                self.texttag_content()


            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.TEXTTAG_WS:
                self.state = 196
                self.match(UL4Parser.TEXTTAG_WS)


            self.state = 199
            self.match(UL4Parser.TEXTTAG_ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Texttag_contentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXTTAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXTTAG_WS)
            else:
                return self.getToken(UL4Parser.TEXTTAG_WS, i)

        def TEXTTAG_TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXTTAG_TEXT)
            else:
                return self.getToken(UL4Parser.TEXTTAG_TEXT, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_texttag_content

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTexttag_content" ):
                return visitor.visitTexttag_content(self)
            else:
                return visitor.visitChildren(self)




    def texttag_content(self):

        localctx = UL4Parser.Texttag_contentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_texttag_content)
        self._la = 0 # Token type
        try:
            self.state = 210
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 201
                _la = self._input.LA(1)
                if _la <= 0 or _la==UL4Parser.TEXTTAG_WS:
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 202
                _la = self._input.LA(1)
                if _la <= 0 or _la==UL4Parser.TEXTTAG_WS:
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 206
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 203
                        self.match(UL4Parser.TEXTTAG_TEXT) 
                    self.state = 208
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

                self.state = 209
                _la = self._input.LA(1)
                if _la <= 0 or _la==UL4Parser.TEXTTAG_WS:
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_INDENT(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_INDENT)
            else:
                return self.getToken(UL4Parser.DEFAULT_INDENT, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_indent

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndent" ):
                return visitor.visitIndent(self)
            else:
                return visitor.visitChildren(self)




    def indent(self):

        localctx = UL4Parser.IndentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_indent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 212
                    self.match(UL4Parser.DEFAULT_INDENT)

                else:
                    raise NoViableAltException(self)
                self.state = 215 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_OTHER(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_OTHER)
            else:
                return self.getToken(UL4Parser.DEFAULT_OTHER, i)

        def TEXT_OTHER(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXT_OTHER)
            else:
                return self.getToken(UL4Parser.TEXT_OTHER, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_text

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitText" ):
                return visitor.visitText(self)
            else:
                return visitor.visitChildren(self)




    def text(self):

        localctx = UL4Parser.TextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_text)
        try:
            self.state = 227
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UL4Parser.DEFAULT_OTHER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 218 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 217
                        self.match(UL4Parser.DEFAULT_OTHER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 220 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

                pass
            elif token in [UL4Parser.TEXT_OTHER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 223 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 222
                        self.match(UL4Parser.TEXT_OTHER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 225 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineendContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_LINEEND(self):
            return self.getToken(UL4Parser.DEFAULT_LINEEND, 0)

        def TEXT_LINEEND(self):
            return self.getToken(UL4Parser.TEXT_LINEEND, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_lineend

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineend" ):
                return visitor.visitLineend(self)
            else:
                return visitor.visitChildren(self)




    def lineend(self):

        localctx = UL4Parser.LineendContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_lineend)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_LINEEND or _la==UL4Parser.TEXT_LINEEND):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(UL4Parser.NAME, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = UL4Parser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(UL4Parser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class None_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def NONE(self):
            return self.getToken(UL4Parser.NONE, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_none_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNone_literal" ):
                return visitor.visitNone_literal(self)
            else:
                return visitor.visitChildren(self)




    def none_literal(self):

        localctx = UL4Parser.None_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_none_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            localctx.value = self.match(UL4Parser.NONE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bool_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_bool_literal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BoolLiteralTrueContext(Bool_literalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Bool_literalContext
            super().__init__(parser)
            self.value = None # Token
            self.copyFrom(ctx)

        def TRUE(self):
            return self.getToken(UL4Parser.TRUE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolLiteralTrue" ):
                return visitor.visitBoolLiteralTrue(self)
            else:
                return visitor.visitChildren(self)


    class BoolLiteralFalseContext(Bool_literalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Bool_literalContext
            super().__init__(parser)
            self.value = None # Token
            self.copyFrom(ctx)

        def FALSE(self):
            return self.getToken(UL4Parser.FALSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolLiteralFalse" ):
                return visitor.visitBoolLiteralFalse(self)
            else:
                return visitor.visitChildren(self)



    def bool_literal(self):

        localctx = UL4Parser.Bool_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_bool_literal)
        try:
            self.state = 237
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UL4Parser.FALSE]:
                localctx = UL4Parser.BoolLiteralFalseContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 235
                localctx.value = self.match(UL4Parser.FALSE)
                pass
            elif token in [UL4Parser.TRUE]:
                localctx = UL4Parser.BoolLiteralTrueContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 236
                localctx.value = self.match(UL4Parser.TRUE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Integer_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_integer_literal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IntegerLiteralContext(Integer_literalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Integer_literalContext
            super().__init__(parser)
            self.value = None # Token
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(UL4Parser.INT, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerLiteral" ):
                return visitor.visitIntegerLiteral(self)
            else:
                return visitor.visitChildren(self)



    def integer_literal(self):

        localctx = UL4Parser.Integer_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_integer_literal)
        try:
            localctx = UL4Parser.IntegerLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            localctx.value = self.match(UL4Parser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Float_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_float_literal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FloatLiteralContext(Float_literalContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Float_literalContext
            super().__init__(parser)
            self.value = None # Token
            self.copyFrom(ctx)

        def FLOAT(self):
            return self.getToken(UL4Parser.FLOAT, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloatLiteral" ):
                return visitor.visitFloatLiteral(self)
            else:
                return visitor.visitChildren(self)



    def float_literal(self):

        localctx = UL4Parser.Float_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_float_literal)
        try:
            localctx = UL4Parser.FloatLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            localctx.value = self.match(UL4Parser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def STRING(self):
            return self.getToken(UL4Parser.STRING, 0)

        def STRING3(self):
            return self.getToken(UL4Parser.STRING3, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_string_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitString_literal" ):
                return visitor.visitString_literal(self)
            else:
                return visitor.visitChildren(self)




    def string_literal(self):

        localctx = UL4Parser.String_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_string_literal)
        try:
            self.state = 245
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UL4Parser.STRING]:
                self.enterOuterAlt(localctx, 1)
                self.state = 243
                localctx.value = self.match(UL4Parser.STRING)
                pass
            elif token in [UL4Parser.STRING3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 244
                localctx.value = self.match(UL4Parser.STRING3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def DATE(self):
            return self.getToken(UL4Parser.DATE, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_date_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_literal" ):
                return visitor.visitDate_literal(self)
            else:
                return visitor.visitChildren(self)




    def date_literal(self):

        localctx = UL4Parser.Date_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_date_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            localctx.value = self.match(UL4Parser.DATE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Datetime_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def DATE(self):
            return self.getToken(UL4Parser.DATE, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_datetime_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatetime_literal" ):
                return visitor.visitDatetime_literal(self)
            else:
                return visitor.visitChildren(self)




    def datetime_literal(self):

        localctx = UL4Parser.Datetime_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_datetime_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            localctx.value = self.match(UL4Parser.DATE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Color_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # Token

        def COLOR(self):
            return self.getToken(UL4Parser.COLOR, 0)

        def getRuleIndex(self):
            return UL4Parser.RULE_color_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColor_literal" ):
                return visitor.visitColor_literal(self)
            else:
                return visitor.visitChildren(self)




    def color_literal(self):

        localctx = UL4Parser.Color_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_color_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            localctx.value = self.match(UL4Parser.COLOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_literal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LiteralIntegerContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def integer_literal(self):
            return self.getTypedRuleContext(UL4Parser.Integer_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralInteger" ):
                return visitor.visitLiteralInteger(self)
            else:
                return visitor.visitChildren(self)


    class LiteralFloatContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def float_literal(self):
            return self.getTypedRuleContext(UL4Parser.Float_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralFloat" ):
                return visitor.visitLiteralFloat(self)
            else:
                return visitor.visitChildren(self)


    class LiteralDateContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def date_literal(self):
            return self.getTypedRuleContext(UL4Parser.Date_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralDate" ):
                return visitor.visitLiteralDate(self)
            else:
                return visitor.visitChildren(self)


    class LiteralBoolContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bool_literal(self):
            return self.getTypedRuleContext(UL4Parser.Bool_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralBool" ):
                return visitor.visitLiteralBool(self)
            else:
                return visitor.visitChildren(self)


    class LiteralStringContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_literal(self):
            return self.getTypedRuleContext(UL4Parser.String_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralString" ):
                return visitor.visitLiteralString(self)
            else:
                return visitor.visitChildren(self)


    class LiteralDatetimeContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datetime_literal(self):
            return self.getTypedRuleContext(UL4Parser.Datetime_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralDatetime" ):
                return visitor.visitLiteralDatetime(self)
            else:
                return visitor.visitChildren(self)


    class LiteralNoneContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def none_literal(self):
            return self.getTypedRuleContext(UL4Parser.None_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralNone" ):
                return visitor.visitLiteralNone(self)
            else:
                return visitor.visitChildren(self)


    class LiteralColorContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def color_literal(self):
            return self.getTypedRuleContext(UL4Parser.Color_literalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralColor" ):
                return visitor.visitLiteralColor(self)
            else:
                return visitor.visitChildren(self)



    def literal(self):

        localctx = UL4Parser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_literal)
        try:
            self.state = 261
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.LiteralNoneContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 253
                self.none_literal()
                pass

            elif la_ == 2:
                localctx = UL4Parser.LiteralBoolContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 254
                self.bool_literal()
                pass

            elif la_ == 3:
                localctx = UL4Parser.LiteralIntegerContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 255
                self.integer_literal()
                pass

            elif la_ == 4:
                localctx = UL4Parser.LiteralFloatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 256
                self.float_literal()
                pass

            elif la_ == 5:
                localctx = UL4Parser.LiteralStringContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 257
                self.string_literal()
                pass

            elif la_ == 6:
                localctx = UL4Parser.LiteralDateContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 258
                self.date_literal()
                pass

            elif la_ == 7:
                localctx = UL4Parser.LiteralDatetimeContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 259
                self.datetime_literal()
                pass

            elif la_ == 8:
                localctx = UL4Parser.LiteralColorContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 260
                self.color_literal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SeqitemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_seqitem

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnpackSeqItemContext(SeqitemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SeqitemContext
            super().__init__(parser)
            self.star = None # Token
            self.unpackitem = None # ExprContext
            self.copyFrom(ctx)

        def STAR(self):
            return self.getToken(UL4Parser.STAR, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnpackSeqItem" ):
                return visitor.visitUnpackSeqItem(self)
            else:
                return visitor.visitChildren(self)


    class SeqItemContext(SeqitemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SeqitemContext
            super().__init__(parser)
            self.item = None # ExprContext
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSeqItem" ):
                return visitor.visitSeqItem(self)
            else:
                return visitor.visitChildren(self)



    def seqitem(self):

        localctx = UL4Parser.SeqitemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_seqitem)
        try:
            self.state = 266
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UL4Parser.NOT, UL4Parser.NONE, UL4Parser.TRUE, UL4Parser.FALSE, UL4Parser.PARENS_OPEN, UL4Parser.BRACKET_OPEN, UL4Parser.BRACE_OPEN, UL4Parser.MINUS, UL4Parser.TILDE, UL4Parser.NAME, UL4Parser.INT, UL4Parser.FLOAT, UL4Parser.DATE, UL4Parser.COLOR, UL4Parser.STRING, UL4Parser.STRING3]:
                localctx = UL4Parser.SeqItemContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 263
                localctx.item = self.expr(0)
                pass
            elif token in [UL4Parser.STAR]:
                localctx = UL4Parser.UnpackSeqItemContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 264
                localctx.star = self.match(UL4Parser.STAR)
                self.state = 265
                localctx.unpackitem = self.expr(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_displayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_list_display

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ListEmptyContext(List_displayContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.List_displayContext
            super().__init__(parser)
            self.open_ = None # Token
            self.close = None # Token
            self.copyFrom(ctx)

        def BRACKET_OPEN(self):
            return self.getToken(UL4Parser.BRACKET_OPEN, 0)
        def BRACKET_CLOSE(self):
            return self.getToken(UL4Parser.BRACKET_CLOSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListEmpty" ):
                return visitor.visitListEmpty(self)
            else:
                return visitor.visitChildren(self)


    class ListContext(List_displayContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.List_displayContext
            super().__init__(parser)
            self.open_ = None # Token
            self._seqitem = None # SeqitemContext
            self.items = list() # of SeqitemContexts
            self.close = None # Token
            self.copyFrom(ctx)

        def BRACKET_OPEN(self):
            return self.getToken(UL4Parser.BRACKET_OPEN, 0)
        def seqitem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.SeqitemContext)
            else:
                return self.getTypedRuleContext(UL4Parser.SeqitemContext,i)

        def BRACKET_CLOSE(self):
            return self.getToken(UL4Parser.BRACKET_CLOSE, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList" ):
                return visitor.visitList(self)
            else:
                return visitor.visitChildren(self)



    def list_display(self):

        localctx = UL4Parser.List_displayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_list_display)
        self._la = 0 # Token type
        try:
            self.state = 284
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.ListEmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 268
                localctx.open_ = self.match(UL4Parser.BRACKET_OPEN)
                self.state = 269
                localctx.close = self.match(UL4Parser.BRACKET_CLOSE)
                pass

            elif la_ == 2:
                localctx = UL4Parser.ListContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 270
                localctx.open_ = self.match(UL4Parser.BRACKET_OPEN)
                self.state = 271
                localctx._seqitem = self.seqitem()
                localctx.items.append(localctx._seqitem)
                self.state = 276
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,27,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 272
                        self.match(UL4Parser.COMMA)
                        self.state = 273
                        localctx._seqitem = self.seqitem()
                        localctx.items.append(localctx._seqitem) 
                    self.state = 278
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

                self.state = 280
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 279
                    self.match(UL4Parser.COMMA)


                self.state = 282
                localctx.close = self.match(UL4Parser.BRACKET_CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListcomprehensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_listcomprehension

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Listcomprehension2Context(ListcomprehensionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ListcomprehensionContext
            super().__init__(parser)
            self.open_ = None # Token
            self.item = None # ExprContext
            self.varname = None # NestedlvalueContext
            self.container = None # ExprContext
            self.condition = None # ExprContext
            self.close = None # Token
            self.copyFrom(ctx)

        def FOR(self):
            return self.getToken(UL4Parser.FOR, 0)
        def IN(self):
            return self.getToken(UL4Parser.IN, 0)
        def BRACKET_OPEN(self):
            return self.getToken(UL4Parser.BRACKET_OPEN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)

        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)

        def BRACKET_CLOSE(self):
            return self.getToken(UL4Parser.BRACKET_CLOSE, 0)
        def IF(self):
            return self.getToken(UL4Parser.IF, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListcomprehension2" ):
                return visitor.visitListcomprehension2(self)
            else:
                return visitor.visitChildren(self)



    def listcomprehension(self):

        localctx = UL4Parser.ListcomprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_listcomprehension)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.Listcomprehension2Context(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            localctx.open_ = self.match(UL4Parser.BRACKET_OPEN)
            self.state = 287
            localctx.item = self.expr(0)
            self.state = 288
            self.match(UL4Parser.FOR)
            self.state = 289
            localctx.varname = self.nestedlvalue()
            self.state = 290
            self.match(UL4Parser.IN)
            self.state = 291
            localctx.container = self.expr(0)
            self.state = 294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.IF:
                self.state = 292
                self.match(UL4Parser.IF)
                self.state = 293
                localctx.condition = self.expr(0)


            self.state = 296
            localctx.close = self.match(UL4Parser.BRACKET_CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_displayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_set_display

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SetEmptyContext(Set_displayContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Set_displayContext
            super().__init__(parser)
            self.open_ = None # Token
            self.close = None # Token
            self.copyFrom(ctx)

        def SLASH(self):
            return self.getToken(UL4Parser.SLASH, 0)
        def BRACE_OPEN(self):
            return self.getToken(UL4Parser.BRACE_OPEN, 0)
        def BRACE_CLOSE(self):
            return self.getToken(UL4Parser.BRACE_CLOSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetEmpty" ):
                return visitor.visitSetEmpty(self)
            else:
                return visitor.visitChildren(self)


    class SetContext(Set_displayContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Set_displayContext
            super().__init__(parser)
            self.open_ = None # Token
            self._seqitem = None # SeqitemContext
            self.items = list() # of SeqitemContexts
            self.close = None # Token
            self.copyFrom(ctx)

        def BRACE_OPEN(self):
            return self.getToken(UL4Parser.BRACE_OPEN, 0)
        def seqitem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.SeqitemContext)
            else:
                return self.getTypedRuleContext(UL4Parser.SeqitemContext,i)

        def BRACE_CLOSE(self):
            return self.getToken(UL4Parser.BRACE_CLOSE, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSet" ):
                return visitor.visitSet(self)
            else:
                return visitor.visitChildren(self)



    def set_display(self):

        localctx = UL4Parser.Set_displayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_set_display)
        self._la = 0 # Token type
        try:
            self.state = 315
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.SetEmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 298
                localctx.open_ = self.match(UL4Parser.BRACE_OPEN)
                self.state = 299
                self.match(UL4Parser.SLASH)
                self.state = 300
                localctx.close = self.match(UL4Parser.BRACE_CLOSE)
                pass

            elif la_ == 2:
                localctx = UL4Parser.SetContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 301
                localctx.open_ = self.match(UL4Parser.BRACE_OPEN)
                self.state = 302
                localctx._seqitem = self.seqitem()
                localctx.items.append(localctx._seqitem)
                self.state = 307
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 303
                        self.match(UL4Parser.COMMA)
                        self.state = 304
                        localctx._seqitem = self.seqitem()
                        localctx.items.append(localctx._seqitem) 
                    self.state = 309
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                self.state = 311
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 310
                    self.match(UL4Parser.COMMA)


                self.state = 313
                localctx.close = self.match(UL4Parser.BRACE_CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetcomprehensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_setcomprehension

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Setcomprehension2Context(SetcomprehensionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SetcomprehensionContext
            super().__init__(parser)
            self.open_ = None # Token
            self.item = None # ExprContext
            self.varname = None # NestedlvalueContext
            self.container = None # ExprContext
            self.condition = None # ExprContext
            self.close = None # Token
            self.copyFrom(ctx)

        def FOR(self):
            return self.getToken(UL4Parser.FOR, 0)
        def IN(self):
            return self.getToken(UL4Parser.IN, 0)
        def BRACE_OPEN(self):
            return self.getToken(UL4Parser.BRACE_OPEN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)

        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)

        def BRACE_CLOSE(self):
            return self.getToken(UL4Parser.BRACE_CLOSE, 0)
        def IF(self):
            return self.getToken(UL4Parser.IF, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetcomprehension2" ):
                return visitor.visitSetcomprehension2(self)
            else:
                return visitor.visitChildren(self)



    def setcomprehension(self):

        localctx = UL4Parser.SetcomprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_setcomprehension)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.Setcomprehension2Context(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            localctx.open_ = self.match(UL4Parser.BRACE_OPEN)
            self.state = 318
            localctx.item = self.expr(0)
            self.state = 319
            self.match(UL4Parser.FOR)
            self.state = 320
            localctx.varname = self.nestedlvalue()
            self.state = 321
            self.match(UL4Parser.IN)
            self.state = 322
            localctx.container = self.expr(0)
            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.IF:
                self.state = 323
                self.match(UL4Parser.IF)
                self.state = 324
                localctx.condition = self.expr(0)


            self.state = 327
            localctx.close = self.match(UL4Parser.BRACE_CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DictitemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_dictitem

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Dictitem2Context(DictitemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.DictitemContext
            super().__init__(parser)
            self.key = None # ExprContext
            self.value = None # ExprContext
            self.copyFrom(ctx)

        def COLON(self):
            return self.getToken(UL4Parser.COLON, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDictitem2" ):
                return visitor.visitDictitem2(self)
            else:
                return visitor.visitChildren(self)


    class UnpackDictItemContext(DictitemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.DictitemContext
            super().__init__(parser)
            self.star = None # Token
            self.unpackitem = None # ExprContext
            self.copyFrom(ctx)

        def STAR_STAR(self):
            return self.getToken(UL4Parser.STAR_STAR, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnpackDictItem" ):
                return visitor.visitUnpackDictItem(self)
            else:
                return visitor.visitChildren(self)



    def dictitem(self):

        localctx = UL4Parser.DictitemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_dictitem)
        try:
            self.state = 335
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UL4Parser.NOT, UL4Parser.NONE, UL4Parser.TRUE, UL4Parser.FALSE, UL4Parser.PARENS_OPEN, UL4Parser.BRACKET_OPEN, UL4Parser.BRACE_OPEN, UL4Parser.MINUS, UL4Parser.TILDE, UL4Parser.NAME, UL4Parser.INT, UL4Parser.FLOAT, UL4Parser.DATE, UL4Parser.COLOR, UL4Parser.STRING, UL4Parser.STRING3]:
                localctx = UL4Parser.Dictitem2Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 329
                localctx.key = self.expr(0)
                self.state = 330
                self.match(UL4Parser.COLON)
                self.state = 331
                localctx.value = self.expr(0)
                pass
            elif token in [UL4Parser.STAR_STAR]:
                localctx = UL4Parser.UnpackDictItemContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 333
                localctx.star = self.match(UL4Parser.STAR_STAR)
                self.state = 334
                localctx.unpackitem = self.expr(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dict_displayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_dict_display

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DictEmptyContext(Dict_displayContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Dict_displayContext
            super().__init__(parser)
            self.open_ = None # Token
            self.close = None # Token
            self.copyFrom(ctx)

        def BRACE_OPEN(self):
            return self.getToken(UL4Parser.BRACE_OPEN, 0)
        def BRACE_CLOSE(self):
            return self.getToken(UL4Parser.BRACE_CLOSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDictEmpty" ):
                return visitor.visitDictEmpty(self)
            else:
                return visitor.visitChildren(self)


    class DictContext(Dict_displayContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Dict_displayContext
            super().__init__(parser)
            self.open_ = None # Token
            self._dictitem = None # DictitemContext
            self.items = list() # of DictitemContexts
            self.close = None # Token
            self.copyFrom(ctx)

        def BRACE_OPEN(self):
            return self.getToken(UL4Parser.BRACE_OPEN, 0)
        def dictitem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.DictitemContext)
            else:
                return self.getTypedRuleContext(UL4Parser.DictitemContext,i)

        def BRACE_CLOSE(self):
            return self.getToken(UL4Parser.BRACE_CLOSE, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDict" ):
                return visitor.visitDict(self)
            else:
                return visitor.visitChildren(self)



    def dict_display(self):

        localctx = UL4Parser.Dict_displayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_dict_display)
        self._la = 0 # Token type
        try:
            self.state = 353
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.DictEmptyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 337
                localctx.open_ = self.match(UL4Parser.BRACE_OPEN)
                self.state = 338
                localctx.close = self.match(UL4Parser.BRACE_CLOSE)
                pass

            elif la_ == 2:
                localctx = UL4Parser.DictContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 339
                localctx.open_ = self.match(UL4Parser.BRACE_OPEN)
                self.state = 340
                localctx._dictitem = self.dictitem()
                localctx.items.append(localctx._dictitem)
                self.state = 345
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,36,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 341
                        self.match(UL4Parser.COMMA)
                        self.state = 342
                        localctx._dictitem = self.dictitem()
                        localctx.items.append(localctx._dictitem) 
                    self.state = 347
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,36,self._ctx)

                self.state = 349
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 348
                    self.match(UL4Parser.COMMA)


                self.state = 351
                localctx.close = self.match(UL4Parser.BRACE_CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DictcomprehensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_dictcomprehension

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Dictcomprehension2Context(DictcomprehensionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.DictcomprehensionContext
            super().__init__(parser)
            self.open_ = None # Token
            self.key = None # ExprContext
            self.value = None # ExprContext
            self.varname = None # NestedlvalueContext
            self.container = None # ExprContext
            self.condition = None # ExprContext
            self.close = None # Token
            self.copyFrom(ctx)

        def COLON(self):
            return self.getToken(UL4Parser.COLON, 0)
        def FOR(self):
            return self.getToken(UL4Parser.FOR, 0)
        def IN(self):
            return self.getToken(UL4Parser.IN, 0)
        def BRACE_OPEN(self):
            return self.getToken(UL4Parser.BRACE_OPEN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)

        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)

        def BRACE_CLOSE(self):
            return self.getToken(UL4Parser.BRACE_CLOSE, 0)
        def IF(self):
            return self.getToken(UL4Parser.IF, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDictcomprehension2" ):
                return visitor.visitDictcomprehension2(self)
            else:
                return visitor.visitChildren(self)



    def dictcomprehension(self):

        localctx = UL4Parser.DictcomprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_dictcomprehension)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.Dictcomprehension2Context(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            localctx.open_ = self.match(UL4Parser.BRACE_OPEN)
            self.state = 356
            localctx.key = self.expr(0)
            self.state = 357
            self.match(UL4Parser.COLON)
            self.state = 358
            localctx.value = self.expr(0)
            self.state = 359
            self.match(UL4Parser.FOR)
            self.state = 360
            localctx.varname = self.nestedlvalue()
            self.state = 361
            self.match(UL4Parser.IN)
            self.state = 362
            localctx.container = self.expr(0)
            self.state = 365
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.IF:
                self.state = 363
                self.match(UL4Parser.IF)
                self.state = 364
                localctx.condition = self.expr(0)


            self.state = 367
            localctx.close = self.match(UL4Parser.BRACE_CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GeneratorexpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_generatorexpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GeneratorExpresssionContext(GeneratorexpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.GeneratorexpressionContext
            super().__init__(parser)
            self.item = None # ExprContext
            self.varname = None # NestedlvalueContext
            self.container = None # ExprContext
            self.condition = None # ExprContext
            self.copyFrom(ctx)

        def FOR(self):
            return self.getToken(UL4Parser.FOR, 0)
        def IN(self):
            return self.getToken(UL4Parser.IN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)

        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)

        def IF(self):
            return self.getToken(UL4Parser.IF, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneratorExpresssion" ):
                return visitor.visitGeneratorExpresssion(self)
            else:
                return visitor.visitChildren(self)



    def generatorexpression(self):

        localctx = UL4Parser.GeneratorexpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_generatorexpression)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.GeneratorExpresssionContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 369
            localctx.item = self.expr(0)
            self.state = 370
            self.match(UL4Parser.FOR)
            self.state = 371
            localctx.varname = self.nestedlvalue()
            self.state = 372
            self.match(UL4Parser.IN)
            self.state = 373
            localctx.container = self.expr(0)
            self.state = 376
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.IF:
                self.state = 374
                self.match(UL4Parser.IF)
                self.state = 375
                localctx.condition = self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_atom

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AtomNameContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # NameContext
            self.copyFrom(ctx)

        def name(self):
            return self.getTypedRuleContext(UL4Parser.NameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomName" ):
                return visitor.visitAtomName(self)
            else:
                return visitor.visitChildren(self)


    class AtomListContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # List_displayContext
            self.copyFrom(ctx)

        def list_display(self):
            return self.getTypedRuleContext(UL4Parser.List_displayContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomList" ):
                return visitor.visitAtomList(self)
            else:
                return visitor.visitChildren(self)


    class AtomLiteralContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # LiteralContext
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(UL4Parser.LiteralContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomLiteral" ):
                return visitor.visitAtomLiteral(self)
            else:
                return visitor.visitChildren(self)


    class AtomDictComprehensionContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # DictcomprehensionContext
            self.copyFrom(ctx)

        def dictcomprehension(self):
            return self.getTypedRuleContext(UL4Parser.DictcomprehensionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomDictComprehension" ):
                return visitor.visitAtomDictComprehension(self)
            else:
                return visitor.visitChildren(self)


    class AtomListComprehensionContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # ListcomprehensionContext
            self.copyFrom(ctx)

        def listcomprehension(self):
            return self.getTypedRuleContext(UL4Parser.ListcomprehensionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomListComprehension" ):
                return visitor.visitAtomListComprehension(self)
            else:
                return visitor.visitChildren(self)


    class AtomSetContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # Set_displayContext
            self.copyFrom(ctx)

        def set_display(self):
            return self.getTypedRuleContext(UL4Parser.Set_displayContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomSet" ):
                return visitor.visitAtomSet(self)
            else:
                return visitor.visitChildren(self)


    class AtomSetComprehensionContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # SetcomprehensionContext
            self.copyFrom(ctx)

        def setcomprehension(self):
            return self.getTypedRuleContext(UL4Parser.SetcomprehensionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomSetComprehension" ):
                return visitor.visitAtomSetComprehension(self)
            else:
                return visitor.visitChildren(self)


    class AtomGeneratorExpressionContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # GeneratorexpressionContext
            self.copyFrom(ctx)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def generatorexpression(self):
            return self.getTypedRuleContext(UL4Parser.GeneratorexpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomGeneratorExpression" ):
                return visitor.visitAtomGeneratorExpression(self)
            else:
                return visitor.visitChildren(self)


    class AtomBracketContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # ExprContext
            self.copyFrom(ctx)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomBracket" ):
                return visitor.visitAtomBracket(self)
            else:
                return visitor.visitChildren(self)


    class AtomDictContext(AtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.AtomContext
            super().__init__(parser)
            self.arg = None # Dict_displayContext
            self.copyFrom(ctx)

        def dict_display(self):
            return self.getTypedRuleContext(UL4Parser.Dict_displayContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomDict" ):
                return visitor.visitAtomDict(self)
            else:
                return visitor.visitChildren(self)



    def atom(self):

        localctx = UL4Parser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_atom)
        try:
            self.state = 394
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.AtomNameContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 378
                localctx.arg = self.name()
                pass

            elif la_ == 2:
                localctx = UL4Parser.AtomLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 379
                localctx.arg = self.literal()
                pass

            elif la_ == 3:
                localctx = UL4Parser.AtomListContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 380
                localctx.arg = self.list_display()
                pass

            elif la_ == 4:
                localctx = UL4Parser.AtomListComprehensionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 381
                localctx.arg = self.listcomprehension()
                pass

            elif la_ == 5:
                localctx = UL4Parser.AtomSetContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 382
                localctx.arg = self.set_display()
                pass

            elif la_ == 6:
                localctx = UL4Parser.AtomSetComprehensionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 383
                localctx.arg = self.setcomprehension()
                pass

            elif la_ == 7:
                localctx = UL4Parser.AtomDictContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 384
                localctx.arg = self.dict_display()
                pass

            elif la_ == 8:
                localctx = UL4Parser.AtomDictComprehensionContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 385
                localctx.arg = self.dictcomprehension()
                pass

            elif la_ == 9:
                localctx = UL4Parser.AtomGeneratorExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 386
                self.match(UL4Parser.PARENS_OPEN)
                self.state = 387
                localctx.arg = self.generatorexpression()
                self.state = 388
                self.match(UL4Parser.PARENS_CLOSE)
                pass

            elif la_ == 10:
                localctx = UL4Parser.AtomBracketContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 390
                self.match(UL4Parser.PARENS_OPEN)
                self.state = 391
                localctx.arg = self.expr(0)
                self.state = 392
                self.match(UL4Parser.PARENS_CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedlvalueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_nestedlvalue

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LValueMultiContext(NestedlvalueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.NestedlvalueContext
            super().__init__(parser)
            self._nestedlvalue = None # NestedlvalueContext
            self.lvalue = list() # of NestedlvalueContexts
            self.copyFrom(ctx)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)
        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def nestedlvalue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.NestedlvalueContext)
            else:
                return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLValueMulti" ):
                return visitor.visitLValueMulti(self)
            else:
                return visitor.visitChildren(self)


    class LValueSimpleContext(NestedlvalueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.NestedlvalueContext
            super().__init__(parser)
            self.lvalue = None # ExprContext
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLValueSimple" ):
                return visitor.visitLValueSimple(self)
            else:
                return visitor.visitChildren(self)


    class LValueOneContext(NestedlvalueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.NestedlvalueContext
            super().__init__(parser)
            self.lvalue = None # NestedlvalueContext
            self.copyFrom(ctx)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def COMMA(self):
            return self.getToken(UL4Parser.COMMA, 0)
        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLValueOne" ):
                return visitor.visitLValueOne(self)
            else:
                return visitor.visitChildren(self)



    def nestedlvalue(self):

        localctx = UL4Parser.NestedlvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_nestedlvalue)
        self._la = 0 # Token type
        try:
            self.state = 418
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.LValueSimpleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 396
                localctx.lvalue = self.expr(0)
                pass

            elif la_ == 2:
                localctx = UL4Parser.LValueOneContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 397
                self.match(UL4Parser.PARENS_OPEN)
                self.state = 398
                localctx.lvalue = self.nestedlvalue()
                self.state = 399
                self.match(UL4Parser.COMMA)
                self.state = 400
                self.match(UL4Parser.PARENS_CLOSE)
                pass

            elif la_ == 3:
                localctx = UL4Parser.LValueMultiContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 402
                self.match(UL4Parser.PARENS_OPEN)
                self.state = 403
                localctx._nestedlvalue = self.nestedlvalue()
                localctx.lvalue.append(localctx._nestedlvalue)
                self.state = 404
                self.match(UL4Parser.COMMA)
                self.state = 405
                localctx._nestedlvalue = self.nestedlvalue()
                localctx.lvalue.append(localctx._nestedlvalue)
                self.state = 410
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 406
                        self.match(UL4Parser.COMMA)
                        self.state = 407
                        localctx._nestedlvalue = self.nestedlvalue()
                        localctx.lvalue.append(localctx._nestedlvalue) 
                    self.state = 412
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

                self.state = 414
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 413
                    self.match(UL4Parser.COMMA)


                self.state = 416
                self.match(UL4Parser.PARENS_CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Slice_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_slice_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SliceContext(Slice_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Slice_Context
            super().__init__(parser)
            self.index1 = None # ExprContext
            self.colon = None # Token
            self.index2 = None # ExprContext
            self.copyFrom(ctx)

        def COLON(self):
            return self.getToken(UL4Parser.COLON, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSlice" ):
                return visitor.visitSlice(self)
            else:
                return visitor.visitChildren(self)



    def slice_(self):

        localctx = UL4Parser.Slice_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_slice_)
        self._la = 0 # Token type
        try:
            localctx = UL4Parser.SliceContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 421
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (UL4Parser.NOT - 37)) | (1 << (UL4Parser.NONE - 37)) | (1 << (UL4Parser.TRUE - 37)) | (1 << (UL4Parser.FALSE - 37)) | (1 << (UL4Parser.PARENS_OPEN - 37)) | (1 << (UL4Parser.BRACKET_OPEN - 37)) | (1 << (UL4Parser.BRACE_OPEN - 37)) | (1 << (UL4Parser.MINUS - 37)) | (1 << (UL4Parser.TILDE - 37)) | (1 << (UL4Parser.NAME - 37)) | (1 << (UL4Parser.INT - 37)) | (1 << (UL4Parser.FLOAT - 37)) | (1 << (UL4Parser.DATE - 37)) | (1 << (UL4Parser.COLOR - 37)) | (1 << (UL4Parser.STRING - 37)) | (1 << (UL4Parser.STRING3 - 37)))) != 0):
                self.state = 420
                localctx.index1 = self.expr(0)


            self.state = 423
            localctx.colon = self.match(UL4Parser.COLON)
            self.state = 425
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (UL4Parser.NOT - 37)) | (1 << (UL4Parser.NONE - 37)) | (1 << (UL4Parser.TRUE - 37)) | (1 << (UL4Parser.FALSE - 37)) | (1 << (UL4Parser.PARENS_OPEN - 37)) | (1 << (UL4Parser.BRACKET_OPEN - 37)) | (1 << (UL4Parser.BRACE_OPEN - 37)) | (1 << (UL4Parser.MINUS - 37)) | (1 << (UL4Parser.TILDE - 37)) | (1 << (UL4Parser.NAME - 37)) | (1 << (UL4Parser.INT - 37)) | (1 << (UL4Parser.FLOAT - 37)) | (1 << (UL4Parser.DATE - 37)) | (1 << (UL4Parser.COLOR - 37)) | (1 << (UL4Parser.STRING - 37)) | (1 << (UL4Parser.STRING3 - 37)))) != 0):
                self.state = 424
                localctx.index2 = self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_argument

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnpackDictArgContext(ArgumentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ArgumentContext
            super().__init__(parser)
            self.star = None # Token
            self.argvalue = None # ExprargContext
            self.copyFrom(ctx)

        def STAR_STAR(self):
            return self.getToken(UL4Parser.STAR_STAR, 0)
        def exprarg(self):
            return self.getTypedRuleContext(UL4Parser.ExprargContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnpackDictArg" ):
                return visitor.visitUnpackDictArg(self)
            else:
                return visitor.visitChildren(self)


    class PosArgContext(ArgumentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ArgumentContext
            super().__init__(parser)
            self.argvalue = None # ExprargContext
            self.copyFrom(ctx)

        def exprarg(self):
            return self.getTypedRuleContext(UL4Parser.ExprargContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosArg" ):
                return visitor.visitPosArg(self)
            else:
                return visitor.visitChildren(self)


    class KeywordArgContext(ArgumentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ArgumentContext
            super().__init__(parser)
            self.argname = None # NameContext
            self.argvalue = None # ExprargContext
            self.copyFrom(ctx)

        def ASSIGN(self):
            return self.getToken(UL4Parser.ASSIGN, 0)
        def name(self):
            return self.getTypedRuleContext(UL4Parser.NameContext,0)

        def exprarg(self):
            return self.getTypedRuleContext(UL4Parser.ExprargContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeywordArg" ):
                return visitor.visitKeywordArg(self)
            else:
                return visitor.visitChildren(self)


    class UnpackListArgContext(ArgumentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ArgumentContext
            super().__init__(parser)
            self.star = None # Token
            self.argvalue = None # ExprargContext
            self.copyFrom(ctx)

        def STAR(self):
            return self.getToken(UL4Parser.STAR, 0)
        def exprarg(self):
            return self.getTypedRuleContext(UL4Parser.ExprargContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnpackListArg" ):
                return visitor.visitUnpackListArg(self)
            else:
                return visitor.visitChildren(self)



    def argument(self):

        localctx = UL4Parser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_argument)
        try:
            self.state = 436
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.PosArgContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 427
                localctx.argvalue = self.exprarg()
                pass

            elif la_ == 2:
                localctx = UL4Parser.KeywordArgContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 428
                localctx.argname = self.name()
                self.state = 429
                self.match(UL4Parser.ASSIGN)
                self.state = 430
                localctx.argvalue = self.exprarg()
                pass

            elif la_ == 3:
                localctx = UL4Parser.UnpackListArgContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 432
                localctx.star = self.match(UL4Parser.STAR)
                self.state = 433
                localctx.argvalue = self.exprarg()
                pass

            elif la_ == 4:
                localctx = UL4Parser.UnpackDictArgContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 434
                localctx.star = self.match(UL4Parser.STAR_STAR)
                self.state = 435
                localctx.argvalue = self.exprarg()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class AddContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def PLUS(self):
            return self.getToken(UL4Parser.PLUS, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)


    class ShiftRightContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def SHIFTRIGHT(self):
            return self.getToken(UL4Parser.SHIFTRIGHT, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShiftRight" ):
                return visitor.visitShiftRight(self)
            else:
                return visitor.visitChildren(self)


    class OrContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def OR(self):
            return self.getToken(UL4Parser.OR, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOr" ):
                return visitor.visitOr(self)
            else:
                return visitor.visitChildren(self)


    class LTContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def LESS_THAN(self):
            return self.getToken(UL4Parser.LESS_THAN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLT" ):
                return visitor.visitLT(self)
            else:
                return visitor.visitChildren(self)


    class IsContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(UL4Parser.IS, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIs" ):
                return visitor.visitIs(self)
            else:
                return visitor.visitChildren(self)


    class AttrContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.e1 = None # ExprContext
            self.n = None # NameContext
            self.copyFrom(ctx)

        def DOT(self):
            return self.getToken(UL4Parser.DOT, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)

        def name(self):
            return self.getTypedRuleContext(UL4Parser.NameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttr" ):
                return visitor.visitAttr(self)
            else:
                return visitor.visitChildren(self)


    class ItemContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.e1 = None # ExprContext
            self.index = None # ExprContext
            self.close = None # Token
            self.copyFrom(ctx)

        def BRACKET_OPEN(self):
            return self.getToken(UL4Parser.BRACKET_OPEN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)

        def BRACKET_CLOSE(self):
            return self.getToken(UL4Parser.BRACKET_CLOSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitItem" ):
                return visitor.visitItem(self)
            else:
                return visitor.visitChildren(self)


    class BitXOrContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def CARET(self):
            return self.getToken(UL4Parser.CARET, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitXOr" ):
                return visitor.visitBitXOr(self)
            else:
                return visitor.visitChildren(self)


    class IsNotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(UL4Parser.IS, 0)
        def NOT(self):
            return self.getToken(UL4Parser.NOT, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsNot" ):
                return visitor.visitIsNot(self)
            else:
                return visitor.visitChildren(self)


    class GEContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def GREATER_THAN_OR_EQUAL(self):
            return self.getToken(UL4Parser.GREATER_THAN_OR_EQUAL, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGE" ):
                return visitor.visitGE(self)
            else:
                return visitor.visitChildren(self)


    class SubContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def MINUS(self):
            return self.getToken(UL4Parser.MINUS, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)


    class CallContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.e1 = None # ExprContext
            self._argument = None # ArgumentContext
            self.args = list() # of ArgumentContexts
            self.close = None # Token
            self.copyFrom(ctx)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)

        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ArgumentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ArgumentContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall" ):
                return visitor.visitCall(self)
            else:
                return visitor.visitChildren(self)


    class NotContainsContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(UL4Parser.NOT, 0)
        def IN(self):
            return self.getToken(UL4Parser.IN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotContains" ):
                return visitor.visitNotContains(self)
            else:
                return visitor.visitChildren(self)


    class ModContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def PERCENT(self):
            return self.getToken(UL4Parser.PERCENT, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMod" ):
                return visitor.visitMod(self)
            else:
                return visitor.visitChildren(self)


    class BitOrContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def BAR(self):
            return self.getToken(UL4Parser.BAR, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitOr" ):
                return visitor.visitBitOr(self)
            else:
                return visitor.visitChildren(self)


    class ShiftLeftContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def SHIFTLEFT(self):
            return self.getToken(UL4Parser.SHIFTLEFT, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShiftLeft" ):
                return visitor.visitShiftLeft(self)
            else:
                return visitor.visitChildren(self)


    class MulContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def STAR(self):
            return self.getToken(UL4Parser.STAR, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMul" ):
                return visitor.visitMul(self)
            else:
                return visitor.visitChildren(self)


    class ExprAtomContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.e = None # AtomContext
            self.copyFrom(ctx)

        def atom(self):
            return self.getTypedRuleContext(UL4Parser.AtomContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprAtom" ):
                return visitor.visitExprAtom(self)
            else:
                return visitor.visitChildren(self)


    class FloorDivContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def SLASH_SLASH(self):
            return self.getToken(UL4Parser.SLASH_SLASH, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloorDiv" ):
                return visitor.visitFloorDiv(self)
            else:
                return visitor.visitChildren(self)


    class EQContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def EQUAL(self):
            return self.getToken(UL4Parser.EQUAL, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEQ" ):
                return visitor.visitEQ(self)
            else:
                return visitor.visitChildren(self)


    class GTContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def GREATER_THAN(self):
            return self.getToken(UL4Parser.GREATER_THAN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGT" ):
                return visitor.visitGT(self)
            else:
                return visitor.visitChildren(self)


    class TrueDivContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def SLASH(self):
            return self.getToken(UL4Parser.SLASH, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrueDiv" ):
                return visitor.visitTrueDiv(self)
            else:
                return visitor.visitChildren(self)


    class NegContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.arg = None # ExprContext
            self.copyFrom(ctx)

        def MINUS(self):
            return self.getToken(UL4Parser.MINUS, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNeg" ):
                return visitor.visitNeg(self)
            else:
                return visitor.visitChildren(self)


    class NotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.e = None # ExprContext
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(UL4Parser.NOT, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNot" ):
                return visitor.visitNot(self)
            else:
                return visitor.visitChildren(self)


    class AndContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def AND(self):
            return self.getToken(UL4Parser.AND, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnd" ):
                return visitor.visitAnd(self)
            else:
                return visitor.visitChildren(self)


    class BitAndContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def AMPERSAND(self):
            return self.getToken(UL4Parser.AMPERSAND, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitAnd" ):
                return visitor.visitBitAnd(self)
            else:
                return visitor.visitChildren(self)


    class NEContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def NOT_EQUAL(self):
            return self.getToken(UL4Parser.NOT_EQUAL, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNE" ):
                return visitor.visitNE(self)
            else:
                return visitor.visitChildren(self)


    class ContainsContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def IN(self):
            return self.getToken(UL4Parser.IN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContains" ):
                return visitor.visitContains(self)
            else:
                return visitor.visitChildren(self)


    class LEContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def LESS_THAN_OR_EQUAL(self):
            return self.getToken(UL4Parser.LESS_THAN_OR_EQUAL, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLE" ):
                return visitor.visitLE(self)
            else:
                return visitor.visitChildren(self)


    class ItemSliceContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.e1 = None # ExprContext
            self.index = None # Slice_Context
            self.close = None # Token
            self.copyFrom(ctx)

        def BRACKET_OPEN(self):
            return self.getToken(UL4Parser.BRACKET_OPEN, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)

        def slice_(self):
            return self.getTypedRuleContext(UL4Parser.Slice_Context,0)

        def BRACKET_CLOSE(self):
            return self.getToken(UL4Parser.BRACKET_CLOSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitItemSlice" ):
                return visitor.visitItemSlice(self)
            else:
                return visitor.visitChildren(self)


    class BitNotContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.arg = None # ExprContext
            self.copyFrom(ctx)

        def TILDE(self):
            return self.getToken(UL4Parser.TILDE, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitNot" ):
                return visitor.visitBitNot(self)
            else:
                return visitor.visitChildren(self)


    class IfContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExprContext
            super().__init__(parser)
            self.argif = None # ExprContext
            self.argcond = None # ExprContext
            self.argelse = None # ExprContext
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(UL4Parser.IF, 0)
        def ELSE(self):
            return self.getToken(UL4Parser.ELSE, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf" ):
                return visitor.visitIf(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = UL4Parser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 64
        self.enterRecursionRule(localctx, 64, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 446
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [UL4Parser.NONE, UL4Parser.TRUE, UL4Parser.FALSE, UL4Parser.PARENS_OPEN, UL4Parser.BRACKET_OPEN, UL4Parser.BRACE_OPEN, UL4Parser.NAME, UL4Parser.INT, UL4Parser.FLOAT, UL4Parser.DATE, UL4Parser.COLOR, UL4Parser.STRING, UL4Parser.STRING3]:
                localctx = UL4Parser.ExprAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 439
                localctx.e = self.atom()
                pass
            elif token in [UL4Parser.MINUS]:
                localctx = UL4Parser.NegContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 440
                self.match(UL4Parser.MINUS)
                self.state = 441
                localctx.arg = self.expr(27)
                pass
            elif token in [UL4Parser.TILDE]:
                localctx = UL4Parser.BitNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 442
                self.match(UL4Parser.TILDE)
                self.state = 443
                localctx.arg = self.expr(26)
                pass
            elif token in [UL4Parser.NOT]:
                localctx = UL4Parser.NotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 444
                self.match(UL4Parser.NOT)
                self.state = 445
                localctx.e = self.expr(4)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 559
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,53,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 557
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
                    if la_ == 1:
                        localctx = UL4Parser.MulContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 448
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 449
                        self.match(UL4Parser.STAR)
                        self.state = 450
                        localctx.right = self.expr(26)
                        pass

                    elif la_ == 2:
                        localctx = UL4Parser.TrueDivContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 451
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 452
                        self.match(UL4Parser.SLASH)
                        self.state = 453
                        localctx.right = self.expr(25)
                        pass

                    elif la_ == 3:
                        localctx = UL4Parser.FloorDivContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 454
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 455
                        self.match(UL4Parser.SLASH_SLASH)
                        self.state = 456
                        localctx.right = self.expr(24)
                        pass

                    elif la_ == 4:
                        localctx = UL4Parser.ModContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 457
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 458
                        self.match(UL4Parser.PERCENT)
                        self.state = 459
                        localctx.right = self.expr(23)
                        pass

                    elif la_ == 5:
                        localctx = UL4Parser.AddContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 460
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 461
                        self.match(UL4Parser.PLUS)
                        self.state = 462
                        localctx.right = self.expr(22)
                        pass

                    elif la_ == 6:
                        localctx = UL4Parser.SubContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 463
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 464
                        self.match(UL4Parser.MINUS)
                        self.state = 465
                        localctx.right = self.expr(21)
                        pass

                    elif la_ == 7:
                        localctx = UL4Parser.ShiftLeftContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 466
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 467
                        self.match(UL4Parser.SHIFTLEFT)
                        self.state = 468
                        localctx.right = self.expr(20)
                        pass

                    elif la_ == 8:
                        localctx = UL4Parser.ShiftRightContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 469
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 470
                        self.match(UL4Parser.SHIFTRIGHT)
                        self.state = 471
                        localctx.right = self.expr(19)
                        pass

                    elif la_ == 9:
                        localctx = UL4Parser.BitAndContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 472
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 473
                        self.match(UL4Parser.AMPERSAND)
                        self.state = 474
                        localctx.right = self.expr(18)
                        pass

                    elif la_ == 10:
                        localctx = UL4Parser.BitXOrContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 475
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 476
                        self.match(UL4Parser.CARET)
                        self.state = 477
                        localctx.right = self.expr(17)
                        pass

                    elif la_ == 11:
                        localctx = UL4Parser.BitOrContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 478
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 479
                        self.match(UL4Parser.BAR)
                        self.state = 480
                        localctx.right = self.expr(16)
                        pass

                    elif la_ == 12:
                        localctx = UL4Parser.EQContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 481
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 482
                        self.match(UL4Parser.EQUAL)
                        self.state = 483
                        localctx.right = self.expr(15)
                        pass

                    elif la_ == 13:
                        localctx = UL4Parser.NEContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 484
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 485
                        self.match(UL4Parser.NOT_EQUAL)
                        self.state = 486
                        localctx.right = self.expr(14)
                        pass

                    elif la_ == 14:
                        localctx = UL4Parser.LTContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 487
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 488
                        self.match(UL4Parser.LESS_THAN)
                        self.state = 489
                        localctx.right = self.expr(13)
                        pass

                    elif la_ == 15:
                        localctx = UL4Parser.LEContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 490
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 491
                        self.match(UL4Parser.LESS_THAN_OR_EQUAL)
                        self.state = 492
                        localctx.right = self.expr(12)
                        pass

                    elif la_ == 16:
                        localctx = UL4Parser.GTContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 493
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 494
                        self.match(UL4Parser.GREATER_THAN)
                        self.state = 495
                        localctx.right = self.expr(11)
                        pass

                    elif la_ == 17:
                        localctx = UL4Parser.GEContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 496
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 497
                        self.match(UL4Parser.GREATER_THAN_OR_EQUAL)
                        self.state = 498
                        localctx.right = self.expr(10)
                        pass

                    elif la_ == 18:
                        localctx = UL4Parser.ContainsContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 499
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 500
                        self.match(UL4Parser.IN)
                        self.state = 501
                        localctx.right = self.expr(9)
                        pass

                    elif la_ == 19:
                        localctx = UL4Parser.NotContainsContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 502
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 503
                        self.match(UL4Parser.NOT)
                        self.state = 504
                        self.match(UL4Parser.IN)
                        self.state = 505
                        localctx.right = self.expr(8)
                        pass

                    elif la_ == 20:
                        localctx = UL4Parser.IsContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 506
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 507
                        self.match(UL4Parser.IS)
                        self.state = 508
                        localctx.right = self.expr(7)
                        pass

                    elif la_ == 21:
                        localctx = UL4Parser.IsNotContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 509
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 510
                        self.match(UL4Parser.IS)
                        self.state = 511
                        self.match(UL4Parser.NOT)
                        self.state = 512
                        localctx.right = self.expr(6)
                        pass

                    elif la_ == 22:
                        localctx = UL4Parser.AndContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 513
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 514
                        self.match(UL4Parser.AND)
                        self.state = 515
                        localctx.right = self.expr(4)
                        pass

                    elif la_ == 23:
                        localctx = UL4Parser.OrContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 516
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 517
                        self.match(UL4Parser.OR)
                        self.state = 518
                        localctx.right = self.expr(3)
                        pass

                    elif la_ == 24:
                        localctx = UL4Parser.IfContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.argif = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 519
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 520
                        self.match(UL4Parser.IF)
                        self.state = 521
                        localctx.argcond = self.expr(0)
                        self.state = 522
                        self.match(UL4Parser.ELSE)
                        self.state = 523
                        localctx.argelse = self.expr(2)
                        pass

                    elif la_ == 25:
                        localctx = UL4Parser.AttrContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.e1 = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 525
                        if not self.precpred(self._ctx, 31):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 31)")
                        self.state = 526
                        self.match(UL4Parser.DOT)
                        self.state = 527
                        localctx.n = self.name()
                        pass

                    elif la_ == 26:
                        localctx = UL4Parser.CallContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.e1 = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 528
                        if not self.precpred(self._ctx, 30):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 30)")
                        self.state = 529
                        self.match(UL4Parser.PARENS_OPEN)
                        self.state = 543
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while ((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (UL4Parser.NOT - 37)) | (1 << (UL4Parser.NONE - 37)) | (1 << (UL4Parser.TRUE - 37)) | (1 << (UL4Parser.FALSE - 37)) | (1 << (UL4Parser.PARENS_OPEN - 37)) | (1 << (UL4Parser.BRACKET_OPEN - 37)) | (1 << (UL4Parser.BRACE_OPEN - 37)) | (1 << (UL4Parser.STAR_STAR - 37)) | (1 << (UL4Parser.STAR - 37)) | (1 << (UL4Parser.MINUS - 37)) | (1 << (UL4Parser.TILDE - 37)) | (1 << (UL4Parser.NAME - 37)) | (1 << (UL4Parser.INT - 37)) | (1 << (UL4Parser.FLOAT - 37)) | (1 << (UL4Parser.DATE - 37)) | (1 << (UL4Parser.COLOR - 37)) | (1 << (UL4Parser.STRING - 37)) | (1 << (UL4Parser.STRING3 - 37)))) != 0):
                            self.state = 530
                            localctx._argument = self.argument()
                            localctx.args.append(localctx._argument)
                            self.state = 535
                            self._errHandler.sync(self)
                            _alt = self._interp.adaptivePredict(self._input,49,self._ctx)
                            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                                if _alt==1:
                                    self.state = 531
                                    self.match(UL4Parser.COMMA)
                                    self.state = 532
                                    localctx._argument = self.argument()
                                    localctx.args.append(localctx._argument) 
                                self.state = 537
                                self._errHandler.sync(self)
                                _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

                            self.state = 539
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==UL4Parser.COMMA:
                                self.state = 538
                                self.match(UL4Parser.COMMA)


                            self.state = 545
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 546
                        localctx.close = self.match(UL4Parser.PARENS_CLOSE)
                        pass

                    elif la_ == 27:
                        localctx = UL4Parser.ItemContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.e1 = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 547
                        if not self.precpred(self._ctx, 29):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 29)")
                        self.state = 548
                        self.match(UL4Parser.BRACKET_OPEN)
                        self.state = 549
                        localctx.index = self.expr(0)
                        self.state = 550
                        localctx.close = self.match(UL4Parser.BRACKET_CLOSE)
                        pass

                    elif la_ == 28:
                        localctx = UL4Parser.ItemSliceContext(self, UL4Parser.ExprContext(self, _parentctx, _parentState))
                        localctx.e1 = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 552
                        if not self.precpred(self._ctx, 28):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 28)")
                        self.state = 553
                        self.match(UL4Parser.BRACKET_OPEN)
                        self.state = 554
                        localctx.index = self.slice_()
                        self.state = 555
                        localctx.close = self.match(UL4Parser.BRACKET_CLOSE)
                        pass

             
                self.state = 561
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,53,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ExprargContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ege = None # GeneratorexpressionContext
            self.e1 = None # ExprContext

        def generatorexpression(self):
            return self.getTypedRuleContext(UL4Parser.GeneratorexpressionContext,0)


        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def getRuleIndex(self):
            return UL4Parser.RULE_exprarg

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprarg" ):
                return visitor.visitExprarg(self)
            else:
                return visitor.visitChildren(self)




    def exprarg(self):

        localctx = UL4Parser.ExprargContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_exprarg)
        try:
            self.state = 564
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 562
                localctx.ege = self.generatorexpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 563
                localctx.e1 = self.expr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExpressionGeneratorExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExpressionContext
            super().__init__(parser)
            self.ege = None # GeneratorexpressionContext
            self.copyFrom(ctx)

        def EOF(self):
            return self.getToken(UL4Parser.EOF, 0)
        def generatorexpression(self):
            return self.getTypedRuleContext(UL4Parser.GeneratorexpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionGeneratorExpression" ):
                return visitor.visitExpressionGeneratorExpression(self)
            else:
                return visitor.visitChildren(self)


    class ExpressionExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.ExpressionContext
            super().__init__(parser)
            self.e = None # ExprContext
            self.copyFrom(ctx)

        def EOF(self):
            return self.getToken(UL4Parser.EOF, 0)
        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionExpression" ):
                return visitor.visitExpressionExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self):

        localctx = UL4Parser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_expression)
        try:
            self.state = 572
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.ExpressionGeneratorExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 566
                localctx.ege = self.generatorexpression()
                self.state = 567
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 2:
                localctx = UL4Parser.ExpressionExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 569
                localctx.e = self.expr(0)
                self.state = 570
                self.match(UL4Parser.EOF)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_for_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ForContext(For_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.For_Context
            super().__init__(parser)
            self.var = None # NestedlvalueContext
            self.container = None # ExprContext
            self.copyFrom(ctx)

        def IN(self):
            return self.getToken(UL4Parser.IN, 0)
        def EOF(self):
            return self.getToken(UL4Parser.EOF, 0)
        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor" ):
                return visitor.visitFor(self)
            else:
                return visitor.visitChildren(self)



    def for_(self):

        localctx = UL4Parser.For_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_for_)
        try:
            localctx = UL4Parser.ForContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 574
            localctx.var = self.nestedlvalue()
            self.state = 575
            self.match(UL4Parser.IN)
            self.state = 576
            localctx.container = self.expr(0)
            self.state = 577
            self.match(UL4Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.nn = None # NestedlvalueContext
            self.e = None # ExprContext
            self.n = None # ExprContext
            self.ex = None # ExpressionContext

        def ASSIGN(self):
            return self.getToken(UL4Parser.ASSIGN, 0)

        def EOF(self):
            return self.getToken(UL4Parser.EOF, 0)

        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def AUGADD(self):
            return self.getToken(UL4Parser.AUGADD, 0)

        def AUGSUB(self):
            return self.getToken(UL4Parser.AUGSUB, 0)

        def AUGMUL(self):
            return self.getToken(UL4Parser.AUGMUL, 0)

        def AUGFLOORDIV(self):
            return self.getToken(UL4Parser.AUGFLOORDIV, 0)

        def AUGTRUEDIV(self):
            return self.getToken(UL4Parser.AUGTRUEDIV, 0)

        def AUGMOD(self):
            return self.getToken(UL4Parser.AUGMOD, 0)

        def AUGSHIFTLEFT(self):
            return self.getToken(UL4Parser.AUGSHIFTLEFT, 0)

        def AUGSHIFTRIGHT(self):
            return self.getToken(UL4Parser.AUGSHIFTRIGHT, 0)

        def AUGAND(self):
            return self.getToken(UL4Parser.AUGAND, 0)

        def AUGXOR(self):
            return self.getToken(UL4Parser.AUGXOR, 0)

        def AUGOR(self):
            return self.getToken(UL4Parser.AUGOR, 0)

        def expression(self):
            return self.getTypedRuleContext(UL4Parser.ExpressionContext,0)


        def getRuleIndex(self):
            return UL4Parser.RULE_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmt" ):
                return visitor.visitStmt(self)
            else:
                return visitor.visitChildren(self)




    def stmt(self):

        localctx = UL4Parser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_stmt)
        try:
            self.state = 642
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 579
                localctx.nn = self.nestedlvalue()
                self.state = 580
                self.match(UL4Parser.ASSIGN)
                self.state = 581
                localctx.e = self.expr(0)
                self.state = 582
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 584
                localctx.n = self.expr(0)
                self.state = 585
                self.match(UL4Parser.AUGADD)
                self.state = 586
                localctx.e = self.expr(0)
                self.state = 587
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 589
                localctx.n = self.expr(0)
                self.state = 590
                self.match(UL4Parser.AUGSUB)
                self.state = 591
                localctx.e = self.expr(0)
                self.state = 592
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 594
                localctx.n = self.expr(0)
                self.state = 595
                self.match(UL4Parser.AUGMUL)
                self.state = 596
                localctx.e = self.expr(0)
                self.state = 597
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 599
                localctx.n = self.expr(0)
                self.state = 600
                self.match(UL4Parser.AUGFLOORDIV)
                self.state = 601
                localctx.e = self.expr(0)
                self.state = 602
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 604
                localctx.n = self.expr(0)
                self.state = 605
                self.match(UL4Parser.AUGTRUEDIV)
                self.state = 606
                localctx.e = self.expr(0)
                self.state = 607
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 609
                localctx.n = self.expr(0)
                self.state = 610
                self.match(UL4Parser.AUGMOD)
                self.state = 611
                localctx.e = self.expr(0)
                self.state = 612
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 614
                localctx.n = self.expr(0)
                self.state = 615
                self.match(UL4Parser.AUGSHIFTLEFT)
                self.state = 616
                localctx.e = self.expr(0)
                self.state = 617
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 619
                localctx.n = self.expr(0)
                self.state = 620
                self.match(UL4Parser.AUGSHIFTRIGHT)
                self.state = 621
                localctx.e = self.expr(0)
                self.state = 622
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 624
                localctx.n = self.expr(0)
                self.state = 625
                self.match(UL4Parser.AUGAND)
                self.state = 626
                localctx.e = self.expr(0)
                self.state = 627
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 629
                localctx.n = self.expr(0)
                self.state = 630
                self.match(UL4Parser.AUGXOR)
                self.state = 631
                localctx.e = self.expr(0)
                self.state = 632
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 634
                localctx.n = self.expr(0)
                self.state = 635
                self.match(UL4Parser.AUGOR)
                self.state = 636
                localctx.e = self.expr(0)
                self.state = 637
                self.match(UL4Parser.EOF)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 639
                localctx.ex = self.expression()
                self.state = 640
                self.match(UL4Parser.EOF)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignatureContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_signature

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SignatureUnpackDictParamsContext(SignatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SignatureContext
            super().__init__(parser)
            self.open_ = None # Token
            self.rkwargsname = None # NameContext
            self.close = None # Token
            self.copyFrom(ctx)

        def STAR_STAR(self):
            return self.getToken(UL4Parser.STAR_STAR, 0)
        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def name(self):
            return self.getTypedRuleContext(UL4Parser.NameContext,0)

        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def COMMA(self):
            return self.getToken(UL4Parser.COMMA, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignatureUnpackDictParams" ):
                return visitor.visitSignatureUnpackDictParams(self)
            else:
                return visitor.visitChildren(self)


    class SignatureDefaultParamsContext(SignatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SignatureContext
            super().__init__(parser)
            self.open_ = None # Token
            self._name = None # NameContext
            self.names = list() # of NameContexts
            self._exprarg = None # ExprargContext
            self.defaults = list() # of ExprargContexts
            self.rargsname = None # NameContext
            self.rkwargsname = None # NameContext
            self.close = None # Token
            self.copyFrom(ctx)

        def ASSIGN(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ASSIGN)
            else:
                return self.getToken(UL4Parser.ASSIGN, i)
        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.NameContext)
            else:
                return self.getTypedRuleContext(UL4Parser.NameContext,i)

        def exprarg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprargContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprargContext,i)

        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)
        def STAR(self):
            return self.getToken(UL4Parser.STAR, 0)
        def STAR_STAR(self):
            return self.getToken(UL4Parser.STAR_STAR, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignatureDefaultParams" ):
                return visitor.visitSignatureDefaultParams(self)
            else:
                return visitor.visitChildren(self)


    class SignatureUnpackParamsContext(SignatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SignatureContext
            super().__init__(parser)
            self.open_ = None # Token
            self.rargsname = None # NameContext
            self.rkwargsname = None # NameContext
            self.close = None # Token
            self.copyFrom(ctx)

        def STAR(self):
            return self.getToken(UL4Parser.STAR, 0)
        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.NameContext)
            else:
                return self.getTypedRuleContext(UL4Parser.NameContext,i)

        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)
        def STAR_STAR(self):
            return self.getToken(UL4Parser.STAR_STAR, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignatureUnpackParams" ):
                return visitor.visitSignatureUnpackParams(self)
            else:
                return visitor.visitChildren(self)


    class SignatureNoParamsContext(SignatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SignatureContext
            super().__init__(parser)
            self.open_ = None # Token
            self.close = None # Token
            self.copyFrom(ctx)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignatureNoParams" ):
                return visitor.visitSignatureNoParams(self)
            else:
                return visitor.visitChildren(self)


    class SignatureAnyParamsContext(SignatureContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.SignatureContext
            super().__init__(parser)
            self.open_ = None # Token
            self._name = None # NameContext
            self.names_without_defaults = list() # of NameContexts
            self.names_with_defaults = list() # of NameContexts
            self._exprarg = None # ExprargContext
            self.defaults = list() # of ExprargContexts
            self.rargsname = None # NameContext
            self.rkwargsname = None # NameContext
            self.close = None # Token
            self.copyFrom(ctx)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)
        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.NameContext)
            else:
                return self.getTypedRuleContext(UL4Parser.NameContext,i)

        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)
        def ASSIGN(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ASSIGN)
            else:
                return self.getToken(UL4Parser.ASSIGN, i)
        def STAR(self):
            return self.getToken(UL4Parser.STAR, 0)
        def STAR_STAR(self):
            return self.getToken(UL4Parser.STAR_STAR, 0)
        def exprarg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprargContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprargContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignatureAnyParams" ):
                return visitor.visitSignatureAnyParams(self)
            else:
                return visitor.visitChildren(self)



    def signature(self):

        localctx = UL4Parser.SignatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_signature)
        self._la = 0 # Token type
        try:
            self.state = 730
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                localctx = UL4Parser.SignatureNoParamsContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 644
                localctx.open_ = self.match(UL4Parser.PARENS_OPEN)
                self.state = 645
                localctx.close = self.match(UL4Parser.PARENS_CLOSE)
                pass

            elif la_ == 2:
                localctx = UL4Parser.SignatureUnpackDictParamsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 646
                localctx.open_ = self.match(UL4Parser.PARENS_OPEN)
                self.state = 647
                self.match(UL4Parser.STAR_STAR)
                self.state = 648
                localctx.rkwargsname = self.name()
                self.state = 650
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 649
                    self.match(UL4Parser.COMMA)


                self.state = 652
                localctx.close = self.match(UL4Parser.PARENS_CLOSE)
                pass

            elif la_ == 3:
                localctx = UL4Parser.SignatureUnpackParamsContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 654
                localctx.open_ = self.match(UL4Parser.PARENS_OPEN)
                self.state = 655
                self.match(UL4Parser.STAR)
                self.state = 656
                localctx.rargsname = self.name()
                self.state = 660
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                if la_ == 1:
                    self.state = 657
                    self.match(UL4Parser.COMMA)
                    self.state = 658
                    self.match(UL4Parser.STAR_STAR)
                    self.state = 659
                    localctx.rkwargsname = self.name()


                self.state = 663
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 662
                    self.match(UL4Parser.COMMA)


                self.state = 665
                localctx.close = self.match(UL4Parser.PARENS_CLOSE)
                pass

            elif la_ == 4:
                localctx = UL4Parser.SignatureDefaultParamsContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 667
                localctx.open_ = self.match(UL4Parser.PARENS_OPEN)
                self.state = 668
                localctx._name = self.name()
                localctx.names.append(localctx._name)
                self.state = 669
                self.match(UL4Parser.ASSIGN)
                self.state = 670
                localctx._exprarg = self.exprarg()
                localctx.defaults.append(localctx._exprarg)
                self.state = 678
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,60,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 671
                        self.match(UL4Parser.COMMA)
                        self.state = 672
                        localctx._name = self.name()
                        localctx.names.append(localctx._name)
                        self.state = 673
                        self.match(UL4Parser.ASSIGN)
                        self.state = 674
                        localctx._exprarg = self.exprarg()
                        localctx.defaults.append(localctx._exprarg) 
                    self.state = 680
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,60,self._ctx)

                self.state = 684
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
                if la_ == 1:
                    self.state = 681
                    self.match(UL4Parser.COMMA)
                    self.state = 682
                    self.match(UL4Parser.STAR)
                    self.state = 683
                    localctx.rargsname = self.name()


                self.state = 689
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 686
                    self.match(UL4Parser.COMMA)
                    self.state = 687
                    self.match(UL4Parser.STAR_STAR)
                    self.state = 688
                    localctx.rkwargsname = self.name()


                self.state = 692
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 691
                    self.match(UL4Parser.COMMA)


                self.state = 694
                localctx.close = self.match(UL4Parser.PARENS_CLOSE)
                pass

            elif la_ == 5:
                localctx = UL4Parser.SignatureAnyParamsContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 696
                localctx.open_ = self.match(UL4Parser.PARENS_OPEN)
                self.state = 697
                localctx._name = self.name()
                localctx.names_without_defaults.append(localctx._name)
                self.state = 702
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 698
                        self.match(UL4Parser.COMMA)
                        self.state = 699
                        localctx._name = self.name()
                        localctx.names_without_defaults.append(localctx._name) 
                    self.state = 704
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

                self.state = 712
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,65,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 705
                        self.match(UL4Parser.COMMA)
                        self.state = 706
                        localctx._name = self.name()
                        localctx.names_with_defaults.append(localctx._name)
                        self.state = 707
                        self.match(UL4Parser.ASSIGN)
                        self.state = 708
                        localctx._exprarg = self.exprarg()
                        localctx.defaults.append(localctx._exprarg) 
                    self.state = 714
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,65,self._ctx)

                self.state = 718
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
                if la_ == 1:
                    self.state = 715
                    self.match(UL4Parser.COMMA)
                    self.state = 716
                    self.match(UL4Parser.STAR)
                    self.state = 717
                    localctx.rargsname = self.name()


                self.state = 723
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
                if la_ == 1:
                    self.state = 720
                    self.match(UL4Parser.COMMA)
                    self.state = 721
                    self.match(UL4Parser.STAR_STAR)
                    self.state = 722
                    localctx.rkwargsname = self.name()


                self.state = 726
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 725
                    self.match(UL4Parser.COMMA)


                self.state = 728
                localctx.close = self.match(UL4Parser.PARENS_CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # NameContext
            self.sig = None # SignatureContext

        def name(self):
            return self.getTypedRuleContext(UL4Parser.NameContext,0)


        def signature(self):
            return self.getTypedRuleContext(UL4Parser.SignatureContext,0)


        def getRuleIndex(self):
            return UL4Parser.RULE_definition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinition" ):
                return visitor.visitDefinition(self)
            else:
                return visitor.visitChildren(self)




    def definition(self):

        localctx = UL4Parser.DefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 733
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.NAME:
                self.state = 732
                localctx.n = self.name()


            self.state = 736
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.PARENS_OPEN:
                self.state = 735
                localctx.sig = self.signature()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefblockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.content = None # Block_contentContext

        def MAYBETAG_DEF(self):
            return self.getToken(UL4Parser.MAYBETAG_DEF, 0)

        def definition(self):
            return self.getTypedRuleContext(UL4Parser.DefinitionContext,0)


        def ENDDELIM(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ENDDELIM)
            else:
                return self.getToken(UL4Parser.ENDDELIM, i)

        def MAYBETAG_END(self):
            return self.getToken(UL4Parser.MAYBETAG_END, 0)

        def DEFAULT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.DEFAULT_MAYBETAG, i)

        def TEXT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.TEXT_MAYBETAG, i)

        def DEF(self):
            return self.getToken(UL4Parser.DEF, 0)

        def block_content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.Block_contentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.Block_contentContext,i)


        def getRuleIndex(self):
            return UL4Parser.RULE_defblock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefblock" ):
                return visitor.visitDefblock(self)
            else:
                return visitor.visitChildren(self)




    def defblock(self):

        localctx = UL4Parser.DefblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_defblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 738
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 739
            self.match(UL4Parser.MAYBETAG_DEF)
            self.state = 740
            self.definition()
            self.state = 741
            self.match(UL4Parser.ENDDELIM)
            self.state = 745
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,72,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 742
                    localctx.content = self.block_content() 
                self.state = 747
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,72,self._ctx)

            self.state = 748
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 749
            self.match(UL4Parser.MAYBETAG_END)
            self.state = 751
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.DEF:
                self.state = 750
                self.match(UL4Parser.DEF)


            self.state = 753
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForblockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.var = None # NestedlvalueContext
            self.container = None # ExprContext
            self.content = None # Block_contentContext

        def MAYBETAG_FOR(self):
            return self.getToken(UL4Parser.MAYBETAG_FOR, 0)

        def IN(self):
            return self.getToken(UL4Parser.IN, 0)

        def ENDDELIM(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ENDDELIM)
            else:
                return self.getToken(UL4Parser.ENDDELIM, i)

        def MAYBETAG_END(self):
            return self.getToken(UL4Parser.MAYBETAG_END, 0)

        def DEFAULT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.DEFAULT_MAYBETAG, i)

        def TEXT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.TEXT_MAYBETAG, i)

        def nestedlvalue(self):
            return self.getTypedRuleContext(UL4Parser.NestedlvalueContext,0)


        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def FOR(self):
            return self.getToken(UL4Parser.FOR, 0)

        def block_content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.Block_contentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.Block_contentContext,i)


        def getRuleIndex(self):
            return UL4Parser.RULE_forblock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForblock" ):
                return visitor.visitForblock(self)
            else:
                return visitor.visitChildren(self)




    def forblock(self):

        localctx = UL4Parser.ForblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_forblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 755
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 756
            self.match(UL4Parser.MAYBETAG_FOR)
            self.state = 757
            localctx.var = self.nestedlvalue()
            self.state = 758
            self.match(UL4Parser.IN)
            self.state = 759
            localctx.container = self.expr(0)
            self.state = 760
            self.match(UL4Parser.ENDDELIM)
            self.state = 764
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,74,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 761
                    localctx.content = self.block_content() 
                self.state = 766
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,74,self._ctx)

            self.state = 767
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 768
            self.match(UL4Parser.MAYBETAG_END)
            self.state = 770
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.FOR:
                self.state = 769
                self.match(UL4Parser.FOR)


            self.state = 772
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileblockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None # ExprContext
            self.content = None # Block_contentContext

        def MAYBETAG_WHILE(self):
            return self.getToken(UL4Parser.MAYBETAG_WHILE, 0)

        def ENDDELIM(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ENDDELIM)
            else:
                return self.getToken(UL4Parser.ENDDELIM, i)

        def MAYBETAG_END(self):
            return self.getToken(UL4Parser.MAYBETAG_END, 0)

        def DEFAULT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.DEFAULT_MAYBETAG, i)

        def TEXT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.TEXT_MAYBETAG, i)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def WHILE(self):
            return self.getToken(UL4Parser.WHILE, 0)

        def block_content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.Block_contentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.Block_contentContext,i)


        def getRuleIndex(self):
            return UL4Parser.RULE_whileblock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileblock" ):
                return visitor.visitWhileblock(self)
            else:
                return visitor.visitChildren(self)




    def whileblock(self):

        localctx = UL4Parser.WhileblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_whileblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 774
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 775
            self.match(UL4Parser.MAYBETAG_WHILE)
            self.state = 776
            localctx.cond = self.expr(0)
            self.state = 777
            self.match(UL4Parser.ENDDELIM)
            self.state = 781
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,76,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 778
                    localctx.content = self.block_content() 
                self.state = 783
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,76,self._ctx)

            self.state = 784
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 785
            self.match(UL4Parser.MAYBETAG_END)
            self.state = 787
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.WHILE:
                self.state = 786
                self.match(UL4Parser.WHILE)


            self.state = 789
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfblockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None # ExprContext
            self.content = None # Block_contentContext

        def MAYBETAG_IF(self):
            return self.getToken(UL4Parser.MAYBETAG_IF, 0)

        def ENDDELIM(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ENDDELIM)
            else:
                return self.getToken(UL4Parser.ENDDELIM, i)

        def MAYBETAG_END(self):
            return self.getToken(UL4Parser.MAYBETAG_END, 0)

        def DEFAULT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.DEFAULT_MAYBETAG, i)

        def TEXT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.TEXT_MAYBETAG, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ExprContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ExprContext,i)


        def MAYBETAG_ELSE(self):
            return self.getToken(UL4Parser.MAYBETAG_ELSE, 0)

        def MAYBETAG_ELIF(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.MAYBETAG_ELIF)
            else:
                return self.getToken(UL4Parser.MAYBETAG_ELIF, i)

        def IF(self):
            return self.getToken(UL4Parser.IF, 0)

        def block_content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.Block_contentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.Block_contentContext,i)


        def getRuleIndex(self):
            return UL4Parser.RULE_ifblock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfblock" ):
                return visitor.visitIfblock(self)
            else:
                return visitor.visitChildren(self)




    def ifblock(self):

        localctx = UL4Parser.IfblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_ifblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 791
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 792
            self.match(UL4Parser.MAYBETAG_IF)
            self.state = 793
            localctx.cond = self.expr(0)
            self.state = 794
            self.match(UL4Parser.ENDDELIM)
            self.state = 798
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,78,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 795
                    localctx.content = self.block_content() 
                self.state = 800
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,78,self._ctx)

            self.state = 813
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,80,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 801
                    _la = self._input.LA(1)
                    if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 802
                    self.match(UL4Parser.MAYBETAG_ELIF)
                    self.state = 803
                    localctx.cond = self.expr(0)
                    self.state = 804
                    self.match(UL4Parser.ENDDELIM)
                    self.state = 808
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 805
                            localctx.content = self.block_content() 
                        self.state = 810
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
             
                self.state = 815
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,80,self._ctx)

            self.state = 816
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 817
            self.match(UL4Parser.MAYBETAG_ELSE)
            self.state = 818
            self.match(UL4Parser.ENDDELIM)
            self.state = 822
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,81,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 819
                    localctx.content = self.block_content() 
                self.state = 824
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,81,self._ctx)

            self.state = 825
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 826
            self.match(UL4Parser.MAYBETAG_END)
            self.state = 828
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.IF:
                self.state = 827
                self.match(UL4Parser.IF)


            self.state = 830
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RenderblockblockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.e1 = None # ExprContext
            self._argument = None # ArgumentContext
            self.args = list() # of ArgumentContexts
            self.close = None # Token
            self.content = None # Block_contentContext

        def MAYBETAG_RENDERBLOCK(self):
            return self.getToken(UL4Parser.MAYBETAG_RENDERBLOCK, 0)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)

        def ENDDELIM(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ENDDELIM)
            else:
                return self.getToken(UL4Parser.ENDDELIM, i)

        def MAYBETAG_END(self):
            return self.getToken(UL4Parser.MAYBETAG_END, 0)

        def DEFAULT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.DEFAULT_MAYBETAG, i)

        def TEXT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.TEXT_MAYBETAG, i)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)

        def RENDERBLOCK(self):
            return self.getToken(UL4Parser.RENDERBLOCK, 0)

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ArgumentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ArgumentContext,i)


        def block_content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.Block_contentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.Block_contentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_renderblockblock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenderblockblock" ):
                return visitor.visitRenderblockblock(self)
            else:
                return visitor.visitChildren(self)




    def renderblockblock(self):

        localctx = UL4Parser.RenderblockblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_renderblockblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 833
            self.match(UL4Parser.MAYBETAG_RENDERBLOCK)
            self.state = 834
            localctx.e1 = self.expr(0)
            self.state = 835
            self.match(UL4Parser.PARENS_OPEN)
            self.state = 849
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (UL4Parser.NOT - 37)) | (1 << (UL4Parser.NONE - 37)) | (1 << (UL4Parser.TRUE - 37)) | (1 << (UL4Parser.FALSE - 37)) | (1 << (UL4Parser.PARENS_OPEN - 37)) | (1 << (UL4Parser.BRACKET_OPEN - 37)) | (1 << (UL4Parser.BRACE_OPEN - 37)) | (1 << (UL4Parser.STAR_STAR - 37)) | (1 << (UL4Parser.STAR - 37)) | (1 << (UL4Parser.MINUS - 37)) | (1 << (UL4Parser.TILDE - 37)) | (1 << (UL4Parser.NAME - 37)) | (1 << (UL4Parser.INT - 37)) | (1 << (UL4Parser.FLOAT - 37)) | (1 << (UL4Parser.DATE - 37)) | (1 << (UL4Parser.COLOR - 37)) | (1 << (UL4Parser.STRING - 37)) | (1 << (UL4Parser.STRING3 - 37)))) != 0):
                self.state = 836
                localctx._argument = self.argument()
                localctx.args.append(localctx._argument)
                self.state = 841
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,83,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 837
                        self.match(UL4Parser.COMMA)
                        self.state = 838
                        localctx._argument = self.argument()
                        localctx.args.append(localctx._argument) 
                    self.state = 843
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,83,self._ctx)

                self.state = 845
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 844
                    self.match(UL4Parser.COMMA)


                self.state = 851
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 852
            localctx.close = self.match(UL4Parser.PARENS_CLOSE)
            self.state = 853
            self.match(UL4Parser.ENDDELIM)
            self.state = 857
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 854
                    localctx.content = self.block_content() 
                self.state = 859
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

            self.state = 860
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 861
            self.match(UL4Parser.MAYBETAG_END)
            self.state = 863
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.RENDERBLOCK:
                self.state = 862
                self.match(UL4Parser.RENDERBLOCK)


            self.state = 865
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RenderblocksblockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.e1 = None # ExprContext
            self._argument = None # ArgumentContext
            self.args = list() # of ArgumentContexts
            self.close = None # Token
            self.content = None # Block_contentContext

        def MAYBETAG_RENDERBLOCKS(self):
            return self.getToken(UL4Parser.MAYBETAG_RENDERBLOCKS, 0)

        def PARENS_OPEN(self):
            return self.getToken(UL4Parser.PARENS_OPEN, 0)

        def ENDDELIM(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.ENDDELIM)
            else:
                return self.getToken(UL4Parser.ENDDELIM, i)

        def MAYBETAG_END(self):
            return self.getToken(UL4Parser.MAYBETAG_END, 0)

        def DEFAULT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.DEFAULT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.DEFAULT_MAYBETAG, i)

        def TEXT_MAYBETAG(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXT_MAYBETAG)
            else:
                return self.getToken(UL4Parser.TEXT_MAYBETAG, i)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def PARENS_CLOSE(self):
            return self.getToken(UL4Parser.PARENS_CLOSE, 0)

        def RENDERBLOCKS(self):
            return self.getToken(UL4Parser.RENDERBLOCKS, 0)

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.ArgumentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.ArgumentContext,i)


        def block_content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(UL4Parser.Block_contentContext)
            else:
                return self.getTypedRuleContext(UL4Parser.Block_contentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.COMMA)
            else:
                return self.getToken(UL4Parser.COMMA, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_renderblocksblock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenderblocksblock" ):
                return visitor.visitRenderblocksblock(self)
            else:
                return visitor.visitChildren(self)




    def renderblocksblock(self):

        localctx = UL4Parser.RenderblocksblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_renderblocksblock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 867
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 868
            self.match(UL4Parser.MAYBETAG_RENDERBLOCKS)
            self.state = 869
            localctx.e1 = self.expr(0)
            self.state = 870
            self.match(UL4Parser.PARENS_OPEN)
            self.state = 884
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (UL4Parser.NOT - 37)) | (1 << (UL4Parser.NONE - 37)) | (1 << (UL4Parser.TRUE - 37)) | (1 << (UL4Parser.FALSE - 37)) | (1 << (UL4Parser.PARENS_OPEN - 37)) | (1 << (UL4Parser.BRACKET_OPEN - 37)) | (1 << (UL4Parser.BRACE_OPEN - 37)) | (1 << (UL4Parser.STAR_STAR - 37)) | (1 << (UL4Parser.STAR - 37)) | (1 << (UL4Parser.MINUS - 37)) | (1 << (UL4Parser.TILDE - 37)) | (1 << (UL4Parser.NAME - 37)) | (1 << (UL4Parser.INT - 37)) | (1 << (UL4Parser.FLOAT - 37)) | (1 << (UL4Parser.DATE - 37)) | (1 << (UL4Parser.COLOR - 37)) | (1 << (UL4Parser.STRING - 37)) | (1 << (UL4Parser.STRING3 - 37)))) != 0):
                self.state = 871
                localctx._argument = self.argument()
                localctx.args.append(localctx._argument)
                self.state = 876
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,88,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 872
                        self.match(UL4Parser.COMMA)
                        self.state = 873
                        localctx._argument = self.argument()
                        localctx.args.append(localctx._argument) 
                    self.state = 878
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,88,self._ctx)

                self.state = 880
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==UL4Parser.COMMA:
                    self.state = 879
                    self.match(UL4Parser.COMMA)


                self.state = 886
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 887
            localctx.close = self.match(UL4Parser.PARENS_CLOSE)
            self.state = 888
            self.match(UL4Parser.ENDDELIM)
            self.state = 892
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,91,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 889
                    localctx.content = self.block_content() 
                self.state = 894
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,91,self._ctx)

            self.state = 895
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 896
            self.match(UL4Parser.MAYBETAG_END)
            self.state = 898
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==UL4Parser.RENDERBLOCKS:
                self.state = 897
                self.match(UL4Parser.RENDERBLOCKS)


            self.state = 900
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrinttagContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAYBETAG_PRINT(self):
            return self.getToken(UL4Parser.MAYBETAG_PRINT, 0)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def ENDDELIM(self):
            return self.getToken(UL4Parser.ENDDELIM, 0)

        def DEFAULT_MAYBETAG(self):
            return self.getToken(UL4Parser.DEFAULT_MAYBETAG, 0)

        def TEXT_MAYBETAG(self):
            return self.getToken(UL4Parser.TEXT_MAYBETAG, 0)

        def MAYBETAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.MAYBETAG_WS)
            else:
                return self.getToken(UL4Parser.MAYBETAG_WS, i)

        def TEXTTAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXTTAG_WS)
            else:
                return self.getToken(UL4Parser.TEXTTAG_WS, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_printtag

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrinttag" ):
                return visitor.visitPrinttag(self)
            else:
                return visitor.visitChildren(self)




    def printtag(self):

        localctx = UL4Parser.PrinttagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_printtag)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 902
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 906
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.MAYBETAG_WS:
                self.state = 903
                self.match(UL4Parser.MAYBETAG_WS)
                self.state = 908
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 909
            self.match(UL4Parser.MAYBETAG_PRINT)
            self.state = 913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.TEXTTAG_WS:
                self.state = 910
                self.match(UL4Parser.TEXTTAG_WS)
                self.state = 915
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 916
            self.expr(0)
            self.state = 920
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.TEXTTAG_WS:
                self.state = 917
                self.match(UL4Parser.TEXTTAG_WS)
                self.state = 922
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 923
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintxtagContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAYBETAG_PRINTX(self):
            return self.getToken(UL4Parser.MAYBETAG_PRINTX, 0)

        def expr(self):
            return self.getTypedRuleContext(UL4Parser.ExprContext,0)


        def ENDDELIM(self):
            return self.getToken(UL4Parser.ENDDELIM, 0)

        def DEFAULT_MAYBETAG(self):
            return self.getToken(UL4Parser.DEFAULT_MAYBETAG, 0)

        def TEXT_MAYBETAG(self):
            return self.getToken(UL4Parser.TEXT_MAYBETAG, 0)

        def MAYBETAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.MAYBETAG_WS)
            else:
                return self.getToken(UL4Parser.MAYBETAG_WS, i)

        def TEXTTAG_WS(self, i:int=None):
            if i is None:
                return self.getTokens(UL4Parser.TEXTTAG_WS)
            else:
                return self.getToken(UL4Parser.TEXTTAG_WS, i)

        def getRuleIndex(self):
            return UL4Parser.RULE_printxtag

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintxtag" ):
                return visitor.visitPrintxtag(self)
            else:
                return visitor.visitChildren(self)




    def printxtag(self):

        localctx = UL4Parser.PrintxtagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_printxtag)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 925
            _la = self._input.LA(1)
            if not(_la==UL4Parser.DEFAULT_MAYBETAG or _la==UL4Parser.TEXT_MAYBETAG):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 929
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.MAYBETAG_WS:
                self.state = 926
                self.match(UL4Parser.MAYBETAG_WS)
                self.state = 931
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 932
            self.match(UL4Parser.MAYBETAG_PRINTX)
            self.state = 936
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.TEXTTAG_WS:
                self.state = 933
                self.match(UL4Parser.TEXTTAG_WS)
                self.state = 938
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 939
            self.expr(0)
            self.state = 943
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==UL4Parser.TEXTTAG_WS:
                self.state = 940
                self.match(UL4Parser.TEXTTAG_WS)
                self.state = 945
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 946
            self.match(UL4Parser.ENDDELIM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Block_contentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defblock(self):
            return self.getTypedRuleContext(UL4Parser.DefblockContext,0)


        def forblock(self):
            return self.getTypedRuleContext(UL4Parser.ForblockContext,0)


        def whileblock(self):
            return self.getTypedRuleContext(UL4Parser.WhileblockContext,0)


        def ifblock(self):
            return self.getTypedRuleContext(UL4Parser.IfblockContext,0)


        def printtag(self):
            return self.getTypedRuleContext(UL4Parser.PrinttagContext,0)


        def printxtag(self):
            return self.getTypedRuleContext(UL4Parser.PrintxtagContext,0)


        def indent(self):
            return self.getTypedRuleContext(UL4Parser.IndentContext,0)


        def text(self):
            return self.getTypedRuleContext(UL4Parser.TextContext,0)


        def lineend(self):
            return self.getTypedRuleContext(UL4Parser.LineendContext,0)


        def getRuleIndex(self):
            return UL4Parser.RULE_block_content

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_content" ):
                return visitor.visitBlock_content(self)
            else:
                return visitor.visitChildren(self)




    def block_content(self):

        localctx = UL4Parser.Block_contentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_block_content)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 957
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 948
                self.defblock()
                pass

            elif la_ == 2:
                self.state = 949
                self.forblock()
                pass

            elif la_ == 3:
                self.state = 950
                self.whileblock()
                pass

            elif la_ == 4:
                self.state = 951
                self.ifblock()
                pass

            elif la_ == 5:
                self.state = 952
                self.printtag()
                pass

            elif la_ == 6:
                self.state = 953
                self.printxtag()
                pass

            elif la_ == 7:
                self.state = 954
                self.indent()
                pass

            elif la_ == 8:
                self.state = 955
                self.text()
                pass

            elif la_ == 9:
                self.state = 956
                self.lineend()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Template_contentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return UL4Parser.RULE_template_content

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Template_content2Context(Template_contentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a UL4Parser.Template_contentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def whitespacetag(self):
            return self.getTypedRuleContext(UL4Parser.WhitespacetagContext,0)

        def doctag(self):
            return self.getTypedRuleContext(UL4Parser.DoctagContext,0)

        def notetag(self):
            return self.getTypedRuleContext(UL4Parser.NotetagContext,0)

        def block_content(self):
            return self.getTypedRuleContext(UL4Parser.Block_contentContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemplate_content2" ):
                return visitor.visitTemplate_content2(self)
            else:
                return visitor.visitChildren(self)



    def template_content(self):

        localctx = UL4Parser.Template_contentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_template_content)
        try:
            localctx = UL4Parser.Template_content2Context(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 963
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 959
                self.whitespacetag()
                pass

            elif la_ == 2:
                self.state = 960
                self.doctag()
                pass

            elif la_ == 3:
                self.state = 961
                self.notetag()
                pass

            elif la_ == 4:
                self.state = 962
                self.block_content()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[32] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 25)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 24)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 23)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 22)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 22:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 1)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 31)
         

            if predIndex == 25:
                return self.precpred(self._ctx, 30)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 29)
         

            if predIndex == 27:
                return self.precpred(self._ctx, 28)
         




